#include"includes/includes.nvgt"

void main()
{
keyhook.install();
dummy.load("dummy");
sound_global_hrtf = hrtf;
initialize_sound_pools();
getver();
show_window("Simple fighter, version "+version);
if(gamstence.is_already_running)
{
alert("error", "You can only have one instence of this game running!");
exit();
}
else
{
init_bone_damage();
load_scriptkeys();
charparse();
shieldparse();
weaponparse();
if (!directory_exists(savePath)) directory_create(savePath);
readpreffs();
mainmenu();
}
}

void getver()
{
dockver.open("docks/version.txt","rb");
version=dockver.read();
dockver.close();
}

void setupgame()
{
update_ambsources(me.x,me.y);
update_musicambs(me.x,me.y);
update_sound_pools();
check_weapon_reload();

checkdeath();
checkloc();
checkpassages();
checkpspassages();
calandercheck();
clockcheck();
dest_platcheck();
dest_stairscheck();
dest_wallcheck();
doorcheck();
elvcheck();
fallcheck();
hazardcheck();
mhazardcheck();
mplatcheck();
psdoorcheck();
signcheck();
spawncheck();
stairscheck();
stuncheck();
textcheck();
turbcheck();
travelcheck();

animalloop();
animalzoneloop();
beltloop();
bikeloop();
bossloop();
bfloop();
bulletloop();
bombloop();
bombzoneloop();
camloop();
cploop();
dlgloop();
doorloop();
elvloop();
forceloop();
healzoneloop();
helperloop();
humiloop();
humanzoneloop();
liftloop();
mineloop();
menuzoneloop();
objloop();
objzoneloop();
psdoorloop();
plainloop();
projloop();
projzoneloop();
robloop();
robotzoneloop();
spikeloop();
telloop();
timebombloop();
timedmrcloop();
timedsrcloop();
timedtxtloop();
turretloop();
vplatloop();
vehloop();
zombloop();
zombiezoneloop();

apply_reverb_pools();
game_input();
}
void dockread(const string&in filename)
{
if(!file_exists(filename))
{
alert("Error","Could not fined "+string_replace(filename, "docks/", "", true));
docksmenu();
}
dockfile.open(filename,"rb");
string docktext=dockfile.read();
dockfile.close();
form.reset();
form.create_window("Viewing "+string_replace(filename, "docks/", "", true),false,false,false);
int dockbox=form.create_input_box(string_replace(filename, "docks/", "", true), docktext, read_only:true, multiline:true);
int dockclose=form.create_button("&close",false,true);
form.focus(dockbox);
while(true)
{
wait(5);
form.monitor();
if (form.is_pressed(dockclose))
{
docksmenu();
}
}
}

void fade_multi_pool(int fade_mode)
{
sound_pool@[] pools = {p, animalpool, beltpool, bikepool, bodypool, bombpool, bosspool, breakerpool, bulletpool, calpool, campool, clockpool, checkpool, doorpool, psdoorpool, elvpool, forcepool, humanpool, hazardpool, healpool, helperpool, itempool, liftpool, minepool, muspool, musambpool, plainpool, platpool, passagepool, pspassagepool, projpool, robpool, safepool, signpool, sourcepool, sourceambpool, spikepool, sucampool, telpool, timemuspool, timesourcepool, turpool, vehpool, vanpool, zombpool};
if(fade_mode==0)
{
fade_pitch_pool(pools);
}
if(fade_mode==1)
{
fade_volume_pool(pools);
}
}
void fade_pitch_pool(sound_pool@[] handles, double time=20, double minpitch=20, double amount=2)
{
bool all_faded = false;    
while(!all_faded)
{
all_faded = true;
for(uint h=0; h<handles.length(); h++)
{
for(uint i=0; i<handles[h].items.length(); i++)
{
if(@handles[h].items[i].handle!=null && handles[h].items[i].handle.playing)
{
double current_pitch = handles[h].items[i].handle.pitch;
if(current_pitch > minpitch)
{
double new_pitch = current_pitch - amount;
if(new_pitch < minpitch)
new_pitch = minpitch;
handles[h].items[i].handle.pitch = new_pitch;
all_faded = false;
}
}
}
}
wait(time);
}    
for(uint h=0; h<handles.length(); h++)
{
handles[h].destroy_all();
}
}
void fade_volume_pool(sound_pool@[] handles, double time=0.25, double minvol=-50)
{
for(double current=0; current>minvol; current-=time)
{
for(uint h=0; h<handles.length(); h++)
{
for(uint x=0; x<handles[h].items.length(); x++)
{
if(@handles[h].items[x].handle==null)
continue;
if(handles[h].items[x].handle.playing==false)
continue;
handles[h].items[x].handle.volume = handles[h].items[x].handle.volume-time;
}
}
wait(5);
}
for(uint h=0; h<handles.length(); h++)
{
handles[h].destroy_all();
}
}

void initialize_sound_pools()
{
sound_pool@[] pools = {p, animalpool, beltpool, bikepool, bodypool, bombpool, bosspool, breakerpool, bulletpool, calpool, campool, clockpool, checkpool, doorpool, psdoorpool, elvpool, forcepool, humanpool, hazardpool, healpool, helperpool, itempool, liftpool, minepool, muspool, musambpool, plainpool, platpool, passagepool, pspassagepool, projpool, robpool, safepool, signpool, sourcepool, sourceambpool, spikepool, sucampool, telpool, timemuspool, timesourcepool, turpool, vehpool, vanpool, zombpool};
for (uint i = 0; i < pools.length(); i++)
{
@pools[i].mixer = mixer();
pools[i].max_distance = 0;
pools[i].pan_step = 2.5;
pools[i].volume_step = 2.5;
}
}
void update_sound_pools()
{
sound_pool@[] pools = {p, animalpool, beltpool, bikepool, bodypool, bombpool, bosspool, breakerpool, bulletpool, calpool, campool, clockpool, checkpool, doorpool, psdoorpool, elvpool, forcepool, humanpool, hazardpool, healpool, helperpool, itempool, liftpool, minepool, muspool, musambpool, plainpool, platpool, passagepool, pspassagepool, projpool, robpool, safepool, signpool, sourcepool, sourceambpool, spikepool, sucampool, telpool, timemuspool, timesourcepool, turpool, vehpool, vanpool, zombpool};
for (uint i = 0; i < pools.length(); i++)
{
pools[i].update_listener_2d(me.x, me.y);
}
}

void pause_pools()
{
sound_pool@[] pools = {animalpool, beltpool, bikepool, bodypool, bombpool, bosspool, breakerpool, bulletpool, calpool, campool, clockpool, checkpool, doorpool, psdoorpool, elvpool, forcepool, humanpool, hazardpool, healpool, helperpool, itempool, liftpool, minepool, muspool, musambpool, plainpool, platpool, passagepool, pspassagepool, projpool, robpool, safepool, signpool, sourcepool, sourceambpool, spikepool, sucampool, telpool, timemuspool, timesourcepool, turpool, vehpool, vanpool, zombpool};
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            if(@pools[h].items[i].handle == null)
                continue;
            if(pools[h].items[i].handle.playing == false)
                continue;
            pools[h].pause_sound(i);
        }
    }
}
void resume_pools()
{
sound_pool@[] pools = {animalpool, beltpool, bikepool, bodypool, bombpool, bosspool, breakerpool, bulletpool, calpool, campool, clockpool, checkpool, doorpool, psdoorpool, elvpool, forcepool, humanpool, hazardpool, healpool, helperpool, itempool, liftpool, minepool, muspool, musambpool, plainpool, platpool, passagepool, pspassagepool, projpool, robpool, safepool, signpool, sourcepool, sourceambpool, spikepool, sucampool, telpool, timemuspool, timesourcepool, turpool, vehpool, vanpool, zombpool};
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            pools[h].resume_sound(i);
        }
    }
}

void pause_game()
{
paused=1;
pause_pools();
cammable=false;
fireable=false;
healable=false;
jumpable=false;
moveable=false;
quittable=false;
speedable=false;
spawnable=false;
sittable=false;
telable=false;
turnable=false;
}
void resume_game()
{
paused=0;
resume_pools();
cammable=true;
fireable=true;
healable=true;
jumpable=true;
moveable=true;
quittable=true;
speedable=true;
spawnable=true;
sittable=true;
telable=true;
turnable=true;
}

void resetpreffs()
{
chartype="default";
keyboardtheme="keyboard";
soundpack="default";
soundcard="Default";
sound_output_device=1;
menutype="default";
autojump=0;
fademode=0;
heartsound=0;
wallbump=true;
turnmode=0;
maploadbeeps=1;
maploadsounds=1;
pausem=0;
spacehold=1;
hidedocks=false;
hidemaps=false;
hidesets=false;
hrtf=false;
echomode=1;
menumusvolume=0;
gamxit=1;
mreset=0;
mskipnum=1;
up_down=1;
left_right=0;
home_end=0;
wrap=0;
repeat_items=0;
numbers=0;
first_letter=0;
position_info=0;
side_scroll=0;
}
void restart()
{
if(SCRIPT_COMPILED)
{
bool success=run("sf.exe","",false,false);
if(!success)
{
alert("errorr", "Unable to restart sf.exe!");
}
}
else
{
bool success=run("c:\\nvgt\\nvgtw.exe","sf.nvgt",false,false);
if(!success)
{
alert("errorr", "Unable to restart sf.nvgt!");
}
}
}
