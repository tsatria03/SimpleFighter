#pragma asset data
#pragma document docks
#pragma plugin nvgt_curl

#include"bgt_compat.nvgt"
#include "instance.nvgt"
#include"sound_pool.nvgt"

#include"includes/include_variables.nvgt"

bool directory_empty(const string&in dir)
{
if (!directory_exists(dir))
{
return false;
}
string[] files=find_files(dir+"/*");
string[] folders=find_directories(dir+"/*");
return files.length()==0 and folders.length()==0;
}

void main()
{
keyhook.install();
dummy.load("dummy");
sound_global_hrtf=true;
timeelapsed.set_timer(gametimer);
initialize_reverb_pools();
initialize_sound_pools();
getver();
set_sound_storage("data/saves/misc.dat");
set_sound_decryption_key("yLnhpXN6@VL=DP&o*7O#Uz)tNHR?!tJUaQ4RP9MO%=ZjL9B",true);
show_game_window("Simple fighter, version "+version);
if(gamstence.is_already_running)
{
alert("error", "You can only have one instence of this game running!");
exit();
}
else
{
string[] charlist=find_directories("data/layouts/characters/*");
for(uint i=0; i<charlist.length(); i++)
{
charparse(charlist[i]);
}
string[] arclist=find_directories("data/layouts/equipments/weapons/archery/*");
for(uint i=0; i<arclist.length(); i++)
{
arcparse(arclist[i]);
}
string[] artlist=find_directories("data/layouts/equipments/weapons/artillery/*");
for(uint i=0; i<artlist.length(); i++)
{
artparse(artlist[i]);
}
string[] exolist=find_directories("data/layouts/equipments/weapons/explosive/*");
for(uint i=0; i<exolist.length(); i++)
{
exoparse(exolist[i]);
}
string[] melelist=find_directories("data/layouts/equipments/weapons/melee/*");
for(uint i=0; i<melelist.length(); i++)
{
meleparse(melelist[i]);
}
string[] shieldlist=find_directories("data/layouts/equipments/shields/*");
for(uint i=0; i<shieldlist.length(); i++)
{
shieldparse(shieldlist[i]);
}
@current_char=get_default_char();
shieldtype=current_char.shieldtype;
shieldweight=current_char.shieldweight;
attack=current_char.attack;
defence=current_char.defence;
points=current_char.points;
health=current_char.health;
maxhealth=current_char.maxhealth;
lifecard=current_char.lifecard;
level=current_char.level;
levmod=current_char.levmod;
xp=current_char.xp;
xpmod=current_char.xpmod;
xprequiered=current_char.xprequiered;
charcamsound=current_char.charcamsound;
charcamsound2=current_char.charcamsound2;
charcamsound3=current_char.charcamsound3;
chardeathsound=current_char.chardeathsound;
charfallsound=current_char.charfallsound;
charfallsound2=current_char.charfallsound2;
charhurtsound=current_char.charhurtsound;
charhealsound=current_char.charhealsound;
charhealsound2=current_char.charhealsound2;
charhealsound3=current_char.charhealsound3;
charinvsound=current_char.charinvsound;
charjumpsound=current_char.charjumpsound;
charjumpsound2=current_char.charjumpsound2;
charkillsound=current_char.charkillsound;
charlandsound=current_char.charlandsound;
charlevsound=current_char.charlevsound;
charlifesound=current_char.charlifesound;
charshakesound=current_char.charshakesound;
charsitsound=current_char.charsitsound;
charstandsound=current_char.charstandsound;
charswingsound=current_char.charswingsound;
charturnsound=current_char.charturnsound;
@current_shield=get_default_shield();
shielddefence=current_shield.shielddefence;
shieldweight=current_shield.shieldweight;
shieldstrength=current_shield.shieldstrength;
maxshieldstrength=current_shield.maxshieldstrength;
shieldlevel=current_shield.shieldlevel;
shieldbreaksound=current_shield.shieldbreaksound;
shielddrawsound=current_shield.shielddrawsound;
shieldhitsound=current_shield.shieldhitsound;
shieldloopsound=current_shield.shieldloopsound;
shieldremovesound=current_shield.shieldremovesound;
shieldwearsound=current_shield.shieldwearsound;
@current_weapon=get_default_weapon();
wepdamage=current_weapon.wepdamage;
wephold=current_weapon.wephold;
weprange=current_weapon.weprange;
weprange2=current_weapon.weprange2;
wepspeed=current_weapon.wepspeed;
weapontime=current_weapon.weapontime;
weapontime2=current_weapon.weapontime2;
wepweight=current_weapon.wepweight;
ammo=current_weapon.ammo;
loadedammo=current_weapon.loadedammo;
maxammo=current_weapon.maxammo;
weplevel=current_weapon.weplevel;
wepdrawsound=current_weapon.wepdrawsound;
wepemptysound=current_weapon.wepemptysound;
wepfiresound=current_weapon.wepfiresound;
wephitsound=current_weapon.wephitsound;
weploopsound=current_weapon.weploopsound;
weprecsound=current_weapon.weprecsound;
wepreloadsound=current_weapon.wepreloadsound;
wepshellsound=current_weapon.wepshellsound;
readdata();
readpreffs();
if(directory_exists("data/sounds") and !directory_empty("data/sounds"))
{
mainmenu();
}
else
{
downloadsounds();
}
}
}
void destroygame()
{
destroy_all_animals();
destroy_all_enemies();
destroy_all_projectiles();
destroy_all_turrets();
destroy_all_robots();
destroy_all_zombies();
}
void dockread(const string&in filename)
{
if(!file_exists(filename))
{
alert("Error","Could not fined "+string_replace(filename, "docks/", "", true));
docksmenu();
}
dockfile.open(filename,"rb");
string docktext=dockfile.read();
dockfile.close();
form.reset();
form.create_window("Viewing "+string_replace(filename, "docks/", "", true),false,false,false);
int dockbox=form.create_input_box(string_replace(filename, "docks/", "", true), docktext, read_only:true, multiline:true);
int dockclose=form.create_button("&close",false,true);
form.focus(dockbox);
while(true)
{
wait(5);
form.monitor();
if (form.is_pressed(dockclose))
{
docksmenu();
}
}
}
void downloadsounds()
{
quest=question("Error", "There are no sounds detected in the game! Would you like to download them now?");
if (quest==1)
{
if (file_exists("data/sounds.zip"))
{
alert("file found", "This file already exists. The downloader will now skip to the extraction process.");
}
else
{
string result=dl_file("https://github.com/tsatria03/SimpleFighter/releases/download/v5.0.0/sounds.zip", "data/sounds.zip");
if (result != "finished")
{
alert("download error", "Download failed or was canceled.");
if(file_exists("data/sounds.zip")) file_delete("data/sounds.zip");
mainmenu();
}
alert("finished", "Download completed successfully.");
}
alert("extracting", "Extracting files.");
progslot=temp.play_stationary_extended("pi2.ogg", true, 0, 0, 0, 100);
if(!directory_exists("data/sounds")) directory_create("data/sounds");
bool result=run("lib/unzip.exe", "-q -o data/sounds.zip -d data/sounds", true, true);
if (result==true)
{
temp.destroy_sound(progslot);
alert("extraction_complete", "Extraction finished successfully.");
if(file_exists("data/sounds.zip")) file_delete("data/sounds.zip");
restart();
}
else
{
alert("extraction_error", "Error occurred during extraction.");
mainmenu();
}
}
else
{
mainmenu();
}
}
void fade_multi_pool(int fade_mode)
{
sound_pool@[] pools = {p, animalpool, bombpool, bosspool, breakerpool, bulletpool, enemiepool, healpool, liftpool, passagepool, platpool, projpool, robpool, rockpool, telpool, turpool, zombpool, campool, calpool, clockpool, checkpool, forcepool, hazardpool, beltpool, doorpool, minepool, muspool, signpool, sourcepool, spikepool, vanpool, vehpool};    
if(fade_mode==0)
{
fade_pitch_pool(pools);
}
if(fade_mode==1)
{
fade_volume_pool(pools);
}
}
void fade_pitch_pool(sound_pool@[] handles, double time=20, double minpitch=20, double amount=2)
{
bool all_faded = false;    
while(!all_faded)
{
all_faded = true;
for(uint h=0; h<handles.length(); h++)
{
for(uint i=0; i<handles[h].items.length(); i++)
{
if(@handles[h].items[i].handle!=null && handles[h].items[i].handle.playing)
{
double current_pitch = handles[h].items[i].handle.pitch;
if(current_pitch > minpitch)
{
double new_pitch = current_pitch - amount;
if(new_pitch < minpitch)
new_pitch = minpitch;
handles[h].items[i].handle.pitch = new_pitch;
all_faded = false;
}
}
}
}
wait(time);
}    
for(uint h=0; h<handles.length(); h++)
{
handles[h].destroy_all();
}
}
void fade_volume_pool(sound_pool@[] handles, double time=0.25, double minvol=-50)
{
for(double current=0; current>minvol; current-=time)
{
for(uint h=0; h<handles.length(); h++)
{
for(uint x=0; x<handles[h].items.length(); x++)
{
if(@handles[h].items[x].handle==null)
continue;
if(handles[h].items[x].handle.playing==false)
continue;
handles[h].items[x].handle.volume = handles[h].items[x].handle.volume-time;
}
}
wait(5);
}
for(uint h=0; h<handles.length(); h++)
{
handles[h].destroy_all();
}
}

void game(bool is_building)
{
building=is_building;
gametimer.force(gametime);
if(building==false and musmode==1) spawn_musicsource(0, maxx*10, 0, maxy*10, mustyp, volume, pitch);
//spawn_boss(10, 0, 0, 0, 0, 0, 5000, 5000, 5, 500, 500, 5000, 500, 10000, 20000, 5, 500, "adel", "projectile", "fireball", true, true, false, true, false, true, true);
//spawn_boss(20, 0, 0, 0, 0, 0, 10000, 10000, 5, 500, 500, 5000, 250, 10000, 20000, 5, 500, "adel2", "projectile", "electrisity", true, true, false, true, false, true, true);
while(true)
{
wait(5);
update_ambsources(me.x,me.y);
update_musicambs(me.x,me.y);
update_sound_pools();
checkdeath();
checkloc();
checkpassages();
checkpspassages();
checkwepslots();
calandercheck();
clockcheck();
doorcheck();
fallcheck();
hazardcheck();
mhazardcheck();
mplatcheck();
psdoorcheck();
signcheck();
spawncheck();
stairscheck();
textcheck();
travelcheck();
wallcheck();
animalloop();
animalzoneloop();
beltloop();
bossloop();
bfloop();
bulletloop();
bombloop();
bombzoneloop();
cploop();
dlgloop();
doorloop();
eneloop();
enemiezoneloop();
forceloop();
healzoneloop();
liftloop();
mineloop();
objloop();
objzoneloop();
psdoorloop();
projloop();
projzoneloop();
revfxloop();
robloop();
robotzoneloop();
spikeloop();
telloop();
timebombloop();
timedmrcloop();
timedsrcloop();
timedtxtloop();
turretloop();
vplatloop();
vehloop();
zombloop();
zombiezoneloop();
if(amsptimer.elapsed>=amsptime and animals.length()<aninum and gamemode==1 and building==false and spawnable==true)
{
string[] animaltype=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
spawn_animal(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, animaltype[random(0,animaltype.length()-1)], true, true, random_bool(), random_bool());
amsptimer.restart();
}
if(emsptimer.elapsed>=emsptime and enemies.length()<eninum and gamemode==2 and building==false and spawnable==true)
{
string[] enemietype=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
spawn_enemie(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, enemietype[random(0,enemietype.length()-1)], true, true, random_bool(), random_bool());
emsptimer.restart();
}
if(prosptimer.elapsed>=prosptime and projectiles.length()<projnum and gamemode==3 and building==false and spawnable==true)
{
string[] projtype=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
spawn_projectile(random(0, maxx), 0, random(0, 1), 1*xp+1, 1*xp+1, 1, 1*xp+1, random(50, 500), 1, 1*level, projtype[random(0,projtype.length()-1)], true, true);
prosptimer.restart();
}
if(robsptimer.elapsed>=robsptime and robots.length()<robnum and gamemode==4 and building==false and spawnable==true)
{
string[] robottype=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
spawn_robot(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, robottype[random(0,robottype.length()-1)], true, true, random_bool(), random_bool());
robsptimer.restart();
}
if(zombsptimer.elapsed>=zombsptime and zombies.length()<zombnum and gamemode==5 and building==false and spawnable==true)
{
string[] zombietype=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
spawn_zombie(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, zombietype[random(0,zombietype.length()-1)], true, true, random_bool(), random_bool());
zombsptimer.restart();
}
if(amsptimer.elapsed>=amsptime and animals.length()<aninum and gamemode==6 and building==false and spawnable==true and  amtype!="")
{
string[] animaltype=find_directories("data/sounds/"+soundpack+"/npc/normal/animals/*");
if(amtype!="" and animaltype.find(amtype)>-1)
{
spawn_animal(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, amtype, true, true, random_bool(), random_bool());
amsptimer.restart();
}
}
if(emsptimer.elapsed>=emsptime and enemies.length()<eninum and gamemode==7 and building==false and spawnable==true and  emtype!="")
{
string[] enemietype=find_directories("data/sounds/"+soundpack+"/npc/normal/enemies/*");
if(emtype!="" and enemietype.find(emtype)>-1)
{
spawn_enemie(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, emtype, true, true, random_bool(), random_bool());
emsptimer.restart();
}
}
if(prosptimer.elapsed>=prosptime and projectiles.length()<projnum and gamemode==8 and building==false and spawnable==true and  potype!="")
{
string[] projtype=find_directories("data/sounds/"+soundpack+"/npc/normal/projectiles/*");
if(potype!="" and projtype.find(potype)>-1)
{
spawn_projectile(random(0, maxx), 0, random(0, 1), 1*xp+1, 1*xp+1, 1, 1*xp+1, random(50, 500), 1, 1*level, potype, true, true);
prosptimer.restart();
}
}
if(robsptimer.elapsed>=robsptime and robots.length()<robnum and gamemode==9 and building==false and spawnable==true and  rotype!="")
{
string[] robottype=find_directories("data/sounds/"+soundpack+"/npc/normal/robots/*");
if(rotype!="" and robottype.find(rotype)>-1)
{
spawn_robot(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, rotype, true, true, random_bool(), random_bool());
robsptimer.restart();
}
}
if(zombsptimer.elapsed>=zombsptime and zombies.length()<zombnum and gamemode==10 and building==false and spawnable==true and  zotype!="")
{
string[] zombietype=find_directories("data/sounds/"+soundpack+"/npc/normal/zombies/*");
if(zotype!="" and zombietype.find(zotype)>-1)
{
spawn_zombie(random(0, maxx), 0, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, zotype, true, true, random_bool(), random_bool());
zombsptimer.restart();
}
}
if(heartsound==1 and hearttimer.elapsed>=hearttime)
{
if(hearttype==1)
{
if(heartsound==1) heartslot=p.play_stationary("heartbeat1.wav", false);
hearttimer.restart();
}
}
if(heartsound==1 and hearttimer.elapsed>=hearttime)
{
if(hearttype==2)
{
if(heartsound==1) heartslot=p.play_stationary("heartbeat2.wav",false);
hearttimer.restart();
}
}
if(heartsound==1 and hearttimer.elapsed>=hearttime)
{
if(hearttype==3)
{
if(heartsound==1) heartslot=p.play_stationary("heartbeat3.wav",false);
hearttimer.restart();
}
}
if(heartsound==1 and hearttimer.elapsed>=hearttime)
{
if(hearttype==4)
{
if(heartsound==1) heartslot=p.play_stationary("hartmon4.ogg",false);
hearttimer.restart();
}
}
if(heartsound==1 and hearttimer.elapsed>=hearttime)
{
if(hearttype==5)
{
if(heartsound==1) heartslot=p.play_stationary("hartmon5.ogg",false);
hearttimer.restart();
}
}
if (jumping==1)
{
movetime=airtime;
}
else if(alt_is_down())
{
movetime=runtime;
}
else
{
movetime=walktime;
}
if(modspeed>=1)
{
airtime=250/modspeed+shieldweight+wepweight;
camtime=250/modspeed+shieldweight+wepweight;
falltime=250/modspeed-shieldweight-wepweight;
runtime=500/modspeed+shieldweight+wepweight;
walktime=1000/modspeed+shieldweight+wepweight;
}
if(xp>=xprequiered)
{
xprequiered=(levmod*(level*(level*4)));
string[] levsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*lev*");
if(levsfx.length()!=0 and charlevsound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+levsfx[random(0,levsfx.length()-1)],false);
if(gamemode==1 and building==false) aninum+=1;
if(gamemode==2 and building==false) eninum+=1;
if(gamemode==3 and building==false) projnum+=1;
if(gamemode==4 and building==false) robnum+=1;
if(gamemode==5 and building==false) zombnum+=1;
if(gamemode==6 and building==false) aninum+=1;
if(gamemode==7 and building==false) eninum+=1;
if(gamemode==8 and building==false) projnum+=1;
if(gamemode==9 and building==false) robnum+=1;
if(gamemode==10 and building==false) zombnum+=1;
level+=1;
points+=100*level*levmod-100;
}
if(health<=health and hprestoretimer.elapsed>=hprestoretime and healable==true)
{
if(hprestoration==1)
{
health+=maxhealth/4;
hearttime+=maxhealth/4;
string[] healstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1 and health>=maxhealth) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
hprestoretimer.restart();
}
}
if(shieldstrength<=shieldstrength and sprestoretimer.elapsed>=sprestoretime and healable==true)
{
if(sprestoration==1)
{
shieldstrength+=maxshieldstrength/4;
string[] healstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1 and shieldstrength>=maxshieldstrength) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
sprestoretimer.restart();
}
}
if(shieldstrength<=0)
{
p.destroy_sound(shieldloop);
p.destroy_sound(shieldslot);
string[] breaksfx=find_files("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*break*");
if(breaksfx.length()!=0 and shieldbreaksound==1) shieldslot=p.play_stationary_extended("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+breaksfx[random(0,breaksfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
shieldstrength=maxshieldstrength;
shieldon=0;
shieldweight=1;
shieldtype="none";
}
if(health<=0)
{
if(lifecard>=2)
{
string[] lifesfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*life*");
if(lifesfx.length()!=0 and charlifesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+lifesfx[random(0,lifesfx.length()-1)],false);
lifecard-=1;
health=maxhealth;
hearttime=maxhealth;
}
}
if(animals.length()>=50 or enemies.length()>=50 or projectiles.length()>=50 or robots.length()>=50 or zombies.length()>=50)
{
aninum=50;
eninum=50;
projnum=50;
robnum=50;
zombnum=50;
}
if(me.x<=0)
{
me.x=0;
}
if(me.x>=maxx)
{
me.x=maxx;
}
if(me.y<=0)
{
me.y=0;
}
if(me.y>=maxy)
{
me.y=maxy;
}
if(health<=0)
{
health=0;
hearttime=0;
}
if(health>=maxhealth)
{
health=maxhealth;
hearttime=maxhealth;
}
if(hearttime<=100)
{
hearttime=100;
}
if(shieldstrength<=0)
{
shieldstrength=0;
}
if(shieldstrength>=maxshieldstrength)
{
shieldstrength=maxshieldstrength;
}
if(attack<=0)
{
attack=0;
}
if(defence<=0)
{
defence=0;
}
if(lifecard<=1)
{
lifecard=1;
}
if(points<=0)
{
points=0;
}
if(shielddefence<=0)
{
shielddefence=0;
}
if(weprange<=0)
{
weprange=0;
}
if(weprange2<=0)
{
weprange2=0;
}
if(health>=maxhealth and hprestoration==1)
{
hprestoration=0;
p.destroy_sound(autoslot);
health=maxhealth;
hearttime=maxhealth;
}
if(shieldstrength>=maxshieldstrength and sprestoration==1)
{
sprestoration=0;
p.destroy_sound(autoslot);
shieldstrength=maxshieldstrength;
}
if(alt_is_down())
{
if(key_pressed(KEY_SLASH) and building==true)
{
input.set_only_allowed_chars("1234567890- ");
string gd=input.input("Enter the coordinates you'd like to go to.");
if(gd=="")
return;
string[] sd=string_split(gd, " ", true);
if(sd.length()==2)
{
int x=stn(sd[0]);
int y=stn(sd[1]);
gop(x, y);
resume_pools();
}
else
{
resume_pools();
speak("Invalid input. Please enter two numbers separated by a space.");
}
}
}
if(key_pressed(KEY_I))
{
pause_pools();
itemsmenu();
}
if(key_pressed(KEY_W))
{
pause_pools();
weaponsmenu();
}
if(key_pressed(KEY_S))
{
string[] armor=find_directories("data/layouts/equipments/shields/*");
if(armor.length()==0)
{
speak("there are no shields available to view.");
}
else if(shieldon==1)
{
speak("You can't switch to a different shield while the current one is in use.");
}
else
{
destroy_all_shields();
string[] shieldlist=find_directories("data/layouts/equipments/shields/*");
for(uint i=0; i<shieldlist.length(); i++)
{
shieldparse(shieldlist[i]);
}
pause_pools();
string res=shieldsmenu();
if(res!="")
{
shieldtype=res;
}
}
}
if(key_pressed(KEY_O) and building==true)
{
pause_pools();
buildmenu();
}
if(key_repeating(KEY_TAB) and key_up(KEY_LMENU) and key_up(KEY_RMENU))
{
if (shift_is_down())
cycle_inv(0);
else
cycle_inv(1);
}
if(key_repeating(KEY_RETURN) and shift_is_down() and usetimer.elapsed>=usetime)
{
usetimer.restart();
if (inv.get_keys().length()>0 and invpos<inv.get_size())
useitem(inv.get_keys()[invpos]);
else
speak("No item in focus.");
}
if(key_repeating(KEY_LBRACKET) and shift_is_down() and usetimer.elapsed>=usetime)
{
if(inv.get_keys().length()>0 and invpos<inv.get_size())
{
string[] dropsfx=find_files("data/sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/*drop*");
if(dropsfx.length()!=0 and facing=="left") itemslot=p.play_extended_2d("data/sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/"+dropsfx[random(0,dropsfx.length()-1)],me.x-1,me.y,me.x-1,me.y,0,0,0,0,false,0,0,itemvolume,itempitch,false);
if(dropsfx.length()!=0 and facing=="right") itemslot=p.play_extended_2d("data/sounds/"+soundpack+"/equipments/items/unsorted/"+itemtype+"/"+itemtype2+"/"+dropsfx[random(0,dropsfx.length()-1)],me.x+1,me.y,me.x+1,me.y,0,0,0,0,false,0,0,itemvolume,itempitch,false);
drop_item(facing, itemtype, itemtype2);
give(itemtype2,-1);
usetimer.restart();
}
else
{
speak("No item in focus.");
}
}
if(shift_is_down())
{
if(key_pressed(KEY_LEFT) and spiable==true)
{
spy("left", spydist);
}
if(key_pressed(KEY_RIGHT) and spiable==true)
{
spy("right", spydist);
}
if(key_pressed(KEY_DOWN) and spiable==true)
{
spy("down", spydist);
}
if(key_pressed(KEY_UP) and spiable==true)
{
spy("up", spydist);
}
}
if(key_down(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(key_pressed(KEY_R))
{
bool hazard_found=false;
string tiletype;
if(cam.y>=1 and gct(cam.x,cam.y)=="")
{
tiletype="air";
}
else
{
tiletype=gct(cam.x,cam.y);
}
for(uint i=0; i<hazards.length(); i++)
{
if(cam.x>=hazards[i].minx && cam.x<=hazards[i].maxx && cam.y>=hazards[i].miny && cam.y<=hazards[i].maxy)
{
hazard_found=true;
speak(tiletype+" with "+hazards[i].hazardtype+" hazard, "+cam.x+","+cam.y);
break;
}
}
if(!hazard_found)
{
if(me.x==cam.x and me.y==cam.y)
{
speak(tiletype+" with player, "+cam.x+", "+cam.y);
}
else
{
speak(tiletype+", "+cam.x+", "+cam.y);
}
}
}
if(key_repeating(KEY_M))
{
if(mfc==false)
{
mfc=true;
if(switchsound==1) p.play_stationary("toggleon.ogg",false);
speak("Mfwc enabled.");
}
else if(mfc==true)
{
mfc=false;
if(switchsound==1) p.play_stationary("toggleoff.ogg",false);
speak("Mfwc disabled.");
}
}
if(key_repeating(KEY_T))
{
playcam();
}
if(cleft.pressing() and cam.x!=0)
{
cam_left();
}
if(cright.pressing() and cam.x!=maxx)
{
cam_right();
}
if(key_pressed(KEY_LEFT) and cam.x!=0)
{
camstep_left();
}
if(key_pressed(KEY_RIGHT) and cam.x!=maxx)
{
camstep_right();
}
if(cdown.pressing() and cam.y!=0)
{
cam_down();
}
if(cup.pressing() and cam.y!=maxx)
{
cam_up();
}
if(key_pressed(KEY_DOWN) and cam.y!=0)
{
camstep_down();
}
if(key_pressed(KEY_UP) and cam.y!=maxy)
{
camstep_up();
}
}
if(key_up(KEY_G))
{
cam.x=me.x;
cam.y=me.y;
mfc=false;
}
if(key_pressed(KEY_SEMICOLON))
{
speak("Your maximum jump height is"+jumpheight+"squares");
}
if(key_pressed(KEY_APOSTROPHE))
{
speak("You are at speed"+modspeed);
}
if(key_down(KEY_LEFT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_left();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_RIGHT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_right();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_UP) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_up();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_down(KEY_DOWN) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and movetimer.elapsed>=movetime)
{
if(keyrowhold==1 and moveable==true and doormove==false)
{
move_down();
movetimer.restart();
}
else if(keyrowhold==1 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
movetimer.restart();
}
}
if(key_pressed(KEY_LEFT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_left();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_RIGHT) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_right();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_UP) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_up();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_pressed(KEY_DOWN) and key_up(KEY_G) and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT))
{
if(keyrowhold==0 and moveable==true and doormove==false)
{
step_down();
}
else if(keyrowhold==0 and moveable==false and sitting==true)
{
string[] rocksfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rock*");
if(rocksfx.length()!=0 and charshakesound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+rocksfx[random(0,rocksfx.length()-1)],false);
}
}
if(key_repeating(KEY_D) and modspeed!=20)
{
if(keyrowhold==0)
{
speak("You must enable auto walking in order to increase the moving speed.");
}
else if(speedable==true)
{
p.play_stationary("speed.ogg",false);
modspeed+=1;
speak("speed"+modspeed);
}
}
if(key_repeating(KEY_A) and modspeed!=1)
{
if(keyrowhold==0)
{
speak("You must enable auto walking in order to decrease the moving speed.");
}
else if(speedable==true)
{
p.play_stationary("speed.ogg",false);
modspeed-=1;
speak("speed"+modspeed);
}
}
if(key_pressed(KEY_F))
{
if(modspeed==5)
{
speak("moving speed is already reset");
}
else if(modspeed<=20)
{
modspeed=5;
speak("moving speed reset");
}
}
if(key_repeating(KEY_X))
{
if(spokenswitch==1)
{
if(keyrowhold==1 and speedable==true)
{
if(switchsound==1) p.play_stationary("switchoff.ogg",false);
speak("auto walking disabled");
keyrowhold=0;
speedable=false;
}
else if(keyrowhold==0 and speedable==false)
{
if(switchsound==1) p.play_stationary("switchon.ogg",false);
speak("auto walking enabled");
keyrowhold=1;
speedable=true;
}
else if(spokenswitch==0)
{
if(keyrowhold==1 and speedable==true)
{
if(switchsound==1) p.play_stationary("switchoff.ogg",false);
keyrowhold=0;
speedable=false;
}
else if(keyrowhold==0 and speedable==false)
{
if(switchsound==1) p.play_stationary("switchon.ogg",false);
keyrowhold=1;
speedable=true;
}
}
}
}
if(key_repeating(KEY_T))
{
if(sittable==true and sitting==false)
{
sit_down();
}
else if(sittable==true and sitting==true)
{
stand_up();
}
}
if(key_pressed(KEY_C))
{
speakcoordinates();
}
if(key_pressed(KEY_Q) and building==true)
{
if(get_zone_at(me.x, me.y)!="")
{
string locate=get_zone_at(me.x,me.y);
speak("Current location"+","+locate);
}
else
{
speak("Current location, unknown area.");
}
}
if(key_repeating(KEY_J) and telable==true)
{
if(spokentel==1)
{
me.x=random(0,maxx);
if(telsound==1) p.play_stationary("tel1.ogg",false);
speak("moved to"+me.x+",;"+me.y);
}
else if(spokentel==0)
{
me.x=random(0,maxx);
if(telsound==1) p.play_stationary("tel1.ogg",false);
}
}
if(key_repeating(KEY_K) and telable==true)
{
if(spokentel==1)
{
me.y=random(1,maxy);
if(telsound==1) p.play_stationary("tel2.ogg",false);
speak("moved to"+me.x+",;"+me.y);
}
else if(spokentel==0)
{
me.y=random(1,maxy);
if(telsound==1) p.play_stationary("tel2.ogg",false);
}
}
if(key_repeating(KEY_L) and telable==true)
{
if(spokentel==1)
{
me.x=random(0,maxx);
me.y=random(1,maxy);
if(telsound==1) p.play_stationary("tel3.ogg",false);
speak("moved to"+me.x+",;"+me.y);
}
else if(spokentel==0)
{
me.x=random(0,maxx);
me.y=random(1,maxy);
if(telsound==1) p.play_stationary("tel3.ogg",false);
}
}
if(key_pressed(KEY_F1) and jumpheight!=1)
{
jumpheight-=1;
speak("jump height decreased to"+jumpheight+"squares");
}
if(key_pressed(KEY_F2) and jumpheight!=20)
{
jumpheight+=1;
speak("jump height increased to"+jumpheight+"squares");
}
if(key_pressed(KEY_F3))
{
if(jumpheight==5)
{
speak("jump hight is already reset");
}
else if(jumpheight<=20)
{
jumpheight=5;
speak("jump hight reset");
}
}
if (key_pressed(KEY_F4) and maxx!=10 and building==false)
{
maxx-=10;
speak("max x position decreased to"+maxx+"tiles");
}
if(key_pressed(KEY_F5) and maxx!=1000 and building==false)
{
maxx+=10;
speak("max x position increased to"+maxx+"tiles");
}
if(key_pressed(KEY_F6) and maxy!=10 and building==false)
{
maxy-=10;
speak("max y position decreased to"+maxy+"tiles");
}
if(key_pressed(KEY_F7) and maxy!=1000 and building==false)
{
maxy+=10;
speak("max y position increased to"+maxy+"tiles");
}
if(key_pressed(KEY_COMMA))
{
speak("Your maximum x position is"+maxx+"tiles");
}
if(key_pressed(KEY_PERIOD))
{
speak("Your maximum y position is"+maxy+"tiles");
}
if(key_down(KEY_SPACE) and key_up(KEY_G)  and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and autojump==1 and jumping==0 and jumpable==true and falling==false and doormove==false and psdoormove==false)
{
string[] jumpstartsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rise*");
if(jumpstartsfx.length()!=0 and charjumpsound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+jumpstartsfx[random(0,jumpstartsfx.length()-1)],false);
string[] jumpstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*jump*");
if(jumpstopsfx.length()!=0 and charjumpsound2==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+jumpstopsfx[random(0,jumpstopsfx.length()-1)],false);
ty1=me.y;
ty2=me.y+jumpheight;
jumping=1;
ascending=true;
}
if (jumping==1)
{
if (atapex==true and jumptimer.elapsed>=apextime)
{
jumptimer.restart();
atapex=false;
}
if (ascending==false and jumptimer.elapsed>=jumptime2 and atapex==false)
{
jumptimer.restart();
me.y-=1;
checkforplatforms();
if (me.y<=ty1)
{
me.y=ty1;
jumping=0;
}
}
if (ascending==true and jumptimer.elapsed>=jumptime)
{
jumptimer.restart();
me.y+=1;
checkforwalls();
if (me.y>=ty2)
{
ascending=false;
jumptimer.restart();
atapex=true;
}
}
}
if(key_pressed(KEY_SPACE) and key_up(KEY_G)  and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and autojump==0 and jumping==0 and jumpable==true and falling==false and doormove==false and psdoormove==false)
{
string[] jumpstartsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*rise*");
if(jumpstartsfx.length()!=0 and charjumpsound==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+jumpstartsfx[random(0,jumpstartsfx.length()-1)],false);
string[] jumpstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*jump*");
if(jumpstopsfx.length()!=0 and charjumpsound2==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+jumpstopsfx[random(0,jumpstopsfx.length()-1)],false);
ty1=me.y;
ty2=me.y+jumpheight;
jumping=1;
ascending=true;
}
if (jumping==1)
{
if (atapex==true and jumptimer.elapsed>=apextime)
{
jumptimer.restart();
atapex=false;
}
if (ascending==false and jumptimer.elapsed>=jumptime2 and atapex==false)
{
jumptimer.restart();
me.y-=1;
checkforplatforms();
if (me.y<=ty1)
{
me.y=ty1;
jumping=0;
}
}
if (ascending==true and jumptimer.elapsed>=jumptime)
{
jumptimer.restart();
me.y+=1;
checkforwalls();
if (me.y>=ty2)
{
ascending=false;
jumptimer.restart();
atapex=true;
}
}
}
if(key_pressed(KEY_Z))
{
if(melee==false and weapontype=="archery")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==false and weapontype=="artillery")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==false and weapontype=="explosive")
{
speak(loadedammo+" out of "+maxammo+" ammo loaded, and "+ammo+" ammo in reserve");
}
if(melee==true and weapontype=="melee")
{
speak("This weapon does not take any ammo.");
}
}
if(key_pressed(KEY_R) and melee==false and loadedammo<=0)
{
reload_weapon();
}
if(key_pressed(KEY_U))
{
speak("You're currently playing "+mapname+" map.");
}
if(key_pressed(KEY_Y))
{
speak("You've been playing for a total of;"+timeelapsed.m()+"minutes,"+timeelapsed.s()+"seconds");
}
if(key_pressed(KEY_H))
{
if(shieldon==1)
{
speak("Your shield must be removed to view the player's health status.");
}
else if(shieldon==0)
{
if(healthspeech==1 and lifecard>=2)
{
speak(health+"health,"+lifecard+"lives");
}
if(healthspeech==2 and lifecard>=2)
{
speak(health+"of"+maxhealth+"health,"+lifecard+"lives");
}
if(healthspeech==3 and lifecard>=2)
{
speak(round(health/maxhealth*100,2)+"percent health remaining,"+lifecard+"lives");
}
if(healthspeech==4 and lifecard>=2)
{
speak(round(health/maxhealth*100,2)+"percent,"+health+"of"+maxhealth+"health,"+lifecard+"lives");
}
if(healthspeech==1 and lifecard<=1)
{
speak(health+"health,"+lifecard+"life");
}
if(healthspeech==2 and lifecard<=1)
{
speak(health+"of"+maxhealth+"health,"+lifecard+"life");
}
if(healthspeech==3 and lifecard<=1)
{
speak(round(health/maxhealth*100,2)+"percent health remaining,"+lifecard+"life");
}
if(healthspeech==4 and lifecard<=1)
{
speak(round(health/maxhealth*100,2)+"percent,"+health+"of"+maxhealth+"health,"+lifecard+"life");
}
}
}
if(key_pressed(KEY_M))
{
if(shieldon==0)
{
speak("Your shield must be worn to view it's status.");
}
else if(shieldon==1)
{
speak("shield strength,"+round(shieldstrength/maxshieldstrength*100,2)+"percent");
}
}
if(control_is_down())
{
if(useitems==false)
{
drawable=true;
auto_fire_weapon();
}
else if(useitems==true)
{
drawable=false;
auto_use_item();
}
}
if(key_pressed(KEY_LCONTROL) or key_pressed(KEY_RCONTROL))
{
if(useitems==false)
{
drawable=true;
manule_fire_weapon();
}
else if(useitems==true)
{
drawable=false;
manule_use_item();
}
}
if(key_pressed(KEY_E))
{
if(objinf==0)
{
if(gamemode==1 and building==false) speak("there are;"+animals.length()+"animals spawned on the map.");
if(gamemode==2 and building==false) speak("there are;"+enemies.length()+"enemies spawned on the map.");
if(gamemode==3 and building==false) speak("there are;"+projectiles.length()+"projectiles spawned on the map.");
if(gamemode==4 and building==false) speak("there are;"+robots.length()+"robots spawned on the map.");
if(gamemode==5 and building==false) speak("there are;"+zombies.length()+"zombies spawned on the map.");
if(gamemode==6 and building==false) speak("there are;"+animals.length()+amtype+";"+"spawned on the map.");
if(gamemode==7 and building==false) speak("there are;"+enemies.length()+emtype+";"+"spawned on the map.");
if(gamemode==8 and building==false) speak("there are;"+projectiles.length()+potype+";"+"spawned on the map.");
if(gamemode==9 and building==false) speak("there are;"+robots.length()+rotype+";"+"spawned on the map.");
if(gamemode==10 and building==false) speak("there are;"+zombies.length()+zotype+";"+"spawned on the map.");
}
else if(objinf==1)
{
if(animals.length()==0 and bosses.length()==0 and bullets.length()==0 and doors.length()==0 and psdoors.length()==0 and enemies.length()==0 and projectiles.length()==0 and robots.length()==0 and spikes.length()==0  and turrets.length()==0 and vehicles.length()==0 and walls.length()==0 and zombies.length()==0)
{
speak("there are no objects on the field to view.");
}
else
{
pause_pools();
infomenu();
}
}
}
if(key_pressed(KEY_N))
{
speak("You have killed a total of"+kills+"entidies.");
}
if(key_repeating(KEY_P))
{
if(pausem==0)
{
if(paused==0)
{
p.play_stationary("pause.ogg",false);
pause_game();
}
else if(paused==1)
{
p.play_stationary("resume.ogg",false);
resume_game();
}
}
else if(pausem==1)
{
pausemenu();
}
}
if(key_pressed(KEY_V))
{
pause_pools();
pointsmenu();
}
if(key_repeating(KEY_BACKSLASH) and healable==true)
{
if(shieldon==1)
{
speak("Your shield must be removed to restore the player's health.");
}
else if(shieldon==0 and hprestoration==0 and health>=maxhealth)
{
speak("You're already at maximum health.");
}
else if(health<=maxhealth and hprestoration==1)
{
p.destroy_sound(autoslot);
string[] healstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
hprestoration=0;
}
else
{
string[] healstartsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstart*");
if(healstartsfx.length()!=0 and charhealsound2==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstartsfx[random(0,healstartsfx.length()-1)],false);
string[] healingsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healing*");
if(healingsfx.length()!=0 and charhealsound==1) autoslot=p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healingsfx[random(0,healingsfx.length()-1)],true);
hprestoration=1;
}
}
if(key_repeating(KEY_RBRACKET) and healable==true)
{
if(shieldon==0)
{
speak("Your shield must be worn to restore it's strength.");
}
else if(shieldon==1 and shieldstrength>=maxshieldstrength)
{
speak("Your shield is already at maximum strength.");
}
else if(shieldon==1 and shieldstrength<=maxshieldstrength)
{
if(sprestoration==1)
{
p.destroy_sound(autoslot);
string[] healstopsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstop*");
if(healstopsfx.length()!=0 and charhealsound3==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstopsfx[random(0,healstopsfx.length()-1)],false);
sprestoration=0;
}
else
{
string[] healstartsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healstart*");
if(healstartsfx.length()!=0 and charhealsound2==1) p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healstartsfx[random(0,healstartsfx.length()-1)],false);
string[] healingsfx=find_files("data/sounds/"+soundpack+"/characters/"+chartype+"/*healing*");
if(healingsfx.length()!=0 and charhealsound==1) autoslot=p.play_stationary("data/sounds/"+soundpack+"/characters/"+chartype+"/"+healingsfx[random(0,healingsfx.length()-1)],true);
sprestoration=1;
}
}
}
if(key_repeating(KEY_B))
{
if(shieldtype=="none")
{
speak("You must draw a shield before wearing it.");
}
else if(shieldon==0)
{
p.destroy_sound(shieldwearslot);
string[] wearsfx=find_files("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*wear*");
if(wearsfx.length()!=0 and shieldwearsound==1) shieldwearslot=p.play_stationary_extended("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+wearsfx[random(0,wearsfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
string[] shieldsfx=find_files("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*loop*");
if(shieldsfx.length()!=0 and shieldloopsound==1) shieldloop=p.play_stationary_extended("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+shieldsfx[random(0,shieldsfx.length()-1)],true,0,0,shieldvolume,shieldpitch,false);
shieldon=1;
}
else
{
p.destroy_sound(shieldloop);
p.destroy_sound(shieldremoveslot);
string[] remsfx=find_files("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*remove*");
if(remsfx.length()!=0 and shieldremovesound==1) shieldremoveslot=p.play_stationary_extended("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/"+remsfx[random(0,remsfx.length()-1)],false,0,0,shieldvolume,shieldpitch,false);
shieldon=0;
}
}
if(key_pressed(KEY_ESCAPE) and quittable==true)
{
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
me.x=0;
me.y=0;
if(building==true) clearmap();
if(building==true) destroymap();
if(building==true) mapmenu();
if(building==false) destroygame();
if(building==false) gamemenu();
}
}
}

void getver()
{
ver.open("docks/version.txt","rb");
version=ver.read();
ver.close();
}
void initialize_sound_pools()
{
@p.mixer=mixer();
p.max_distance=0;
p.pan_step=2.5;
p.volume_step=2.5;
@animalpool.mixer=mixer();
animalpool.max_distance=0;
animalpool.pan_step=2.5;
animalpool.volume_step=2.5;
@bombpool.mixer=mixer();
bombpool.max_distance=0;
bombpool.pan_step=2.5;
bombpool.volume_step=2.5;
@bosspool.mixer=mixer();
bosspool.max_distance=0;
bosspool.pan_step=2.5;
bosspool.volume_step=2.5;
@breakerpool.mixer=mixer();
breakerpool.max_distance=0;
breakerpool.pan_step=2.5;
breakerpool.volume_step=2.5;
@bulletpool.mixer=mixer();
bulletpool.max_distance=0;
bulletpool.pan_step=2.5;
bulletpool.volume_step=2.5;
@enemiepool.mixer=mixer();
enemiepool.max_distance=0;
enemiepool.pan_step=2.5;
enemiepool.volume_step=2.5;
@healpool.mixer=mixer();
healpool.max_distance=0;
healpool.pan_step=2.5;
healpool.volume_step=2.5;
@liftpool.mixer=mixer();
liftpool.max_distance=0;
liftpool.pan_step=2.5;
liftpool.volume_step=2.5;
@passagepool.mixer=mixer();
passagepool.max_distance=0;
passagepool.pan_step=2.5;
passagepool.volume_step=2.5;
@platpool.mixer=mixer();
platpool.max_distance=0;
platpool.pan_step=2.5;
platpool.volume_step=2.5;
@projpool.mixer=mixer();
projpool.max_distance=0;
projpool.pan_step=2.5;
projpool.volume_step=2.5;
@robpool.mixer=mixer();
robpool.max_distance=0;
robpool.pan_step=2.5;
robpool.volume_step=2.5;
@rockpool.mixer=mixer();
rockpool.max_distance=0;
rockpool.pan_step=2.5;
rockpool.volume_step=2.5;
@telpool.mixer=mixer();
telpool.max_distance=0;
telpool.pan_step=2.5;
telpool.volume_step=2.5;
@turpool.mixer=mixer();
turpool.max_distance=0;
turpool.pan_step=2.5;
turpool.volume_step=2.5;
@zombpool.mixer=mixer();
zombpool.max_distance=0;
zombpool.pan_step=2.5;
zombpool.volume_step=2.5;
@campool.mixer=mixer();
campool.max_distance=0;
campool.pan_step=2.5;
campool.volume_step=2.5;
@calpool.mixer=mixer();
calpool.max_distance=0;
calpool.pan_step=2.5;
calpool.volume_step=2.5;
@clockpool.mixer=mixer();
clockpool.max_distance=0;
clockpool.pan_step=2.5;
clockpool.volume_step=2.5;
@checkpool.mixer=mixer();
checkpool.max_distance=0;
checkpool.pan_step=2.5;
checkpool.volume_step=2.5;
@forcepool.mixer=mixer();
forcepool.max_distance=0;
forcepool.pan_step=2.5;
forcepool.volume_step=2.5;
@hazardpool.mixer=mixer();
hazardpool.max_distance=0;
hazardpool.pan_step=2.5;
hazardpool.volume_step=2.5;
@itempool.mixer=mixer();
itempool.max_distance=0;
itempool.pan_step=2.5;
itempool.volume_step=2.5;
@beltpool.mixer=mixer();
beltpool.max_distance=0;
beltpool.pan_step=2.5;
beltpool.volume_step=2.5;
@doorpool.mixer=mixer();
doorpool.max_distance=0;
doorpool.pan_step=2.5;
doorpool.volume_step=2.5;
@minepool.mixer=mixer();
minepool.max_distance=0;
minepool.pan_step=2.5;
minepool.volume_step=2.5;
@muspool.mixer=mixer();
muspool.max_distance=0;
muspool.pan_step=2.5;
muspool.volume_step=2.5;
@signpool.mixer=mixer();
signpool.max_distance=0;
signpool.pan_step=2.5;
signpool.volume_step=2.5;
@sourcepool.mixer=mixer();
sourcepool.max_distance=0;
sourcepool.pan_step=2.5;
sourcepool.volume_step=2.5;
@spikepool.mixer=mixer();
spikepool.max_distance=0;
spikepool.pan_step=2.5;
spikepool.volume_step=2.5;
@vehpool.mixer=mixer();
vehpool.max_distance=0;
vehpool.pan_step=2.5;
vehpool.volume_step=2.5;
@vanpool.mixer=mixer();
vanpool.max_distance=0;
vanpool.pan_step=2.5;
vanpool.volume_step=2.5;
}
void update_sound_pools()
{
p.update_listener_2d(me.x,me.y);
animalpool.update_listener_2d(me.x,me.y);
bombpool.update_listener_2d(me.x,me.y);
bosspool.update_listener_2d(me.x,me.y);
breakerpool.update_listener_2d(me.x,me.y);
bulletpool.update_listener_2d(me.x,me.y);
enemiepool.update_listener_2d(me.x,me.y);
healpool.update_listener_2d(me.x,me.y);
liftpool.update_listener_2d(me.x,me.y);
passagepool.update_listener_2d(me.x,me.y);
platpool.update_listener_2d(me.x,me.y);
projpool.update_listener_2d(me.x,me.y);
robpool.update_listener_2d(me.x,me.y);
rockpool.update_listener_2d(me.x,me.y);
telpool.update_listener_2d(me.x,me.y);
turpool.update_listener_2d(me.x,me.y);
zombpool.update_listener_2d(me.x,me.y);
campool.update_listener_2d(me.x,me.y);
calpool.update_listener_2d(me.x,me.y);
clockpool.update_listener_2d(me.x,me.y);
checkpool.update_listener_2d(me.x,me.y);
forcepool.update_listener_2d(me.x,me.y);
hazardpool.update_listener_2d(me.x,me.y);
itempool.update_listener_2d(me.x,me.y);
beltpool.update_listener_2d(me.x,me.y);
doorpool.update_listener_2d(me.x,me.y);
minepool.update_listener_2d(me.x,me.y);
muspool.update_listener_2d(me.x,me.y);
signpool.update_listener_2d(me.x,me.y);
sourcepool.update_listener_2d(me.x,me.y);
spikepool.update_listener_2d(me.x,me.y);
vanpool.update_listener_2d(me.x,me.y);
vehpool.update_listener_2d(me.x,me.y);
}

void pause_pools()
{
sound_pool@[] pools = {animalpool, bombpool, bosspool, breakerpool, bulletpool, enemiepool, healpool, liftpool, passagepool, platpool, projpool, robpool, rockpool, telpool, turpool, zombpool, calpool, clockpool, checkpool, forcepool, hazardpool, beltpool, doorpool, minepool, muspool, signpool, sourcepool, spikepool, vanpool, vehpool};    
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            if(@pools[h].items[i].handle == null)
                continue;
            if(pools[h].items[i].handle.playing == false)
                continue;
            pools[h].pause_sound(i);
        }
    }
}
void resume_pools()
{
sound_pool@[] pools = {animalpool, bombpool, bosspool, breakerpool, bulletpool, enemiepool, healpool, liftpool, passagepool, platpool, projpool, robpool, rockpool, telpool, turpool, zombpool, calpool, clockpool, checkpool, forcepool, hazardpool, beltpool, doorpool, minepool, muspool, signpool, sourcepool, spikepool, vanpool, vehpool};   
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            pools[h].resume_sound(i);
        }
    }
}
void pause_game()
{
paused=1;
pause_pools();
cammable=false;
droppable=false;
fireable=false;
gametimer.pause();
healable=false;
jumpable=false;
moveable=false;
quittable=false;
speedable=false;
spawnable=false;
sittable=false;
telable=false;
turnable=false;
}
void resume_game()
{
paused=0;
resume_pools();
cammable=true;
droppable=true;
fireable=true;
gametimer.resume();
healable=true;
jumpable=true;
moveable=true;
quittable=true;
speedable=true;
spawnable=true;
sittable=true;
telable=true;
turnable=true;
}

void resetgame()
{
aninum=1;
eninum=1;
projnum=1;
robnum=1;
zombnum=1;
weapontype="melee";
me.x=0;
me.y=0;
maxx=100;
maxy=100;
kills=0;
facing="left";
tiletype="short grass";
walltype="wallgrass";
}
void resetpreffs()
{
chartype="default";
keyboardtheme="keyboard";
soundpack="default";
soundcard="Default";
sound_output_device=1;
menutype="default";
autosave=0;
hidedocks=false;
hidegames=false;
hidemaps=false;
hidesets=false;
hrtf=false;
mreset=0;
mskipnum=1;
up_down=1;
left_right=0;
home_end=0;
wrap=0;
repeat_items=0;
numbers=0;
first_letter=0;
position_info=0;
side_scroll=0;
}
void restart()
{
if(SCRIPT_COMPILED)
{
bool success=run("sf.exe","",false,false);
if(!success)
{
alert("errorr", "Unable to restart sf.exe!");
}
}
else
{
bool success=run("c:\\nvgt\\nvgtw.exe","sf.nvgt",false,false);
if(!success)
{
alert("errorr", "Unable to restart sf.nvgt!");
}
}
}
