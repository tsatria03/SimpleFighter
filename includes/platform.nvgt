bool platformmove;

dest_plat@[]dest_plats(0);
class dest_plat
{
int defsound,hurtsound;
double minx,maxx,miny,maxy;
double dest_plathealth;
double dest_platmaxhealth;
double volume;
double pitch;
string plat;
dest_plat(double mx,double mx2,double my,double my2,double hp,double maxhp,string dpy,double vol,double semitone)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
dest_plathealth=hp;
dest_platmaxhealth=maxhp;
plat=dpy;
volume=vol;
pitch=semitone;
}
}
void dest_platcheck()
{
for(uint i=0; i<dest_plats.length(); i++)
{
if(dest_plats[i].dest_plathealth<=0)
{
p.destroy_sound(dest_plats[i].hurtsound);
dest_plats[i].defsound=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/platforms/"+dest_plats[i].plat+"/*death*"),me.x,me.y,dest_plats[i].minx,dest_plats[i].miny,0,0,0,0,false,0,0,tilevolume,tilepitch,false);
p.update_sound_2d(dest_plats[i].defsound,dest_plats[i].minx,dest_plats[i].miny);
p.update_sound_range_2d(dest_plats[i].defsound,0,dest_plats[i].maxx-dest_plats[i].minx,0,dest_plats[i].maxy-dest_plats[i].miny);
dest_plats.remove_at(i);
return;
}
}
}
void spawn_dest_plat(double x1,double x2,double y1,double y2,double hp,double hp2,string plat,double platvolume,double platpitch)
{
dest_plat dpf1(x1,x2,y1,y2,hp,hp2,plat,platvolume,platpitch);
dest_plats.insert_last(dpf1);
}
void destroy_all_dest_plats()
{
dest_plats.resize(0);
}

moving_platform@[]moving_platforms(0);
class moving_platform
{
    int platsound;
    int platform_id;
    double minx, maxx, miny, maxy;
    double currentx, currenty;
    double sizex;
    string tile;
    string mplattype;
    int move_mode;
    int snap_mode;
    double speed;
    bool moving_forward;
    double move_accumulator_x, move_accumulator_y;
    double tilevolume;
    double tilepitch;
    double mplatvolume;
    double mplatpitch;
    double offset_volume;

    moving_platform(double left_x, double right_x, double bottom_y, double top_y, double x_length, int direction, int snap, int speed_in, string ty, double vol, double semitone, string mptype, double vol2, double semitone2, double vol_offset)
    {
        minx = left_x;
        maxx = right_x;
        miny = bottom_y;
        maxy = top_y;
        sizex = x_length;
        currentx = minx;
        currenty = miny;
        move_mode = direction;
        snap_mode = snap;
        if (speed_in <= 0) speed_in = 1;
        speed = 1.0 / speed_in;
        tile = ty;
        tilevolume = vol;
        tilepitch = semitone;
        mplattype = mptype;
        mplatvolume = vol2;
        mplatpitch = semitone2;
        offset_volume = vol_offset;
        moving_forward = true;
        move_accumulator_x = 0;
        move_accumulator_y = 0;        
        platform_id = spawn_platform(left_x, left_x + x_length, bottom_y, bottom_y + 1, tile, tilevolume, tilepitch);        
        platsound = platpool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/moving platforms/" + mplattype + "/*loop*"), me.x, me.y, currentx, currenty, 0, 0, 0, 0, true, 0, 0, mplatvolume, mplatpitch, false);
        update_platform_sound();
    }
void update_platform_sound()
    {
        platpool.update_sound_2d(platsound, currentx, currenty);
        platpool.update_sound_range_2d(platsound, 0, maxx - minx, 0, maxy - miny);
    }

    bool is_on_platform()
    {
        return (me.x >= currentx - 0.5 && me.x <= currentx + sizex + 0.5 && 
                (me.y == currenty || me.y == currenty - 1 || me.y == currenty + 1));
    }

    void check_player()
    {
        platformmove = is_on_platform();
        if (platformmove)
        {
            me.y = currenty;
        }
    }

    void move()
    {
        double old_x = currentx;
        double old_y = currenty;
        double dx = 0, dy = 0;
        bool reached_endpoint = false;

        switch(move_mode)
        {
            case 0: case 4:
                dx = (move_mode == 0 ? 1 : -1) * (moving_forward ? speed : -speed);
                reached_endpoint = (moving_forward && currentx >= maxx) || (!moving_forward && currentx <= minx);
                break;
            case 1: case 5:
                dy = (move_mode == 1 ? 1 : -1) * (moving_forward ? speed : -speed);
                reached_endpoint = (moving_forward && currenty >= maxy) || (!moving_forward && currenty <= miny);
                break;
            case 2: case 6:
                dx = (move_mode == 2 ? 1 : -1) * (moving_forward ? speed : -speed);
                dy = (move_mode == 2 ? 1 : -1) * (moving_forward ? speed : -speed);
                reached_endpoint = (moving_forward && (currentx >= maxx || currenty >= maxy)) || (!moving_forward && (currentx <= minx || currenty <= miny));
                break;
            case 3: case 7:
                dx = (move_mode == 3 ? -1 : 1) * (moving_forward ? speed : -speed);
                dy = (move_mode == 3 ? 1 : -1) * (moving_forward ? speed : -speed);
                reached_endpoint = (moving_forward && (currentx <= minx || currenty >= maxy)) || (!moving_forward && (currentx >= maxx || currenty <= miny));
                break;
        }

        move_accumulator_x += dx;
        move_accumulator_y += dy;

        if(abs(move_accumulator_x) >= 1)
        {
            int steps = int(move_accumulator_x);
            currentx += steps;
            move_accumulator_x -= steps;
        }

        if(abs(move_accumulator_y) >= 1)
        {
            int steps = int(move_accumulator_y);
            currenty += steps;
            move_accumulator_y -= steps;
        }

        if(reached_endpoint)
        {
            switch(snap_mode)
            {
                case 0:
                    moving_forward = !moving_forward;
                    break;
                case 1:
                    if(moving_forward)
                    {
                        currentx = minx;
                        currenty = miny;
                    }
                    break;
                case 2:
                    if(!moving_forward)
                    {
                        currentx = maxx;
                        currenty = maxy;
                    }
                    break;
                case 3:
                    if(moving_forward)
                    {
                        currentx = maxx;
                        currenty = maxy;
                    }
                    else
                    {
                        currentx = minx;
                        currenty = miny;
                    }
                    break;
            }
        }

        currentx = clamp(currentx, minx, maxx);
        currenty = clamp(currenty, miny, maxy);
        update_platform(platform_id, currentx, currentx + sizex, currenty, currenty + 1);        
        if(platformmove)
        {
            me.x += (currentx - old_x);
            me.y += (currenty - old_y);
            me.x = clamp(me.x, currentx, currentx + sizex);
            me.y = clamp(me.y, currenty, currenty + 1);
        }
        update_platform_sound();
        if(platformmove)
        {
            platpool.update_sound_start_values(platsound, -1, mplatvolume - offset_volume, -1);
        }
        else
        {
            platpool.update_sound_start_values(platsound, -1, mplatvolume, -1);
        }
    }
};

void mplatcheck()
{
    for(uint i = 0; i < moving_platforms.length(); i++)
    {
        moving_platforms[i].check_player();
        moving_platforms[i].move();
    }
}

void spawn_moving_platform(double left_x, double right_x, double bottom_y, double top_y, double x_length, int direction, int snap, int speed, string ty, double vol, double semitone, string mptype, double vol2, double semitone2, double vol_offset)
{
    moving_platform mp1(left_x, right_x, bottom_y, top_y, x_length, direction, snap, speed, ty, vol, semitone, mptype, vol2, semitone2, vol_offset);
    moving_platforms.insert_last(mp1);
}

void destroy_all_moving_platforms()
{
    for(uint i = 0; i < moving_platforms.length(); i++)
    {
        platpool.destroy_sound(moving_platforms[i].platsound);
        remove_platform(moving_platforms[i].platform_id);
    }
    moving_platforms.resize(0);
    platformmove = false;
}

platform@[]platforms(0);
class platform
{
double minx, maxx, miny, maxy;
double volume;
double pitch;
string tile;
platform(double mx,double mx2,double my,double my2,string ty,double vol,double semitone)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
tile=ty;
volume=vol;
pitch=semitone;
}
}
int spawn_platform(double x1, double x2, double y1, double y2, string tile, double tilevol, double tilepitch)
{
    platform pl1(x1, x2, y1, y2, tile, tilevol, tilepitch);
    platforms.insert_last(pl1);
    return platforms.length() - 1;
}
void update_platform(int id, double x1, double x2, double y1, double y2)
{
    if (id >= 0 && id < platforms.length())
    {
        platforms[id].minx = x1;
        platforms[id].maxx = x2;
        platforms[id].miny = y1;
        platforms[id].maxy = y2;
    }
}
void remove_platform(int id)
{
    if (id >= 0 && id < platforms.length())
    {
        platforms.remove_at(id);
    }
}
void destroy_all_platforms()
{
platforms.resize(0);
}

vanishing_platform@[]vanishing_platforms(0);
class vanishing_platform
{
bool vanished;
int vplatsound;
double minx, maxx, miny, maxy;
double tilevolume;
double tilepitch;
double vplatvolume;
double vplatpitch;
int vplattime;
string tile;
string vptype;
timer vplattimer;
vanishing_platform(double mx,double mx2,double my,double my2,string ty,double vol,double semitone,string vtype,double vol2,double semitone2,int vtime)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
tile=ty;
tilevolume=vol;
tilepitch=semitone;
vptype=vtype;
vplatvolume=vol2;
vplatpitch=semitone2;
vplattime=vtime;
spawn_platform(minx, maxx, miny, maxy, tile, tilevolume, tilepitch);
vplatsound=vanpool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/vanishing platforms/"+vptype+"/*loop*"),me.x,me.y,minx,miny,0,0,0,0,true,0,0,vplatvolume,vplatpitch,false);
vanpool.update_sound_2d(vplatsound,minx,miny);
vanpool.update_sound_range_2d(vplatsound, 0, maxx-minx, 0, maxy-miny);
}
}
void vplatloop()
{
for(uint i=0; i<vanishing_platforms.length(); i++)
{
if(vanishing_platforms[i].vanished==false and vanishing_platforms[i].vplattimer.elapsed>=vanishing_platforms[i].vplattime)
{
vanpool.destroy_sound(vanishing_platforms[i].vplatsound);
spawn_platform(vanishing_platforms[i].minx, vanishing_platforms[i].maxx, vanishing_platforms[i].miny, vanishing_platforms[i].maxy, "", vanishing_platforms[i].tilevolume, vanishing_platforms[i].tilepitch);
vanishing_platforms[i].vanished=true;
vanishing_platforms[i].vplattimer.restart();
}
else if(vanishing_platforms[i].vanished==true and vanishing_platforms[i].vplattimer.elapsed>=vanishing_platforms[i].vplattime)
{
spawn_platform(vanishing_platforms[i].minx, vanishing_platforms[i].maxx, vanishing_platforms[i].miny, vanishing_platforms[i].maxy, vanishing_platforms[i].tile, vanishing_platforms[i].tilevolume, vanishing_platforms[i].tilepitch);
vanishing_platforms[i].vplatsound=vanpool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/vanishing platforms/"+vanishing_platforms[i].vptype+"/*loop*"),me.x,me.y,vanishing_platforms[i].minx,vanishing_platforms[i].miny,0,0,0,0,true,0,0,vanishing_platforms[i].vplatvolume,vanishing_platforms[i].vplatpitch,false);
vanpool.update_sound_2d(vanishing_platforms[i].vplatsound,vanishing_platforms[i].minx,vanishing_platforms[i].miny);
vanpool.update_sound_range_2d(vanishing_platforms[i].vplatsound, 0, vanishing_platforms[i].maxx-vanishing_platforms[i].minx, 0, vanishing_platforms[i].maxy-vanishing_platforms[i].miny);
vanishing_platforms[i].vanished=false;
vanishing_platforms[i].vplattimer.restart();
}
}
}
void spawn_vanishing_platform(double x1,double x2,double y1,double y2,string tile,double tilevol,double tilepitch,string vtype,double vplatvol,double vplatpitch,int vtime)
{
vanishing_platform vp1(x1,x2,y1,y2,tile,tilevol,tilepitch,vtype,vplatvol,vplatpitch,vtime);
vanishing_platforms.insert_last(vp1);
}
void destroy_all_vanishing_platforms()
{
for(uint i=0; i<vanishing_platforms.length(); i++)
{
vanpool.destroy_sound(vanishing_platforms[i].vplatsound);
}
vanishing_platforms.resize(0);
}
