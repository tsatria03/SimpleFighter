void clearmap()
{
destroy_all_ambsources();
destroy_all_blockages();
destroy_all_dest_walls();
destroy_all_doors();
destroy_all_musicambs();
destroy_all_musicsources();
destroy_all_platforms();
destroy_all_psdoors();
destroy_all_pspassages();
destroy_all_passages();
destroy_all_reverb_effects();
destroy_all_soundsources();
destroy_all_spawnpoints();
destroy_all_staircases();
destroy_all_walls();
destroy_all_zones();
}
void destroymap()
{
destroy_all_animals();
destroy_all_animalzones();
destroy_all_belts();
destroy_all_bombs();
destroy_all_bombzones();
destroy_all_bosses();
destroy_all_bullets();
destroy_all_calanders();
destroy_all_checkpoints();
destroy_all_clocks();
destroy_all_dialogs();
destroy_all_humans();
destroy_all_humanzones();
destroy_all_floorbreakers();
destroy_all_forcefields();
destroy_all_hazards();
destroy_all_healzones();
destroy_all_helpers();
destroy_all_lifts();
destroy_all_mines();
destroy_all_menuzones();
destroy_all_moving_hazards();
destroy_all_moving_platforms();
destroy_all_objs();
destroy_all_objzones();
destroy_all_projectiles();
destroy_all_projzones();
destroy_all_robots();
destroy_all_robotzones();
destroy_all_safezones();
destroy_all_signs();
destroy_all_spikes();
destroy_all_teleporters();
destroy_all_text_squares();
destroy_all_timebombs();
destroy_all_timedmusics();
destroy_all_timedsources();
destroy_all_timedtexts();
destroy_all_travelpoints();
destroy_all_turrets();
destroy_all_vanishing_platforms();
destroy_all_vehicles();
destroy_all_zombies();
destroy_all_zombiezones();
}

void gop(string entity,string id,double x,double y)
{
if(x<minx or x>maxx or y<miny or y>maxy)
{
dlg_snd("Error! You can't move yourself or an entity out of map boundries! Please try again! Press enter to continue.");
return;
}
if (entity == "me")
{
me.x=x;
me.y=y;
fallcounter=0;
jumping=0;
falling=false;
if(fallcounter>=0) p.destroy_sound(fallslot);
if(charmovesound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*move*"),false);
speak("Player moved to "+me.x+", "+me.y+".");
}
else if(entity=="animal")
{
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animaltype==id)
{
animals[i].amx=int(x);
animals[i].amy=int(y);
animalpool.update_sound_2d(animals[i].amsound, animals[i].amx, animals[i].amy);
animals[i].animaltimer.restart();
speak("animal moved to "+animals[i].amx+", "+animals[i].amy+".");
return;
}
}
}
else if(entity=="human")
{
for(uint i=0; i<humans.length(); i++)
{
if(humans[i].humantype==id)
{
humans[i].humx=int(x);
humans[i].humy=int(y);
humanpool.update_sound_2d(humans[i].humsound, humans[i].humx, humans[i].humy);
humans[i].humantimer.restart();
speak("human moved to "+humans[i].humx+", "+humans[i].humy+".");
return;
}
}
}
else if(entity=="boss")
{
for(uint i=0; i<bosses.length(); i++)
{
if(bosses[i].bosstype==id)
{
bosses[i].bossx=int(x);
bosses[i].bossy=int(y);
bosspool.update_sound_2d(bosses[i].bossesound, bosses[i].bossx, bosses[i].bossy);
bosses[i].bosstimer.restart();
speak("boss moved to "+bosses[i].bossx+", "+bosses[i].bossy+".");
return;
}
}
}
else if(entity=="helper")
{
for(uint i=0; i<helpers.length(); i++)
{
if(helpers[i].helpertype==id)
{
helpers[i].helpx=int(x);
helpers[i].helpy=int(y);
helperpool.update_sound_2d(helpers[i].helpersound, helpers[i].helpx, helpers[i].helpy);
helpers[i].helpertimer.restart();
speak("helper moved to "+helpers[i].helpx+", "+helpers[i].helpy+".");
return;
}
}
}
else if(entity=="projectile")
{
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projtype==id)
{
projectiles[i].prox=int(x);
projectiles[i].proy=int(y);
projpool.update_sound_2d(projectiles[i].projsound, projectiles[i].prox, projectiles[i].proy);
projectiles[i].projtimer.restart();
speak("projectile moved to "+projectiles[i].prox+", "+projectiles[i].proy+".");
return;
}
}
}
else if(entity=="robot")
{
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].robottype==id)
{
robots[i].robx=int(x);
robots[i].roby=int(y);
robpool.update_sound_2d(robots[i].robsound, robots[i].robx, robots[i].roby);
robots[i].robottimer.restart();
speak("robot moved to "+robots[i].robx+", "+robots[i].roby+".");
return;
}
}
}
else if(entity=="turret")
{
for(uint i=0; i<turrets.length(); i++)
{
if(turrets[i].turtype==id)
{
turrets[i].turx=int(x);
turrets[i].tury=int(y);
turpool.update_sound_2d(turrets[i].tursound, turrets[i].turx, turrets[i].tury);
turrets[i].turtimer.restart();
speak("turret moved to "+turrets[i].turx+", "+turrets[i].tury+".");
return;
}
}
}
else if(entity=="zombie")
{
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombietype==id)
{
zombies[i].zombx=int(x);
zombies[i].zomby=int(y);
zombpool.update_sound_2d(zombies[i].zombsound, zombies[i].zombx, zombies[i].zomby);
zombies[i].zombietimer.restart();
speak("zombie moved to "+zombies[i].zombx+", "+zombies[i].zomby+".");
return;
}
}
}
else if(entity=="item")
{
for(uint i=0; i<objs.length(); i++)
{
if(objs[i].objtype2==id)
{
objs[i].itx=int(x);
objs[i].ity=int(y);
itempool.update_sound_2d(objs[i].objsound, objs[i].itx, objs[i].ity);
objs[i].objtimer.restart();
speak("item moved to "+objs[i].itx+", "+objs[i].ity+".");
return;
}
}
}
else if(entity=="mine")
{
for(uint i=0; i<mines.length(); i++)
{
if(mines[i].minetype==id)
{
mines[i].minex=int(x);
mines[i].miney=int(y);
minepool.update_sound_2d(mines[i].minesound, mines[i].minex, mines[i].miney);
speak("mine moved to "+mines[i].minex+", "+mines[i].miney+".");
return;
}
}
}
else if(entity=="sign")
{
for(uint i=0; i<signs.length(); i++)
{
if(signs[i].signtype==id)
{
signs[i].signx=int(x);
signs[i].signy=int(y);
signpool.update_sound_2d(signs[i].signsound, signs[i].signx, signs[i].signy);
speak("sign moved to "+signs[i].signx+", "+signs[i].signy+".");
return;
}
}
}
else if(entity=="vehicle")
{
for(uint i=0; i<vehicles.length(); i++)
{
if(vehicles[i].vehtype==id)
{
vehicles[i].vehx=int(x);
vehicles[i].vehy=int(y);
vehpool.update_sound_2d(vehicles[i].vehsound, vehicles[i].vehx, vehicles[i].vehy);
speak("vehicle moved to "+vehicles[i].vehx+", "+vehicles[i].vehy+".");
return;
}
}
}
else
{
dlg_snd("Error! Unknown entity type "+id+".");
return;
}
}

void speakcoordinates()
{
if(locspeech==1 and gmt(me.x,me.y)=="")
{
speak("in the air,"+"facing;"+facing);
}
else if(locspeech==1)
{
speak("on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
if(locspeech==2 )
{
speak(me.x+",;"+me.y+",;"+"facing;"+facing);
}
if(locspeech==3 and gmt(me.x,me.y)=="")
{
speak(me.x+",;"+me.y+";"+"in the air,"+"facing;"+facing);
}
else if(locspeech==3)
{
speak(me.x+",;"+me.y+";"+"on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
if(locspeech==4 and gmt(me.x,me.y)=="")
{
speak("current location,"+me.x+",;"+me.y+","+"you're currently in the air,"+"facing;"+facing);
}
else if(locspeech==4)
{
speak("current location,"+me.x+",;"+me.y+","+"you're walking on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
}

void load_map(string name, string owner, bool instent_update=true, bool speak_percentage=false, bool anounce_mapload=false, int loadtime=50, int loadbeeps=maploadbeeps, int loadsounds=maploadsounds)
{
mapname=name;
mapowner=owner;
maploadbeeps=loadbeeps;
maploadsounds=loadsounds;
clearmap();
destroymap();
if(string_ends_with(mapname,".map"))
{
mapname=string_replace(mapname,".map","",true);
}
if(!file_exists("data/maps/"+mapname+".map"))
{
dlg_snd("Error. This map is invalid. Please check the map name in the file and try again. Press enter to continue.");
mainmenu();
}
mapper.open("data/maps/"+mapname+".map","rb");
mapdata=mapper.read();
mapper.close();
sound mapload;
timer maploadtimer;
if(anounce_mapload==true) speak("loading map");
if(loadsounds==1) mpool.play_stationary("maploadstart.ogg",false);
if(loadsounds==1) mapload.load("maploading.ogg");
if(loadsounds==1) mapload.play_looped();
string[] lines=delinear(mapdata);
double percent=0;
double last_beep_percent=-1;
for (uint i=0; i<lines.length(); i++)
{
if(loadbeeps == 1)
{
double l=lines.length(), ind=i;
int current_percent=int(ind/l*100);
if(current_percent>last_beep_percent && maploadtimer.elapsed>=loadtime)
{
if(speak_percentage==true) speak(current_percent+" percent");
beep_percentage(current_percent);
last_beep_percent=current_percent;
maploadtimer.restart();
}
}        
if(!instent_update)
{
wait(5);
}
string[] sd=string_split(lines[i], " ", true);
if(sd[0]=="name" && sd.length()==2)
{
mapname=sd[1];
}
else if(sd[0]=="minx" && sd.length()==2)
{
minx=stn(sd[1]);
}
else if(sd[0]=="maxx" && sd.length()==2)
{
maxx=stn(sd[1]);
}
else if(sd[0]=="miny" && sd.length()==2)
{
miny=stn(sd[1]);
}
else if(sd[0]=="maxy" && sd.length()==2)
{
maxy=stn(sd[1])+jumpheight;
}
else if(sd[0]=="contributor" && sd.length()==2)
{
mapowner=sd[1];
}
else if(sd[0]=="platform" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
spawn_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch);
}
else if(sd[0]=="staircase" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string tiletype=sd[5];
double stairsvol=stn(sd[6]);
double stairspitch=stn(sd[7]);
spawn_staircase(mx, mx2, my, my2, tiletype, stairsvol, stairspitch);
}
else if(sd[0]=="vanishing_platform" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
string vplattype=sd[7];
double vplatvol=stn(sd[8]);
double vplatpitch=stn(sd[9]);
int sp=stn(sd[10]);
spawn_vanishing_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch, vplattype, vplatvol, vplatpitch, sp);
}
else if(sd[0]=="dest_wall" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
string dest_walltype=sd[6];
double wallvol=stn(sd[7]);
double wallpitch=stn(sd[8]);
spawn_dest_wall(mx, mx2, my, my2, hp, hp, dest_walltype, wallvol, wallpitch);
}
else if(sd[0]=="wall" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string walltype=sd[5];
double wallvol=stn(sd[6]);
double wallpitch=stn(sd[7]);
spawn_wall(mx, mx2, my, my2, walltype, wallvol, wallpitch);
}
else if(sd[0]=="blockage" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_blockage(mx, mx2, my, my2, txt);
}
else if(sd[0]=="door" && sd.length()==14)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string lotype=sd[7];
string motype=sd[8];
string optype=sd[9];
string cotype=sd[10];
string dotype=sd[11];
bool amt=string_to_bool(sd[12]);
bool dbl=string_to_bool(sd[13]);
spawn_door(sx, sy, sx2, sy2, hp, hp, sp, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="psdoor" && sd.length()==15)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string drpass=sd[7];
string lotype=sd[8];
string motype=sd[9];
string optype=sd[10];
string cotype=sd[11];
string dotype=sd[12];
bool amt=string_to_bool(sd[13]);
bool dbl=string_to_bool(sd[14]);
spawn_psdoor(sx, sy, sx2, sy2, hp, hp, sp, drpass, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="passage" && sd.length()==11)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
int sp2=stn(sd[10]);
spawn_passage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, sp2);
}
else if(sd[0]=="pspassage" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
string pspass=sd[10];
int sp2=stn(sd[11]);
spawn_pspassage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, pspass, sp2);
}
else if(sd[0]=="menu_zone" && sd.length()==5)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
create_menuzone(mx, mx2, my, my2);
}
else if(sd[0]=="safe_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string safetype=sd[5];
spawn_safezone(mx, mx2, my, my2, safetype);
}
else if(sd[0]=="zone" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_zone(mx, mx2, my, my2, txt);
}
else if(sd[0]=="reverb" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string id=sd[5];
float dry=stn(sd[6]);
float wet=stn(sd[7]);
float size=stn(sd[8]);
float damp=stn(sd[9]);
float width=stn(sd[10]);
spawn_reverb_effect(mx, mx2, my, my2, id, dry, wet, size, damp, width);
}
else if(sd[0]=="text_square" && sd.length()>=4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length());
spawn_text_square(x, y, txt);
}
else if(sd[0]=="clock" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string clocktype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_clock(x, y, txt, clocktype, dbl);
}
else if(sd[0]=="calander" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string calandertype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_calander(x, y, txt, calandertype, dbl);
}
else if(sd[0]=="music_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musicvol=stn(sd[6]);
double musicpitch=stn(sd[7]);
spawn_musicamb(mx, mx2, my, my2, musictype, musicvol, musicpitch);
}
else if(sd[0]=="music_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
spawn_musicsource(mx, mx2, my, my2, musictype, musvol, muspitch);
}
else if(sd[0]=="sound_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_ambsource(mx, mx2, my, my2, sorcetype, soundvol, soundpitch);
}
else if(sd[0]=="sound_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_soundsource(mx, mx2, my, my2, sourcetype, soundvol, soundpitch);
}
else if(sd[0]=="timebomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string timbotype=sd[5];
spawn_timebomb(x, y, dmg, sp, timbotype);
}
else if(sd[0]=="timed_music" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
int musictime=stn(sd[8]);
spawn_timedmusic(mx, mx2, my, my2, musvol, muspitch, musictime, musictype);
}
else if(sd[0]=="timed_source" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
int sourcetime=stn(sd[8]);
spawn_timedsource(mx, mx2, my, my2, soundvol, soundpitch, sourcetime, sourcetype);
}
else if(sd[0]=="timed_text" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int texttime=stn(sd[5]);
string txt=join_string_array(sd, 6, sd.length());
spawn_timedtext(mx, mx2, my, my2, texttime, txt);
}
else if(sd[0]=="heal_zone" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int hm=stn(sd[5]);
int hp=stn(sd[6]);
int ht=stn(sd[7]);
string hlt=sd[8];
spawn_healzone(mx, mx2, my, my2, hm, hp, ht,hlt);
}
else if(sd[0]=="hazard" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string hazardtype=sd[5];
bool lgp=string_to_bool(sd[6]);
spawn_hazard(mx, mx2, my, my2, hazardtype, lgp);
}
else if(sd[0]=="lift" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
double tilevol=stn(sd[8]);
double tilepitch=stn(sd[9]);
string lifttype=sd[10];
double liftvol=stn(sd[11]);
double liftpitch=stn(sd[12]);
spawn_lift(mx, mx2, my, my2, dir, sp, tiletype, tilevol, tilepitch, lifttype, liftvol, liftpitch);
}
else if(sd[0]=="mine" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
string minetype=sd[4];
bool tg=string_to_bool(sd[5]);
spawn_mine(x, y, dmg, minetype, tg);
}
else if(sd[0]=="mhazard" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
double sy=stn(sd[6]);
int dir=stn(sd[7]);
int dir2=stn(sd[8]);
int sp=stn(sd[9]);
string hazardtype=sd[10];
spawn_moving_hazard(mx, mx2, my, my2, sx, sy, dir, dir2, sp, hazardtype);
}
else if(sd[0]=="mplatform" && sd.length()==16)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
int dir=stn(sd[6]);
int dir2=stn(sd[7]);
int sp=stn(sd[8]);
string tiletype=sd[9];
double tilevol=stn(sd[10]);
double tilepitch=stn(sd[11]);
string mplattype=sd[12];
double mplatvol=stn(sd[13]);
double mplatpitch=stn(sd[14]);
int vs=stn(sd[15]);
spawn_moving_platform(mx, mx2, my, my2, sx, dir, dir2, sp, tiletype, tilevol, tilepitch, mplattype, mplatvol, mplatpitch, vs);
}
else if(sd[0]=="sign" && sd.length()>=7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-3);
string signtype=sd[sd.length()-3];
bool dbl=string_to_bool(sd[sd.length()-2]);
bool lps=string_to_bool(sd[sd.length()-1]);
spawn_sign(x, y, txt, signtype, dbl, lps);
}
else if(sd[0]=="checkpoint" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int checktime=stn(sd[3]);
string checktype=sd[4];
spawn_checkpoint(x, y, checktime, checktype);
}
else if(sd[0]=="dialog" && sd.length()>=8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length()-2);
string dlgtype=sd[sd.length()-2];
dlgtyp=dlgtype;
bool dlm=string_to_bool(sd[sd.length()-1]);
spawn_dialog(mx, mx2, my, my2, txt, dlgtype, dlm);
}
else if(sd[0]=="item" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int objtime=stn(sd[3]);
string objtype=sd[4];
string objtype2=sd[5];
bool automatic=string_to_bool(sd[6]);
spawn_obj(x, y, objtime, objtype, objtype2, automatic);
}
else if(sd[0]=="item_zone" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int sp=stn(sd[5]);
string objtype=sd[6];
string objtype2=sd[7];
spawn_objzone(mx, mx2, my, my2, sp, objtype, objtype2);
}
else if(sd[0]=="spike" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
string spiketype=sd[8];
bool dbl=string_to_bool(sd[9]);
spawn_spike(mx, mx2, my, my2, hp, hp, dmg, sp, spiketype, dbl);
}
else if(sd[0]=="spawnpoint" && sd.length()==3)
{
int spx=stn(sd[1]);
int spy=stn(sd[2]);
create_spawnpoint(spx, spy);
}
else if(sd[0]=="travelpoint" && sd.length()>=9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string destmap=sd[5];
int destx=stn(sd[6]);
int desty=stn(sd[7]);
string endtext=sd[8];
spawn_travelpoint(mx, mx2, my, my2, destmap, destx, desty, endtext);
}
else if(sd[0]=="animal" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int anirange=stn(sd[3]);
int anirange2=stn(sd[4]);
int anirange3=stn(sd[5]);
int anirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string amtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_animal(x, y, anirange, anirange2, anirange3, anirange4, hp, hp, card, dmg, ft, sp, lv, xp, amtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="human" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int humrange=stn(sd[3]);
int humrange2=stn(sd[4]);
int humrange3=stn(sd[5]);
int humrange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string humtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_human(x, y, humrange, humrange2, humrange3, humrange4, hp, hp, card, dmg, ft, sp, lv, xp, humtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="floor_breaker" && sd.length()==4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string floorbtype=sd[3];
spawn_floorbreaker(x, y, floorbtype);
}
else if(sd[0]=="forcefield" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dmg=stn(sd[5]);
int sp=stn(sd[6]);
string forcetype=sd[7];
spawn_forcefield(mx, mx2, my, my2, dmg, sp, forcetype);
}
else if(sd[0]=="helper" && sd.length()==10)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
string helptyp=sd[9];
spawn_helper(x, y, hp, hp, card, dmg, ft, sp, lv, helptyp);
}
else if(sd[0]=="projectile" && sd.length()==13)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dir=stn(sd[3]);
double hp=stn(sd[4]);
int card=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
double xp=stn(sd[9]);
string potype=sd[10];
bool fb=string_to_bool(sd[11]);
bool mb=string_to_bool(sd[12]);
spawn_projectile(x, y, dir, hp, hp, card, dmg, sp, lv, xp, potype, fb, mb);
}
else if(sd[0]=="robot" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int roborange=stn(sd[3]);
int roborange2=stn(sd[4]);
int roborange3=stn(sd[5]);
int roborange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string rotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_robot(x, y, roborange, roborange2, roborange3, roborange4, hp, hp, card, dmg, ft, sp, lv, xp, rotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="turret" && sd.length()==17)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int lt=stn(sd[7]);
int sp=stn(sd[8]);
double lv=stn(sd[9]);
double xp=stn(sd[10]);
string tutype=sd[11];
string tutype2=sd[12];
string tutype3=sd[13];
bool fb=string_to_bool(sd[14]);
bool mb=string_to_bool(sd[15]);
bool mb2=string_to_bool(sd[16]);
spawn_turret(x, y, hp, hp, card, dmg, ft, lt, sp, lv, xp, tutype, tutype2, tutype3, fb, mb, mb2);
}
else if(sd[0]=="zombie" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int zombirange=stn(sd[3]);
int zombirange2=stn(sd[4]);
int zombirange3=stn(sd[5]);
int zombirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string zotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_zombie(x, y, zombirange, zombirange2, zombirange3, zombirange4, hp, hp, card, dmg, ft, sp, lv, xp, zotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="animal_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string amtype=sd[5];
spawn_animalzone(mx, mx2, y, sp, amtype);
}
else if(sd[0]=="bomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bomb(x, y, dmg, sp, botype);
}
else if(sd[0]=="bomb_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bombzone(mx, mx2, y, sp, botype);
}
else if(sd[0]=="boss" && sd.length()==27)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int boserange=stn(sd[3]);
int boserange2=stn(sd[4]);
int boserange3=stn(sd[5]);
int boserange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int lt=stn(sd[11]);
int sp=stn(sd[12]);
int tt=stn(sd[13]);
int ht=stn(sd[14]);
double lv=stn(sd[15]);
double xp=stn(sd[16]);
string bosstyp=sd[17];
string bosstyp2=sd[18];
string bosstyp3=sd[19];
bool fb=string_to_bool(sd[20]);
bool mb=string_to_bool(sd[21]);
bool mb2=string_to_bool(sd[22]);
bool tb=string_to_bool(sd[23]);
bool tb2=string_to_bool(sd[24]);
bool hb=string_to_bool(sd[25]);
bool dpm=string_to_bool(sd[26]);
spawn_boss(x, y, boserange, boserange2, boserange3, boserange4, hp, hp, card, dmg, ft, lt, sp, tt, ht, lv, xp, bosstyp, bosstyp2, bosstyp3, fb, mb, mb2, tb, tb2, hb, dpm);
}
else if(sd[0]=="belt" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
string belttyp=sd[8];
spawn_belt(mx, mx2, my, my2, dir, sp, tiletype, belttyp);
}
else if(sd[0]=="human_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string emtype=sd[5];
spawn_humanzone(mx, mx2, y, sp, emtype);
}
else if(sd[0]=="projectile_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string potype=sd[5];
spawn_projzone(mx, mx2, y, sp, potype);
}
else if(sd[0]=="robot_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string rotype=sd[5];
spawn_robotzone(mx, mx2, y, sp, rotype);
}
else if(sd[0]=="teleporter" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
int telrange=stn(sd[5]);
int telrange2=stn(sd[6]);
int sp=stn(sd[7]);
string teltype=sd[8];
bool mb=string_to_bool(sd[9]);
bool mb2=string_to_bool(sd[10]);
bool ss=string_to_bool(sd[11]);
spawn_teleporter(sx, sy, sx2, sy2, telrange, telrange2, sp, teltype, mb, mb2, ss);
}
else if(sd[0]=="vehicle" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int dmg=stn(sd[4]);
string vehtyp=sd[5];
bool fb=string_to_bool(sd[6]);
spawn_vehicle(x, y, hp, hp, dmg, vehtyp, fb);
}
else if(sd[0]=="zombie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string zotype=sd[5];
spawn_zombiezone(mx, mx2, y, sp, zotype);
}
if(last_spawnpoint!is null)
{
me.x=last_spawnpoint.spawnx;
me.y=last_spawnpoint.spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else if(spawnpoints.length()>0)
{
me.x=spawnpoints[0].spawnx;
me.y=spawnpoints[0].spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else
{
me.x=me.x;
me.y=me.y;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
}
if(loadsounds==1) mapload.stop();
if(loadsounds==1) mpool.play_stationary("maploadstop.ogg",false);
if(loadbeeps == 1 && last_beep_percent<100)
{
if(speak_percentage==true) speak("100 "+"percent");
if(loadbeeps == 1) beep_percentage(100);
if(anounce_mapload==true) speak("map loded.");
}
}
void comparse()
{
vd.set_disallowed_chars("", false, "This character is not allowed.");
string cmd=vd.input_box("","Enter the command you'd like to use.");
if(cmd=="")
return;
string[] sd=string_split(cmd, "/", true);
if(sd.length()<2)
{
speak("Invalid command syntax. Make sure to include '/' followed by a command.");
game(true);
}
string command = sd[1];
string[] parsed = string_split(command, " ", true);
if (parsed.length() < 1)
{
speak("No command entered after '/'.");
game(true);
}
string base_command = parsed[0];
if (base_command == "go")
{
if (parsed.length() == 3)
{
double x = stn(parsed[1]);
double y = stn(parsed[2]);
gop("me", "", x, y);
}
else if (parsed.length() == 5)
{
string entity = parsed[1];
string id = parsed[2];
double x = stn(parsed[3]);
double y = stn(parsed[4]);
gop(entity, id, x, y);
}
else
{
speak("Invalid command syntax. Usage: /go x y, or /go entity id x y.");
game(true);
}
}
else if(base_command=="kill")
{
if(parsed.length()==5)
{
string entity=parsed[1];
string id=parsed[2];
double x=stn(parsed[3]);
double y=stn(parsed[4]);
if(entity=="animal")
{
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animaltype==id && animals[i].amx==x && animals[i].amy==y)
{
animalpool.destroy_sound(animals[i].amsound);
animals[i].defsound=animalpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/animals/"+animals[i].animaltype+"/*death*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=animals[i].amxp*animals[i].amlevel*xpmod;
kills+=1;
spawn_bodyfall(animals[i].amx, animals[i].amy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and animals[i].dropitem==true) spawn_obj(animals[i].amx, animals[i].amy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,animals[i].amx,animals[i].amy,false);
speak("Killed the animal " + id + " at position " + x + ", " + y + ".");
animals.remove_at(i);
return;
}
}
}
else if(entity=="boss")
{
for(uint i=0; i<bosses.length(); i++)
{
if(bosses[i].bosstype==id && bosses[i].bossx==x && bosses[i].bossy==y)
{
bosspool.destroy_sound(bosses[i].bossesound);
bosses[i].defsound=bosspool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/bosses/"+bosses[i].bosstype+"/*death*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=bosses[i].bossxp*bosses[i].bosslevel*xpmod;
kills+=1;
spawn_bodyfall(bosses[i].bossx, bosses[i].bossy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and bosses[i].dropitem==true) spawn_obj(bosses[i].bossx, bosses[i].bossy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,bosses[i].bossx,bosses[i].bossy,false);
speak("Killed the boss " + id + " at position " + x + ", " + y + ".");
bosses.remove_at(i);
return;
}
}
}
else if(entity=="human")
{
for(uint i=0; i<humans.length(); i++)
{
if(humans[i].humantype==id && humans[i].humx==x && humans[i].humy==y)
{
humanpool.destroy_sound(humans[i].humsound);
humans[i].defsound=humanpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/humans/"+humans[i].humantype+"/*death*"),me.x,me.y,humans[i].humx,humans[i].humy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=humans[i].humxp*humans[i].humlevel*xpmod;
kills+=1;
spawn_bodyfall(humans[i].humx, humans[i].humy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and humans[i].dropitem==true) spawn_obj(humans[i].humx, humans[i].humy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,humans[i].humx,humans[i].humy,false);
speak("Killed the human " + id + " at position " + x + ", " + y + ".");
humans.remove_at(i);
return;
}
}
}
else if(entity=="helper")
{
for(uint i=0; i<helpers.length(); i++)
{
if(helpers[i].helpertype==id && helpers[i].helpx==x && helpers[i].helpy==y)
{
helperpool.destroy_sound(helpers[i].helpersound);
helpers[i].defsound=helperpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/helpers/"+helpers[i].helpertype+"/*death*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,0,0,0,0,false,0,0,painvolume,painpitch,false);
spawn_bodyfall(helpers[i].helpx, helpers[i].helpy, random(500,1000));
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,helpers[i].helpx,helpers[i].helpy,false);
speak("Killed the helper " + id + " at position " + x + ", " + y + ".");
helpers.remove_at(i);
return;
}
}
}
else if(entity=="projectile")
{
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projtype==id && projectiles[i].prox==x && projectiles[i].proy==y)
{
projpool.destroy_sound(projectiles[i].projsound);
projectiles[i].defsound=projpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/projectiles/"+projectiles[i].projtype+"/*death*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=projectiles[i].poxp*projectiles[i].projlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,projectiles[i].prox,projectiles[i].proy,false);
speak("Killed the projectile " + id + " at position " + x + ", " + y + ".");
projectiles.remove_at(i);
return;
}
}
}
else if(entity=="robot")
{
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].robottype==id && robots[i].robx==x && robots[i].roby==y)
{
robpool.destroy_sound(robots[i].robsound);
robots[i].defsound=robpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/robots/"+robots[i].robottype+"/*death*"),me.x,me.y,robots[i].robx,robots[i].roby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=robots[i].robxp*robots[i].roblevel*xpmod;
kills+=1;
spawn_bodyfall(robots[i].robx, robots[i].roby, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and robots[i].dropitem==true) spawn_obj(robots[i].robx, robots[i].roby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,robots[i].robx,robots[i].roby,false);
speak("Killed the robot " + id + " at position " + x + ", " + y + ".");
robots.remove_at(i);
return;
}
}
}
else if(entity=="turret")
{
for(uint i=0; i<turrets.length(); i++)
{
if(turrets[i].turtype==id && turrets[i].turx==x && turrets[i].tury==y)
{
turpool.destroy_sound(turrets[i].tursound);
turrets[i].defsound=turpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/turrets/"+turrets[i].turtype+"/*death*"),me.x,me.y,turrets[i].turx,turrets[i].tury,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=turrets[i].turxp*turrets[i].turlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,turrets[i].turx,turrets[i].tury,false);
speak("Killed the turret " + id + " at position " + x + ", " + y + ".");
turrets.remove_at(i);
return;
}
}
}
else if(entity=="vehicle")
{
for(uint i=0; i<vehicles.length(); i++)
{
if(vehicles[i].vehtype==id && vehicles[i].vehx==x && vehicles[i].vehy==y)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
vehpool.destroy_sound(vehicles[i].beepsound);
vehpool.destroy_sound(vehicles[i].vehsound);
vehicles[i].defsound=vehpool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/vehicles/"+vehicles[i].vehtype+"/*death*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,0,0,0,0,false,0,0,painvolume,painpitch,false);
vehicles[i].vehspeed=5;
invehicle=false;
vehicles[i].moveable=false;
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,false);
speak("Killed the vehicle " + id + " at position " + x + ", " + y + ".");
vehicles.remove_at(i);
return;
}
}
}
else if(entity=="zombie")
{
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombietype==id && zombies[i].zombx==x && zombies[i].zomby==y)
{
zombpool.destroy_sound(zombies[i].zombsound);
zombies[i].defsound=zombpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/zombies/"+zombies[i].zombietype+"/*death*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=zombies[i].zombxp*zombies[i].zomblevel*xpmod;
kills+=1;
spawn_bodyfall(zombies[i].zombx, zombies[i].zomby, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and zombies[i].dropitem==true) spawn_obj(zombies[i].zombx, zombies[i].zomby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,zombies[i].zombx,zombies[i].zomby,false);
speak("Killed the zombie " + id + " at position " + x + ", " + y + ".");
zombies.remove_at(i);
return;
}
}
}
else 
{
speak("Invalid entity type: "+entity+".");
}
}
else
{
speak("Invalid command syntax. Usage: /kill entity id x y.");
game(true);
}
}
else if (base_command == "killall")
{
if (parsed.length() == 1)
{
int total_kills=0;
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animalhealth>0)
{
animalpool.destroy_sound(animals[i].amsound);
animals[i].defsound=animalpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/animals/"+animals[i].animaltype+"/*death*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=animals[i].amxp*animals[i].amlevel*xpmod;
kills+=1;
spawn_bodyfall(animals[i].amx, animals[i].amy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and animals[i].dropitem==true) spawn_obj(animals[i].amx, animals[i].amy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,animals[i].amx,animals[i].amy,false);
}
total_kills++;
}
animals.resize(0);
for(uint i=0; i<bosses.length(); i++)
{
if(bosses[i].bosshealth>0)
{
bosspool.destroy_sound(bosses[i].bossesound);
bosses[i].defsound=bosspool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/bosses/"+bosses[i].bosstype+"/*death*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=bosses[i].bossxp*bosses[i].bosslevel*xpmod;
kills+=1;
spawn_bodyfall(bosses[i].bossx, bosses[i].bossy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and bosses[i].dropitem==true) spawn_obj(bosses[i].bossx, bosses[i].bossy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,bosses[i].bossx,bosses[i].bossy,false);
}
total_kills++;
}
bosses.resize(0);
for(uint i=0; i<humans.length(); i++)
{
if(humans[i].humanhealth>0)
{
humanpool.destroy_sound(humans[i].humsound);
humans[i].defsound=humanpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/humans/"+humans[i].humantype+"/*death*"),me.x,me.y,humans[i].humx,humans[i].humy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=humans[i].humxp*humans[i].humlevel*xpmod;
kills+=1;
spawn_bodyfall(humans[i].humx, humans[i].humy, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
if(healtype.length()!=0 and humans[i].dropitem==true) spawn_obj(humans[i].humx, humans[i].humy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,humans[i].humx,humans[i].humy,false);
}
total_kills++;
}
humans.resize(0);
for(uint i=0; i<helpers.length(); i++)
{
if(helpers[i].helperhealth>0)
{
helperpool.destroy_sound(helpers[i].helpersound);
helpers[i].defsound=helperpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/helpers/"+helpers[i].helpertype+"/*death*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,0,0,0,0,false,0,0,painvolume,painpitch,false);
spawn_bodyfall(helpers[i].helpx, helpers[i].helpy, random(500,1000));
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,helpers[i].helpx,helpers[i].helpy,false);
}
total_kills++;
}
helpers.resize(0);
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projhealth>0)
{
projpool.destroy_sound(projectiles[i].projsound);
projectiles[i].defsound=projpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/projectiles/"+projectiles[i].projtype+"/*death*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=projectiles[i].poxp*projectiles[i].projlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,projectiles[i].prox,projectiles[i].proy,false);
}
total_kills++;
}
projectiles.resize(0);
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].robothealth>0)
{
robpool.destroy_sound(robots[i].robsound);
robots[i].defsound=robpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/robots/"+robots[i].robottype+"/*death*"),me.x,me.y,robots[i].robx,robots[i].roby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=robots[i].robxp*robots[i].roblevel*xpmod;
kills+=1;
spawn_bodyfall(robots[i].robx, robots[i].roby, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/itrobs/unsorted/health/*");
if(healtype.length()!=0 and robots[i].dropitem==true) spawn_obj(robots[i].robx, robots[i].roby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,robots[i].robx,robots[i].roby,false);
}
total_kills++;
}
robots.resize(0);
for(uint i=0; i<turrets.length(); i++)
{
if(turrets[i].turhealth>0)
{
turpool.destroy_sound(turrets[i].tursound);
turrets[i].defsound=turpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/turrets/"+turrets[i].turtype+"/*death*"),me.x,me.y,turrets[i].turx,turrets[i].tury,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=turrets[i].turxp*turrets[i].turlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,turrets[i].turx,turrets[i].tury,false);
}
total_kills++;
}
turrets.resize(0);
for(uint i=0; i<vehicles.length(); i++)
{
if(vehicles[i].vehhealth>0)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
vehpool.destroy_sound(vehicles[i].beepsound);
vehpool.destroy_sound(vehicles[i].vehsound);
vehicles[i].defsound=vehpool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/vehicles/"+vehicles[i].vehtype+"/*death*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,0,0,0,0,false,0,0,painvolume,painpitch,false);
vehicles[i].vehspeed=5;
invehicle=false;
vehicles[i].moveable=false;
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,false);
}
total_kills++;
}
vehicles.resize(0);
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombiehealth>0)
{
zombpool.destroy_sound(zombies[i].zombsound);
zombies[i].defsound=zombpool.play_extended_2d(find_sound("sounds/"+soundpack+"/npc/zombies/"+zombies[i].zombietype+"/*death*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=zombies[i].zombxp*zombies[i].zomblevel*xpmod;
kills+=1;
spawn_bodyfall(zombies[i].zombx, zombies[i].zomby, random(500,1000));
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/itzombs/unsorted/health/*");
if(healtype.length()!=0 and zombies[i].dropitem==true) spawn_obj(zombies[i].zombx, zombies[i].zomby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*kill*"),false);
p.play_2d("punch"+random(4,6)+".ogg",me.x,me.y,zombies[i].zombx,zombies[i].zomby,false);
}
total_kills++;
}
zombies.resize(0);
speak("Killed all entities.");
}
else
{
speak("Invalid command syntax. Usage: /killal.");
game(true);
}
}
else if (base_command == "help")
{
if (parsed.length() == 1)
{
if(coms.open("docks/commands.txt", "rb"))
{
comsplit=coms.read();
coms.close();
string com=string_replace(comsplit, "\r\n", "\n", true);
virtual_info_box("command help", "commands", com);
}
else
{
speak("Failed to open docks/commands.txt.");
}
}
else
{
speak("Invalid command syntax. Usage: /help.");
game(true);
}
}
else if (base_command == "getall")
{
if (parsed.length() == 1)
{
if(objs.length() == 0)
{
speak("There are no items on this map.");
game(true);
}
else
{
for(uint i=0; i<objs.length(); i++)
{
objs[i].getsound=itempool.play_stationary_extended(find_sound("sounds/"+soundpack+"/equipments/items/unsorted/"+objs[i].objtype+"/"+objs[i].objtype2+"/*get*"),false,0,0,itemvolume,itempitch,false);
give(objs[i].objtype2,1);
}
objs.resize(0);
speak("Collected all items.");
}
}
else
{
speak("Invalid command syntax. Usage: /getall.");
game(true);
}
}
else if (base_command == "invclear")
{
if (parsed.length() == 1)
{
if (inv.get_size()==0)
{
speak("There are no items in your inventory.");
game(true);
}
else
{
clear_inv();
speak("Your inventory has been cleared.");
}
}
else
{
speak("Invalid command syntax. Usage: /invclear.");
game(true);
}
}
else if(base_command=="give")
{
if(parsed.length()==3)
{
string item=parsed[1];
int amount=stn(parsed[2]);
if(amount>0)
{
p.play_stationary("give.ogg",false);
give(item,stn(amount));
speak("You received " + amount + " " + (amount == 1 ? item : item + "s") + ".");
}
else
{
p.play_stationary("take.ogg",false);
give(item,stn(amount));
speak("You recycled " + amount + " " + (amount == 1 ? item : item + "s") + ".");
}
}
else
{
speak("Invalid command syntax. Usage: /give item amount.");
}
}
else if (base_command == "menu")
{
if (parsed.length() == 1)
{
pause_pools();
mapmenu2();
}
else
{
speak("Invalid command syntax. Usage: /menu.");
game(true);
}
}
else if (base_command == "preffs")
{
if (parsed.length() == 1)
{
pause_pools();
settingsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /preffs.");
game(true);
}
}
else if (base_command == "stats")
{
if (parsed.length() == 1)
{
pause_pools();
statsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /stats.");
game(true);
}
}
else if (base_command == "changemap")
{
if (parsed.length() == 4)
{
string name=parsed[1];
int x = stn(parsed[2]);
int y = stn(parsed[3]);
if (file_exists("data/maps/" + name + ".map"))
{
if (x >= minx && x <= maxx && y >= miny && y <= maxy)
{
load_map(name,mapowner);
}
}
else
{
speak("Map '" + name + "' not found. Please check the name and try again.");
game(true);
}
if(x >= minx && x <= maxx && y >= miny && y <= maxy)
{
gop("me", "", x, y);
}
else
{
speak("Invalid coordinates. Please make sure x and y are within the map boundaries.");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /changemap mapname x y.");
game(true);
}
}
else if (base_command == "newmap")
{
if (parsed.length() == 1)
{
vd.set_disallowed_chars("", false, "This character is not allowed.");
string name=vd.input_box("","Enter the name of this map.");
string name2=vd.input_box("","Enter the author of this map.");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("","Enter the minimum length of this map.");
string mx2=vd.input_box("","Enter the maximum length of this map.");
string my=vd.input_box("","Enter the minimum height of this map.");
string my2=vd.input_box("","Enter the maximum height of this map.");
if(mapname=="" and mapowner=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
string mapowner=name2;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
string[] platform=find_directories("sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
game(true);
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
if(file_exists("data/maps/"+mapname+".map"))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
game(true);
}
else
{
create_map(mapname, mapowner, minx, maxx, miny, maxy, tiletype);
load_map(mapname, mapowner);
}
}
else
{
speak("Invalid command syntax. Usage: /newmap.");
game(true);
}
}
else if (base_command == "relmap")
{
if (parsed.length() == 1)
{
load_map(mapname, mapowner);
speak("map reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relmap.");
game(true);
}
}
else if (base_command == "relchar")
{
if (parsed.length() == 1)
{
bonehealth=0;
broken_bones.delete_all();
clear_inv();
destroy_all_charas();
charparse();
speak("character reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relchar.");
game(true);
}
}
else if (base_command == "gozone")
{
if (parsed.length() == 1)
{
if (zones.length() == 0)
{
speak("There are no zones available on this map.");
game(true);
}
pause_pools();
setupmenu();
for (uint i = 0; i < zones.length(); i++)
{
double width = zones[i].maxx - zones[i].minx + 1;
double height = zones[i].maxy - zones[i].miny + 1;
string zone_desc = zones[i].text + ", " +int(width) + " x " + int(height) + " zone, at " +int(zones[i].minx) + ", " + int(zones[i].miny);
m.add_item_tts(zone_desc, zones[i].text);
}
int mres=m.run("Choose the zone you'd like to go to. There are "+zones.length()+" zones available on this map.", true);
if(mres==0)
{
resume_pools();
speak("canceled");
game(true);
}
if (mres==0 and mres>=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
if (mres>0 and mres<=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
}
else
{
speak("Invalid command syntax. Usage: /gozone.");
game(true);
}
}
else if (base_command == "maps")
{
if (parsed.length() == 1)
{
string[] maps=find_files("data/maps/*.map");
if(maps.length()==0)
{
pause_pools();
dlg_snd("Error. There are no maps available to view. Press enter to continue.");
resume_pools();
game(true);
}
else
{
pause_pools();
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".map", "", true);
mapper.open("data/maps/"+temp_map_name+".map", "rb");
string temp_map_data = mapper.read();
mapper.close();            
string temp_owner;
string[] lines = delinear(temp_map_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "contributor" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
m.add_item_tts(temp_map_name + ", created by " + temp_owner + ", Size: " + measure_file_size(file_get_size("data/maps/" + maps[i])));
}
int mres=m.run("Maps menu", true);
if(mres==0)
{
resume_pools();
speak("canceled");
game(true);
}
if (mres==0 and mres>=maps.length())
{
resume_pools();
speak("canceled");
game(true);
}
if (mres>0 and mres<=maps.length())
{
resume_pools();
mapname=maps[mres-1];
mapname=string_replace(mapname, ".map", "", true);
me.x=0;
me.y=0;
load_map(mapname, mapowner);
}
}
}
else
{
speak("Invalid command syntax. Usage: /maps.");
game(true);
}
}
else if (base_command == "rawmap")
{
if (parsed.length() == 1)
{
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
else
{
speak("Invalid command syntax. Usage: /rawmap.");
game(true);
}
}
else if (base_command == "rawdata")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
game(true);
}
if(mres==1)
{
string clipboard_data = clipboard_read_text();
if (clipboard_data == "")
{
dlg_snd("Error. The clipboard is empty.");
resume_pools();
game(true);
}
string[] lines = string_split(clipboard_data, "\r\n", true);
bool is_valid = validate_map_data(lines);
if (!is_valid)
{
dlg_snd("Error. The clipboard data is invalid.");
resume_pools();
game(true);
}
mapper.open("data/maps/" + mapname + ".map", "wb");
mapper.write(clipboard_data);
mapper.close();
load_map(mapname, mapowner);
mpool.play_stationary("mapupdate.ogg", false);
speak("Map updated.");
}
if(mres==2)
{
resume_pools();
speak("canceled");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /rawdata.");
game(true);
}
}
else if (base_command == "delmap")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete the current map? This action can't be undone.",true);
if(mres==0)
{
speak("canceled");
game(true);
}
if(mres==1)
{
if(file_exists("data/maps/"+mapname+".map")) file_delete("data/maps/"+mapname+".map");
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
speak("map deleted");
dlgplay("mapdelete.ogg",false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
speak("canceled");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /delmap.");
game(true);
}
}
else
{
speak("Unknown command: /"+base_command);
game(true);
}
}

void create_map(string name, string owner, double mx, double mx2, double my, double my2, string tiletype)
{
mapname=name;
mapowner=owner;
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
mapper.open("data/maps/"+name+".map","wb");
mapdata=mapper.read();
mapper.write("name "+name+"\r\n"+"minx "+mx+"\r\n"+"maxx "+mx2+"\r\n"+"miny "+my+"\r\n"+"maxy "+my2+"\r\n"+"contributor "+owner+"\r\n"+"platform 0 "+mx2+" 0 "+tiletype+" 0 100");
mapper.close();
me.x=0;
me.y=0;
spawn_platform(0, mx, 0, 0, tiletype, 0, 100);
speak("map created");
}

void cam_left()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="left";
cam.x-=1;
playcam();
camtimer.restart();
}
}
void cam_right()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="right";
cam.x+=1;
playcam();
camtimer.restart();
}
}
void cam_down()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="down";
cam.y-=1;
playcam();
camtimer.restart();
}
}
void cam_up()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="up";
cam.y+=1;
playcam();
camtimer.restart();
}
}
void camstep_left()
{
if(keyrowhold==0 and cammable==true)
{
camdir="left";
cam.x-=1;
playcam();
}
}
void camstep_right()
{
if(keyrowhold==0 and cammable==true)
{
camdir="right";
cam.x+=1;
playcam();
}
}
void camstep_down()
{
if(keyrowhold==0 and cammable==true)
{
camdir="down";
cam.y-=1;
playcam();
}
}
void camstep_up()
{
if(keyrowhold==0 and cammable==true)
{
camdir="up";
cam.y+=1;
playcam();
}
}

void face_left()
{
if(facing=="left"==false and turnable==true)
{
facing="left";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="left") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x-1,me.y,me.x-1,me.y,false);
}
}
void face_right()
{
if(facing=="right"==false and turnable==true)
{
facing="right";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="right") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x+1,me.y,me.x+1,me.y,false);
}
}
void face_down()
{
if(facing=="down"==false and turnable==true)
{
facing="down";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="down") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y-1,me.x,me.y-1,false);
}
}
void face_up()
{
if(facing=="up"==false and turnable==true)
{
facing="up";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="up") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y+1,me.x,me.y+1,false);
}
}

void move_left()
{
if(facing=="left"==false and turnmode==1)
{
facing="left";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="left") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x-1,me.y,me.x-1,me.y,false);
}
else
{
if(turnmode==0) facing="left";
me.x--;
playstep();
}
}
void move_right()
{
if(facing=="right"==false and turnmode==1)
{
facing="right";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="right") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x+1,me.y,me.x+1,me.y,false);
}
else
{
if(turnmode==0) facing="right";
me.x++;
playstep();
}
}
void move_down()
{
if(facing=="down"==false and turnmode==1)
{
facing="down";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="down") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y-1,me.x,me.y-1,false);
}
else
{
if(turnmode==0) facing="down";
me.y--;
playstep();
}
}
void move_up()
{
if(facing=="up"==false and turnmode==1)
{
facing="up";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="up") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y+1,me.x,me.y+1,false);
}
else
{
if(turnmode==0) facing="up";
me.y++;
playstep();
}
}
void step_left()
{
if(facing=="left"==false and turnmode==1)
{
facing="left";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="left") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x-1,me.y,me.x-1,me.y,false);
}
else
{
if(turnmode==0) facing="left";
me.x--;
playstep();
}
}
void step_right()
{
if(facing=="right"==false and turnmode==1)
{
facing="right";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="right") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x+1,me.y,me.x+1,me.y,false);
}
else
{
if(turnmode==0) facing="right";
me.x++;
playstep();
}
}
void step_down()
{
if(facing=="down"==false and turnmode==1)
{
facing="down";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="down") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y-1,me.x,me.y-1,false);
}
else
{
if(turnmode==0) facing="down";
me.y--;
playstep();
}
}
void step_up()
{
if(facing=="up"==false and turnmode==1)
{
facing="up";
if(spokenturns==1) speak(facing);
if(charturnsound==1 and facing=="up") p.play_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),me.x,me.y+1,me.x,me.y+1,false);
}
else
{
if(turnmode==0) facing="up";
me.y++;
playstep();
}
}

void sit_down()
{
if(sittable==true and stuntimer.elapsed>=stuntime)
{
if(moveable==true and sitting==false)
{
if(charsitsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*sit*"),false);
stuntimer.restart();
playfall();
jumpable=false;
onstaircase=false;
moveable=false;
sitting=true;
stuntimer.restart();
}
}
}
void stand_up()
{
if(sittable==true and stuntimer.elapsed>=stuntime)
{
if(charstandsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*stand*"),false);
jumpable=true;
onstaircase=true;
moveable=true;
sitting=false;
stuntimer.restart();
}
else if(keyrowhold==0)
{
if(moveable==true and sitting==false)
{
if(charsitsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*sit*"),false);
stuntimer.restart();
playfall();
jumpable=false;
onstaircase=false;
moveable=false;
sitting=true;
stuntimer.restart();
}
else
{
if(charstandsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*stand*"),false);
jumpable=true;
onstaircase=true;
moveable=true;
sitting=false;
stuntimer.restart();
}
}
}

void playcam()
{
for (uint i = 0; i < hazards.length(); i++)
{
if(cam.x>=hazards[i].minx && cam.x<=hazards[i].maxx && cam.y>=hazards[i].miny && cam.y<=hazards[i].maxy)
{
if(charcamsound2==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*camerahazard*"),false,0,0,cameravolume,100,false);
if(charcamsound2==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*camerahazard*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
}
for (uint i = 0; i < safezones.length(); i++)
{
bool camera_in_zone =safezones[i].minx <= cam.x && safezones[i].maxx >= cam.x && safezones[i].miny <= cam.y && safezones[i].maxy >= cam.y;
if (camera_in_zone && !safezones[i].cam_in_zone)
{
if(mfc==true) safezones[i].safesound=safepool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false,0,0,cameravolume,100,false);
if(mfc==false) safezones[i].safesound=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
safezones[i].cam_in_zone=true;
}
else if (!camera_in_zone && safezones[i].cam_in_zone)
{
if(mfc==true) safezones[i].safesound=safepool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false,0,0,cameravolume,100,false);
if(mfc==false) safezones[i].safesound=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
safezones[i].cam_in_zone=false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=cam.x and dest_walls[i].maxx>=cam.x and dest_walls[i].miny<=cam.y and dest_walls[i].maxy>=cam.y)
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
cbounce();
return;
}
}
if (string_contains(gct(cam.x,cam.y),"wall",1)>-1)
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/walls/"+gct(cam.x,cam.y)+"/*wall*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+gct(cam.x,cam.y)+"/*wall*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
cbounce();
return;
}
if(me.x==cam.x and me.y==cam.y)
{
if(charcamsound3==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*cameraplayer*"),false,0,0,cameravolume,100,false);
if(charcamsound3==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*cameraplayer*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
if(gct(cam.x, cam.y)=="" || gct(cam.x, cam.y)=="air")
{
if(charcamsound==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*cameraair*"),false,0,0,cameravolume,100,false);
if(charcamsound==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*cameraair*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
else
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/*step*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/*step*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
}
}
void playstep()
{
string current_text;
if(is_in_blockage(current_text))
{
speak(current_text);
pbounce();
return;
}
for(uint i=0; i<healzones.length(); i++)
{
bool currently_in_zone =healzones[i].minx <= me.x && healzones[i].maxx >= me.x && healzones[i].miny <= me.y && healzones[i].maxy >= me.y;
if (currently_in_zone && !healzones[i].in_zone)
{
if(healzones[i].healmode==1) healzones[i].healsound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*heal*"),false);
if(healzones[i].healmode==0) healzones[i].takesound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*take*"),false);
healzones[i].in_zone = true;
}
else if (!currently_in_zone && healzones[i].in_zone)
{
healzones[i].in_zone = false;
}
}
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<signs.length(); i++)
{
if(signs[i].looping==false) signs[i].signsound=signpool.play_2d(find_sound("sounds/"+soundpack+"/objects/signs/"+signs[i].signtype+"/*step*"),me.x,me.y,signs[i].signx,signs[i].signy,false);
}
for(uint i=0; i<forcefields.length(); i++)
{
if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==1 && shieldstrength<=maxshieldstrength && paused==0)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
shieldstrength-=forcefields[i].damage-shielddefence;
pbounce(5);
return;
}
else if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==0 && paused==0)
{
forcefields[i].wepsound=forcepool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/*hit*"),false,0,0,painvolume,painpitch,false);
if(charhurtsound==1) painslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
health-=forcefields[i].damage-defence;
hearttime-=forcefields[i].damage-defence;
pbounce(5);
return;
}
}
for(uint i=0; i<hazards.length(); i++)
{
if(hazards[i].is_on_hazard() and lifecard>=2)
{
if(charlifesound==1) hazardpool.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*life*"),false);
lifecard-=1;
health=maxhealth;
hearttime=maxhealth;
pbounce(5);
return;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if (string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
if(jumping==0) tileslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*step*"),false,0,0,tilevolume,tilepitch);
}
void playfall()
{
for(uint i=0; i<healzones.length(); i++)
{
bool currently_in_zone =healzones[i].minx <= me.x && healzones[i].maxx >= me.x && healzones[i].miny <= me.y && healzones[i].maxy >= me.y;
if (currently_in_zone && !healzones[i].in_zone)
{
if(healzones[i].healmode==1) healzones[i].healsound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*heal*"),false);
if(healzones[i].healmode==0) healzones[i].takesound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*take*"),false);
healzones[i].in_zone = true;
}
else if (!currently_in_zone && healzones[i].in_zone)
{
healzones[i].in_zone = false;
}
}
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if(string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
tileslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*fall*"),false,0,0,tilevolume,tilepitch);
}
void playland()
{
for(uint i=0; i<healzones.length(); i++)
{
bool currently_in_zone =healzones[i].minx <= me.x && healzones[i].maxx >= me.x && healzones[i].miny <= me.y && healzones[i].maxy >= me.y;
if (currently_in_zone && !healzones[i].in_zone)
{
if(healzones[i].healmode==1) healzones[i].healsound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*heal*"),false);
if(healzones[i].healmode==0) healzones[i].takesound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*take*"),false);
healzones[i].in_zone = true;
}
else if (!currently_in_zone && healzones[i].in_zone)
{
healzones[i].in_zone = false;
}
}
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if (string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
if(charlandsound==1) p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*land*"),false);
tileslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*land*"),false,0,0,tilevolume,tilepitch);
}

void cbounce()
{
if(camdir=="right")
cam.x--;
else if(camdir=="left")
cam.x++;
else if(camdir=="up")
cam.y--;
else if(camdir=="down")
cam.y++;
}
void pbounce(int steps=1)
{
if(facing=="right")
me.x-=steps;
else if(facing=="left")
me.x+=steps;
else if(facing=="up")
me.y-=steps;
else if(facing=="down")
me.y+=steps;
}
void checkforplatforms()
{
if (gmt(me.x,me.y)!="")
{
playland();
jumping=0;
falling=false;
}
}
void checkforwalls()
{
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
ascending=false;
jumptimer.restart();
atapex=true;
}
}
if(gmt(me.x,me.y)!="" and string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
ascending=false;
jumptimer.restart();
atapex=true;
}
}
void fallcheck()
{
if(jumping==0 && falling==false && (gmt(me.x,me.y)==""||gmt(me.x,me.y)=="air") && doormove==false && psdoormove==false and me.y>miny)
{
falling=true;
if(charfallsound==1 and me.y>7 or me.y<=0) fallslot=p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*fall*"),false);
if(charfallsound2==1 and me.y>7 or me.y<=0) fallslot=p.play_stationary(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*plummet*"),false);
}
if(falling)
{
for(uint i=0; i<healzones.length(); i++)
{
bool currently_in_zone =healzones[i].minx <= me.x && healzones[i].maxx >= me.x && healzones[i].miny <= me.y && healzones[i].maxy >= me.y;
if (currently_in_zone && !healzones[i].in_zone)
{
if(healzones[i].healmode==1) healzones[i].healsound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*heal*"),false);
if(healzones[i].healmode==0) healzones[i].takesound=healpool.play_stationary(find_sound("sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*take*"),false);
healzones[i].in_zone = true;
}
else if (!currently_in_zone && healzones[i].in_zone)
{
healzones[i].in_zone = false;
}
}
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
if(falltimer.elapsed>=falltime and me.y>miny)
{
falltimer.restart();
me.y--;
fallcounter++;
}
if(gmt(me.x, me.y)!="" && gmt(me.x, me.y)!="air")
{
if(fallcounter>=0) p.destroy_sound(fallslot);
if(shieldhitsound==1 and fallcounter>=8 and shieldon==1) shieldslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch);
if(charhurtsound==1 and fallcounter>=8 and shieldon==0) painslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/characters/"+chartype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
if(fallcounter<=7) playland();
else if(fallcounter>7)
{
playfall();
int shield_damage = fallcounter * fallmod - shielddefence;
if(fallcounter>=8 and shieldon==1)
{
shieldstrength-=shield_damage;
stun_target("me", "", 10 * fallcounter);
if(shieldstrength<=0)
{
health -= shield_damage;
hearttime -= shield_damage;
int ct = clamp((fallcounter - 8) * 10, 0, 100);
int count = clamp((fallcounter - 8) / 2, 1, 5);
break_charbones(ct, shield_damage, 10 * fallcounter, count);
}
}
int health_damage= fallcounter * fallmod - defence;
if(fallcounter>=8 and shieldon==0)
{
health -= health_damage;
hearttime-=health_damage;
int ct = clamp((fallcounter - 8) * 10, 0, 100);
int count = clamp((fallcounter - 8) / 2, 1, 5);
break_charbones(ct, health_damage, 10 * fallcounter, count);
}
}
falling=false;
fallcounter=0;
for(uint i=0; i<checkpoints.length(); i++)
{
if(me.x==checkpoints[i].checkx and me.y==checkpoints[i].checky)
{
checkpoints[i].getsound=checkpool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/checkpoints/"+checkpoints[i].checktype+"/*get*"),false,0,0,itemvolume,itempitch,false);
@last_checkpoint=checkpoints[i];
checkpoints.remove_at(i);
return;
}
}
}
}
}
