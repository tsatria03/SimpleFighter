void clearmap()
{
destroy_all_blockages();
destroy_all_musicambs();
destroy_all_musicsources();
destroy_all_platforms();
destroy_all_ambsources();
destroy_all_soundsources();
destroy_all_reverb_effects();
destroy_all_spawnpoints();
destroy_all_staircases();
destroy_all_dest_walls();
destroy_all_walls();
destroy_all_safezones();
destroy_all_zones();
}
void destroymap()
{
destroy_all_animals();
destroy_all_animalzones();
destroy_all_belts();
destroy_all_bombs();
destroy_all_bombzones();
destroy_all_bosses();
destroy_all_bullets();
destroy_all_calanders();
destroy_all_checkpoints();
destroy_all_clocks();
destroy_all_dialogs();
destroy_all_doors();
destroy_all_enemies();
destroy_all_enemiezones();
destroy_all_floorbreakers();
destroy_all_forcefields();
destroy_all_hazards();
destroy_all_healzones();
destroy_all_helpers();
destroy_all_lifts();
destroy_all_mines();
destroy_all_menuzones();
destroy_all_moving_hazards();
destroy_all_moving_platforms();
destroy_all_objs();
destroy_all_objzones();
destroy_all_psdoors();
destroy_all_pspassages();
destroy_all_passages();
destroy_all_projectiles();
destroy_all_projzones();
destroy_all_robots();
destroy_all_robotzones();
destroy_all_signs();
destroy_all_spikes();
destroy_all_teleporters();
destroy_all_text_squares();
destroy_all_timebombs();
destroy_all_timedmusics();
destroy_all_timedsources();
destroy_all_timedtexts();
destroy_all_travelpoints();
destroy_all_turrets();
destroy_all_vanishing_platforms();
destroy_all_vehicles();
destroy_all_zombies();
destroy_all_zombiezones();
}

void gop(int x, int y)
{
if(x<minx or x>maxx or y<miny or y>maxy)
{
dlg_snd("Error! You can't move out of map boundries! Please try again! Press enter to continue.");
}
else
{
me.x=x;
me.y=y;
fallcounter=0;
jumping=0;
falling=false;
if(fallcounter>=0) p.destroy_sound(fallslot);
speak("Moved to "+me.x+", "+me.y+".");
}
}
void speakcoordinates()
{
if(locspeech==1 and gmt(me.x,me.y)=="")
{
speak("in the air,"+"facing;"+facing);
}
else if(locspeech==1)
{
speak("on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
if(locspeech==2 )
{
speak(me.x+",;"+me.y+",;"+"facing;"+facing);
}
if(locspeech==3 and gmt(me.x,me.y)=="")
{
speak(me.x+",;"+me.y+";"+"in the air,"+"facing;"+facing);
}
else if(locspeech==3)
{
speak(me.x+",;"+me.y+";"+"on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
if(locspeech==4 and gmt(me.x,me.y)=="")
{
speak("current location,"+me.x+",;"+me.y+","+"you're currently in the air,"+"facing;"+facing);
}
else if(locspeech==4)
{
speak("current location,"+me.x+",;"+me.y+","+"you're walking on;"+gmt(me.x,me.y)+","+"facing;"+facing);
}
}

void load_map(string name, bool instent_update=true, bool speak_percentage=false, int loadtime=50, int loadbeeps=1, int loadsounds=1)
{
mapname=name;
clearmap();
destroymap();
if(string_ends_with(mapname,".map"))
{
mapname=string_replace(mapname,".map","",true);
}
if(!file_exists("data/maps/"+mapname+".map"))
{
dlg_snd("Error. This map is invalid. Please check the map name in the file and try again. Press enter to continue.");
mainmenu();
}
mapper.open("data/maps/"+mapname+".map","rb");
mapdata=mapper.read();
mapper.close();
sound mapload;
timer maploadtimer;
speak("loading map");
if(loadsounds==1) mpool.play_stationary("maploadstart.ogg",false);
if(loadsounds==1) mapload.load("maploading.ogg");
if(loadsounds==1) mapload.play_looped();
string[] lines=delinear(mapdata);
double percent=0;
double last_beep_percent=-1;
for (uint i=0; i<lines.length(); i++)
{
if(loadbeeps == 1)
{
double l=lines.length(), ind=i;
int current_percent=int(ind/l*100);
if(current_percent>last_beep_percent && maploadtimer.elapsed>=loadtime)
{
if(speak_percentage==true) speak(current_percent+" percent");
beep_percentage(current_percent);
last_beep_percent=current_percent;
maploadtimer.restart();
}
}        
if(!instent_update)
{
wait(5);
}
string[] sd=string_split(lines[i], " ", true);
if(sd[0]=="name" && sd.length()==2)
{
mapname=sd[1];
}
else if(sd[0]=="minx" && sd.length()==2)
{
minx=stn(sd[1]);
}
else if(sd[0]=="maxx" && sd.length()==2)
{
maxx=stn(sd[1]);
}
else if(sd[0]=="miny" && sd.length()==2)
{
miny=stn(sd[1]);
}
else if(sd[0]=="maxy" && sd.length()==2)
{
maxy=stn(sd[1]);
}
else if(sd[0]=="platform" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
spawn_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch);
}
else if(sd[0]=="staircase" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string tiletype=sd[5];
double stairsvol=stn(sd[6]);
double stairspitch=stn(sd[7]);
spawn_staircase(mx, mx2, my, my2, tiletype, stairsvol, stairspitch);
}
else if(sd[0]=="vanishing_platform" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
string vplattype=sd[7];
double vplatvol=stn(sd[8]);
double vplatpitch=stn(sd[9]);
int sp=stn(sd[10]);
spawn_vanishing_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch, vplattype, vplatvol, vplatpitch, sp);
}
else if(sd[0]=="dest_wall" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
string dest_walltype=sd[6];
double wallvol=stn(sd[7]);
double wallpitch=stn(sd[8]);
spawn_dest_wall(mx, mx2, my, my2, hp, hp, dest_walltype, wallvol, wallpitch);
}
else if(sd[0]=="wall" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string walltype=sd[5];
double wallvol=stn(sd[6]);
double wallpitch=stn(sd[7]);
spawn_wall(mx, mx2, my, my2, walltype, wallvol, wallpitch);
}
else if(sd[0]=="blockage" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_blockage(mx, mx2, my, my2, txt);
}
else if(sd[0]=="door" && sd.length()==14)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string lotype=sd[7];
string motype=sd[8];
string optype=sd[9];
string cotype=sd[10];
string dotype=sd[11];
bool amt=string_to_bool(sd[12]);
bool dbl=string_to_bool(sd[13]);
spawn_door(sx, sy, sx2, sy2, hp, hp, sp, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="psdoor" && sd.length()==15)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string drpass=sd[7];
string lotype=sd[8];
string motype=sd[9];
string optype=sd[10];
string cotype=sd[11];
string dotype=sd[12];
bool amt=string_to_bool(sd[13]);
bool dbl=string_to_bool(sd[14]);
spawn_psdoor(sx, sy, sx2, sy2, hp, hp, sp, drpass, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="passage" && sd.length()==11)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
int sp2=stn(sd[10]);
spawn_passage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, sp2);
}
else if(sd[0]=="pspassage" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
int sp=stn(sd[5]);
string tiletype=sd[6];
string lotype=sd[7];
string optype=sd[8];
string cotype=sd[9];
string pspass=sd[10];
int sp2=stn(sd[11]);
spawn_pspassage(sx, sy, dir, lt, sp, tiletype, lotype, optype, cotype, pspass, sp2);
}
else if(sd[0]=="menu_zone" && sd.length()==5)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
create_menuzone(mx, mx2, my, my2);
}
else if(sd[0]=="safe_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string safetype=sd[5];
spawn_safezone(mx, mx2, my, my2, safetype);
}
else if(sd[0]=="zone" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_zone(mx, mx2, my, my2, txt);
}
else if(sd[0]=="reverb" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string id=sd[5];
float dry=stn(sd[6]);
float wet=stn(sd[7]);
float size=stn(sd[8]);
float damp=stn(sd[9]);
float width=stn(sd[10]);
spawn_reverb_effect(mx, mx2, my, my2, id, dry, wet, size, damp, width);
}
else if(sd[0]=="text_square" && sd.length()>=4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length());
spawn_text_square(x, y, txt);
}
else if(sd[0]=="clock" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string clocktype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_clock(x, y, txt, clocktype, dbl);
}
else if(sd[0]=="calander" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string calandertype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_calander(x, y, txt, calandertype, dbl);
}
else if(sd[0]=="music_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musicvol=stn(sd[6]);
double musicpitch=stn(sd[7]);
spawn_musicamb(mx, mx2, my, my2, musictype, musicvol, musicpitch);
}
else if(sd[0]=="music_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
spawn_musicsource(mx, mx2, my, my2, musictype, musvol, muspitch);
}
else if(sd[0]=="sound_ambience" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_ambsource(mx, mx2, my, my2, sorcetype, soundvol, soundpitch);
}
else if(sd[0]=="sound_source" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
spawn_soundsource(mx, mx2, my, my2, sourcetype, soundvol, soundpitch);
}
else if(sd[0]=="timebomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string timbotype=sd[5];
spawn_timebomb(x, y, dmg, sp, timbotype);
}
else if(sd[0]=="timed_music" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string musictype=sd[5];
double musvol=stn(sd[6]);
double muspitch=stn(sd[7]);
int musictime=stn(sd[8]);
spawn_timedmusic(mx, mx2, my, my2, musvol, muspitch, musictime, musictype);
}
else if(sd[0]=="timed_source" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sourcetype=sd[5];
double soundvol=stn(sd[6]);
double soundpitch=stn(sd[7]);
int sourcetime=stn(sd[8]);
spawn_timedsource(mx, mx2, my, my2, soundvol, soundpitch, sourcetime, sourcetype);
}
else if(sd[0]=="timed_text" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int texttime=stn(sd[5]);
string txt=join_string_array(sd, 6, sd.length());
spawn_timedtext(mx, mx2, my, my2, texttime, txt);
}
else if(sd[0]=="heal_zone" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int hm=stn(sd[5]);
int hp=stn(sd[6]);
int ht=stn(sd[7]);
string hlt=sd[8];
spawn_healzone(mx, mx2, my, my2, hm, hp, ht,hlt);
}
else if(sd[0]=="hazard" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string hazardtype=sd[5];
bool lgp=string_to_bool(sd[6]);
spawn_hazard(mx, mx2, my, my2, hazardtype, lgp);
}
else if(sd[0]=="lift" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
double tilevol=stn(sd[8]);
double tilepitch=stn(sd[9]);
string lifttype=sd[10];
double liftvol=stn(sd[11]);
double liftpitch=stn(sd[12]);
spawn_lift(mx, mx2, my, my2, dir, sp, tiletype, tilevol, tilepitch, lifttype, liftvol, liftpitch);
}
else if(sd[0]=="mine" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
string minetype=sd[4];
bool tg=string_to_bool(sd[5]);
spawn_mine(x, y, dmg, minetype, tg);
}
else if(sd[0]=="mhazard" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
double sy=stn(sd[6]);
int dir=stn(sd[7]);
int dir2=stn(sd[8]);
int sp=stn(sd[9]);
string hazardtype=sd[10];
spawn_moving_hazard(mx, mx2, my, my2, sx, sy, dir, dir2, sp, hazardtype);
}
else if(sd[0]=="mplatform" && sd.length()==16)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
int dir=stn(sd[6]);
int dir2=stn(sd[7]);
int sp=stn(sd[8]);
string tiletype=sd[9];
double tilevol=stn(sd[10]);
double tilepitch=stn(sd[11]);
string mplattype=sd[12];
double mplatvol=stn(sd[13]);
double mplatpitch=stn(sd[14]);
int vs=stn(sd[15]);
spawn_moving_platform(mx, mx2, my, my2, sx, dir, dir2, sp, tiletype, tilevol, tilepitch, mplattype, mplatvol, mplatpitch, vs);
}
else if(sd[0]=="sign" && sd.length()>=7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-3);
string signtype=sd[sd.length()-3];
bool dbl=string_to_bool(sd[sd.length()-2]);
bool lps=string_to_bool(sd[sd.length()-1]);
spawn_sign(x, y, txt, signtype, dbl, lps);
}
else if(sd[0]=="checkpoint" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int checktime=stn(sd[3]);
string checktype=sd[4];
spawn_checkpoint(x, y, checktime, checktype);
}
else if(sd[0]=="dialog" && sd.length()>=8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length()-2);
string dlgtype=sd[sd.length()-2];
dlgtyp=dlgtype;
bool dlm=string_to_bool(sd[sd.length()-1]);
spawn_dialog(mx, mx2, my, my2, txt, dlgtype, dlm);
}
else if(sd[0]=="item" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int objtime=stn(sd[3]);
string objtype=sd[4];
string objtype2=sd[5];
bool automatic=string_to_bool(sd[6]);
spawn_obj(x, y, objtime, objtype, objtype2, automatic);
}
else if(sd[0]=="item_zone" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int sp=stn(sd[5]);
string objtype=sd[6];
string objtype2=sd[7];
spawn_objzone(mx, mx2, my, my2, sp, objtype, objtype2);
}
else if(sd[0]=="spike" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
string spiketype=sd[8];
bool dbl=string_to_bool(sd[9]);
spawn_spike(mx, mx2, my, my2, hp, hp, dmg, sp, spiketype, dbl);
}
else if(sd[0]=="spawnpoint" && sd.length()==3)
{
int spx=stn(sd[1]);
int spy=stn(sd[2]);
create_spawnpoint(spx, spy);
}
else if(sd[0]=="travelpoint" && sd.length()>=9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string destmap=sd[5];
int destx=stn(sd[6]);
int desty=stn(sd[7]);
string endtext=sd[8];
spawn_travelpoint(mx, mx2, my, my2, destmap, destx, desty, endtext);
}
else if(sd[0]=="animal" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int anirange=stn(sd[3]);
int anirange2=stn(sd[4]);
int anirange3=stn(sd[5]);
int anirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string amtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_animal(x, y, anirange, anirange2, anirange3, anirange4, hp, hp, card, dmg, ft, sp, lv, xp, amtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="enemie" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int enerange=stn(sd[3]);
int enerange2=stn(sd[4]);
int enerange3=stn(sd[5]);
int enerange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string emtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_enemie(x, y, enerange, enerange2, enerange3, enerange4, hp, hp, card, dmg, ft, sp, lv, xp, emtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="floor_breaker" && sd.length()==4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string floorbtype=sd[3];
spawn_floorbreaker(x, y, floorbtype);
}
else if(sd[0]=="forcefield" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dmg=stn(sd[5]);
int sp=stn(sd[6]);
string forcetype=sd[7];
spawn_forcefield(mx, mx2, my, my2, dmg, sp, forcetype);
}
else if(sd[0]=="helper" && sd.length()==11)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
double xp=stn(sd[9]);
string helptyp=sd[10];
spawn_helper(x, y, hp, hp, card, dmg, ft, sp, lv, xp, helptyp);
}
else if(sd[0]=="projectile" && sd.length()==13)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dir=stn(sd[3]);
double hp=stn(sd[4]);
int card=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
double xp=stn(sd[9]);
string potype=sd[10];
bool fb=string_to_bool(sd[11]);
bool mb=string_to_bool(sd[12]);
spawn_projectile(x, y, dir, hp, hp, card, dmg, sp, lv, xp, potype, fb, mb);
}
else if(sd[0]=="robot" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int roborange=stn(sd[3]);
int roborange2=stn(sd[4]);
int roborange3=stn(sd[5]);
int roborange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string rotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_robot(x, y, roborange, roborange2, roborange3, roborange4, hp, hp, card, dmg, ft, sp, lv, xp, rotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="turret" && sd.length()==17)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int lt=stn(sd[7]);
int sp=stn(sd[8]);
double lv=stn(sd[9]);
double xp=stn(sd[10]);
string tutype=sd[11];
string tutype2=sd[12];
string tutype3=sd[13];
bool fb=string_to_bool(sd[14]);
bool mb=string_to_bool(sd[15]);
bool mb2=string_to_bool(sd[16]);
spawn_turret(x, y, hp, hp, card, dmg, ft, lt, sp, lv, xp, tutype, tutype2, tutype3, fb, mb, mb2);
}
else if(sd[0]=="zombie" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int zombirange=stn(sd[3]);
int zombirange2=stn(sd[4]);
int zombirange3=stn(sd[5]);
int zombirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string zotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_zombie(x, y, zombirange, zombirange2, zombirange3, zombirange4, hp, hp, card, dmg, ft, sp, lv, xp, zotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="animal_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string amtype=sd[5];
spawn_animalzone(mx, mx2, y, sp, amtype);
}
else if(sd[0]=="bomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bomb(x, y, dmg, sp, botype);
}
else if(sd[0]=="bomb_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bombzone(mx, mx2, y, sp, botype);
}
else if(sd[0]=="boss" && sd.length()==27)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int boserange=stn(sd[3]);
int boserange2=stn(sd[4]);
int boserange3=stn(sd[5]);
int boserange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int lt=stn(sd[11]);
int sp=stn(sd[12]);
int tt=stn(sd[13]);
int ht=stn(sd[14]);
double lv=stn(sd[15]);
double xp=stn(sd[16]);
string bosstyp=sd[17];
string bosstyp2=sd[18];
string bosstyp3=sd[19];
bool fb=string_to_bool(sd[20]);
bool mb=string_to_bool(sd[21]);
bool mb2=string_to_bool(sd[22]);
bool tb=string_to_bool(sd[23]);
bool tb2=string_to_bool(sd[24]);
bool hb=string_to_bool(sd[25]);
bool dpm=string_to_bool(sd[26]);
spawn_boss(x, y, boserange, boserange2, boserange3, boserange4, hp, hp, card, dmg, ft, lt, sp, tt, ht, lv, xp, bosstyp, bosstyp2, bosstyp3, fb, mb, mb2, tb, tb2, hb, dpm);
}
else if(sd[0]=="belt" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
string belttyp=sd[8];
spawn_belt(mx, mx2, my, my2, dir, sp, tiletype, belttyp);
}
else if(sd[0]=="enemie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string emtype=sd[5];
spawn_enemiezone(mx, mx2, y, sp, emtype);
}
else if(sd[0]=="projectile_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string potype=sd[5];
spawn_projzone(mx, mx2, y, sp, potype);
}
else if(sd[0]=="robot_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string rotype=sd[5];
spawn_robotzone(mx, mx2, y, sp, rotype);
}
else if(sd[0]=="teleporter" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
int telrange=stn(sd[5]);
int telrange2=stn(sd[6]);
int sp=stn(sd[7]);
string teltype=sd[8];
bool mb=string_to_bool(sd[9]);
bool mb2=string_to_bool(sd[10]);
bool ss=string_to_bool(sd[11]);
spawn_teleporter(sx, sy, sx2, sy2, telrange, telrange2, sp, teltype, mb, mb2, ss);
}
else if(sd[0]=="vehicle" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int dmg=stn(sd[4]);
string vehtyp=sd[5];
bool fb=string_to_bool(sd[6]);
spawn_vehicle(x, y, hp, hp, dmg, vehtyp, fb);
}
else if(sd[0]=="zombie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string zotype=sd[5];
spawn_zombiezone(mx, mx2, y, sp, zotype);
}
if(last_spawnpoint!is null)
{
me.x=last_spawnpoint.spawnx;
me.y=last_spawnpoint.spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else if(spawnpoints.length()>0)
{
me.x=spawnpoints[0].spawnx;
me.y=spawnpoints[0].spawny;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
else
{
me.x=me.x;
me.y=me.y;
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
sittable=true;
sitting=false;
turnable=true;
telable=true;
}
}
if(loadsounds==1) mapload.stop();
if(loadsounds==1) mpool.play_stationary("maploadstop.ogg",false);
if(loadbeeps == 1 && last_beep_percent<100)
{
if(speak_percentage==true) speak("100 "+"percent");
beep_percentage(100);
speak("map loded.");
}
}
void comparse()
{
string cmd=virtual_input_box("","Enter the command you'd like to use.");
if(cmd=="")
return;
string[] sd=string_split(cmd, "/", true);
if(sd.length()<2)
{
speak("Invalid command syntax. Make sure to include '/' followed by a command.");
game(true);
}
string command = sd[1];
string[] parsed = string_split(command, " ", true);
if (parsed.length() < 1)
{
speak("No command entered after '/'.");
game(true);
}
string base_command = parsed[0];
if (base_command == "go")
{
if (parsed.length() == 3)
{
int x = stn(parsed[1]);
int y = stn(parsed[2]);
gop(x, y);
}
else
{
speak("Invalid command syntax. Usage: /go x y.");
game(true);
}
}
else if (base_command == "help")
{
if (parsed.length() == 1)
{
if(coms.open("docks/help.txt", "rb"))
{
comsplit=coms.read();
coms.close();
string com=string_replace(comsplit, "\r\n", "\n", true);
virtual_info_box("command help", "commands", com);
}
else
{
speak("Failed to open docks/help.txt.");
}
}
else
{
speak("Invalid command syntax. Usage: /help.");
game(true);
}
}
else if (base_command == "menu")
{
if (parsed.length() == 1)
{
pause_pools();
mapmenu2();
}
else
{
speak("Invalid command syntax. Usage: /menu.");
game(true);
}
}
else if (base_command == "preffs")
{
if (parsed.length() == 1)
{
pause_pools();
settingsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /preffs.");
game(true);
}
}
else if (base_command == "stats")
{
if (parsed.length() == 1)
{
pause_pools();
statsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /stats.");
game(true);
}
}
else if (base_command == "changemap")
{
if (parsed.length() == 4)
{
string name=parsed[1];
int x = stn(parsed[2]);
int y = stn(parsed[3]);
if (file_exists("data/maps/" + name + ".map"))
{
if (x >= minx && x <= maxx && y >= miny && y <= maxy)
{
load_map(name);
}
}
else
{
speak("Map '" + name + "' not found. Please check the name and try again.");
game(true);
}
if(x >= minx && x <= maxx && y >= miny && y <= maxy)
{
gop(x, y);
}
else
{
speak("Invalid coordinates. Please make sure x and y are within the map boundaries.");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /changemap mapname x y.");
game(true);
}
}
else if (base_command == "newmap")
{
if (parsed.length() == 1)
{
string name=virtual_input_box("","Enter the name of this map.");
string mx=virtual_input_box("","Enter the minimum length of this map.");
string mx2=virtual_input_box("","Enter the maximum length of this map.");
string my=virtual_input_box("","Enter the minimum height of this map.");
string my2=virtual_input_box("","Enter the maximum height of this map.");
if(mapname=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
string[] platform=find_directories("data/sounds/"+soundpack+"/objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
game(true);
}
else
{
string res=platsmenu();
if(res!="")
{
tiletype=res;
}
}
if(file_exists("data/maps/"+mapname+".map"))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
game(true);
}
else
{
create_map(mapname, minx, maxx, miny, maxy, tiletype);
load_map(mapname);
}
}
else
{
speak("Invalid command syntax. Usage: /newmap.");
game(true);
}
}
else if (base_command == "relmap")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload the current map?",true);
if(mres==0)
{
speak("canceled");
game(true);
}
if(mres==1)
{
load_map(mapname);
speak("map reloaded");
}
if(mres==2)
{
speak("canceled");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /relmap.");
game(true);
}
}
else if (base_command == "gozone")
{
if (parsed.length() == 1)
{
if (zones.length() == 0)
{
speak("There are no zones available on this map.");
game(true);
}
pause_pools();
setupmenu();
for (uint i = 0; i < zones.length(); i++)
{
double width = zones[i].maxx - zones[i].minx + 1;
double height = zones[i].maxy - zones[i].miny + 1;
string zone_desc = zones[i].text + ", " +int(width) + " x " + int(height) + " zone, at " +int(zones[i].minx) + ", " + int(zones[i].miny);
m.add_item_tts(zone_desc, zones[i].text);
}
int mres=m.run("Choose the zone you'd like to go to. There are "+zones.length()+" zones available on this map.", true);
if(mres==0)
{
resume_pools();
speak("canceled");
game(true);
}
if (mres==0 and mres>=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop(int(target_x), int(target_y));
}
if (mres>0 and mres<=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop(int(target_x), int(target_y));
}
}
else
{
speak("Invalid command syntax. Usage: /gozone.");
game(true);
}
}
else if (base_command == "maps")
{
if (parsed.length() == 1)
{
string[] maps=find_files("data/maps/*.map");
if(maps.length()==0)
{
pause_pools();
dlg_snd("Error. There are no maps available to view. Press enter to continue.");
resume_pools();
game(true);
}
else
{
pause_pools();
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
m.add_item_tts(string_replace(maps[i],".map","",true)+", size: "+measure_file_size(file_get_size("data/maps/"+maps[i])));
}
int mres=m.run("Maps menu", true);
if(mres==0)
{
resume_pools();
speak("canceled");
game(true);
}
if (mres==0 and mres>=maps.length())
{
resume_pools();
speak("canceled");
game(true);
}
if (mres>0 and mres<=maps.length())
{
resume_pools();
mapname=maps[mres-1];
mapname=string_replace(mapname, ".map", "", true);
me.x=0;
me.y=0;
load_map(mapname);
}
}
}
else
{
speak("Invalid command syntax. Usage: /maps.");
game(true);
}
}
else if (base_command == "rawmap")
{
if (parsed.length() == 1)
{
mapper.open("data/maps/" + mapname + ".map", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
else
{
speak("Invalid command syntax. Usage: /rawmap.");
game(true);
}
}
else if (base_command == "rawdata")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
speak("canceled");
game(true);
}
if(mres==1)
{
mapper.open("data/maps/" + mapname + ".map", "wb");
mapdata=mapper.read();
mapdata=clipboard_read_text();
if(mapdata=="")
{
dlg_snd("Error. The map data you've pasted is invalid.");
game(true);
}
else if(mapdata!="name "+mapname+"\r\n"+"maxx "+maxx+"\r\n"+"maxy "+maxy+"\r\n"+"platform 0 "+maxx+" 0 "+tiletype+" 0 100")
{
dlg_snd("Error. The map data you've pasted is invalid.");
game(true);
}
else
{
mapper.write(mapdata);
mapper.close();
load_map(mapname);
mpool.play_stationary("mapupdate.ogg",false);
speak("Map updated.");
}
}
if(mres==2)
{
speak("canceled");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /rawdata.");
game(true);
}
}
else if (base_command == "delmap")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound="menu1.ogg";
m.enter_sound="menu2.ogg";
m.open_sound="menu3.ogg";
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete the current map? This action can't be undone.",true);
if(mres==0)
{
speak("canceled");
game(true);
}
if(mres==1)
{
if(file_exists("data/maps/"+mapname+".map")) file_delete("data/maps/"+mapname+".map");
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
speak("map deleted");
dlgplay("mapdelete.ogg",false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
speak("canceled");
game(true);
}
}
else
{
speak("Invalid command syntax. Usage: /delmap.");
game(true);
}
}
else
{
speak("Unknown command: /"+base_command);
game(true);
}
}

void create_map(string name, double mx, double mx2, double my, double my2, string tiletype)
{
mapname=name;
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
mapper.open("data/maps/"+name+".map","wb");
mapdata=mapper.read();
mapper.write("name "+mapname+"\r\n"+"minx "+mx+"\r\n"+"maxx "+mx2+"\r\n"+"miny "+my+"\r\n"+"maxy "+my2+"\r\n"+"platform 0 "+mx2+" 0 "+tiletype+" 0 100");
mapper.close();
me.x=0;
me.y=0;
spawn_platform(0, mx, 0, 0, tiletype, 0, 100);
speak("map created");
}

void cam_left()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="left";
cam.x-=1;
playcam();
camtimer.restart();
}
}
void cam_right()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="right";
cam.x+=1;
playcam();
camtimer.restart();
}
}
void cam_down()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="down";
cam.y-=1;
playcam();
camtimer.restart();
}
}
void cam_up()
{
if(keyrowhold==1 and camtimer.elapsed>=camtime and cammable==true)
{
camdir="up";
cam.y+=1;
playcam();
camtimer.restart();
}
}
void camstep_left()
{
if(keyrowhold==0 and cammable==true)
{
camdir="left";
cam.x-=1;
playcam();
}
}
void camstep_right()
{
if(keyrowhold==0 and cammable==true)
{
camdir="right";
cam.x+=1;
playcam();
}
}
void camstep_down()
{
if(keyrowhold==0 and cammable==true)
{
camdir="down";
cam.y-=1;
playcam();
}
}
void camstep_up()
{
if(keyrowhold==0 and cammable==true)
{
camdir="up";
cam.y+=1;
playcam();
}
}

void move_left()
{
if(facing=="left"==false)
{
facing="left";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.x--;
playstep();
}
}
void move_right()
{
if(facing=="right"==false)
{
facing="right";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.x++;
playstep();
}
}
void move_down()
{
if(facing=="down"==false)
{
facing="down";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.y--;
playstep();
}
}
void move_up()
{
if(facing=="up"==false)
{
facing="up";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.y++;
playstep();
}
}
void step_left()
{
if(facing=="left"==false)
{
facing="left";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.x--;
playstep();
}
}
void step_right()
{
if(facing=="right"==false)
{
facing="right";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.x++;
playstep();
}
}
void step_down()
{
if(facing=="down"==false)
{
facing="down";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.y--;
playstep();
}
}
void step_up()
{
if(facing=="up"==false)
{
facing="up";
if(spokenturns==1) speak(facing);
if(charturnsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*turn*"),false);
}
else
{
me.y++;
playstep();
}
}

void sit_down()
{
if(sittable==true and stuntimer.elapsed>=stuntime)
{
if(moveable==true and sitting==false)
{
if(charsitsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*sit*"),false);
stuntimer.restart();
playfall();
jumpable=false;
onstaircase=false;
moveable=false;
sitting=true;
stuntimer.restart();
}
}
}
void stand_up()
{
if(sittable==true and stuntimer.elapsed>=stuntime)
{
if(charstandsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*stand*"),false);
jumpable=true;
onstaircase=true;
moveable=true;
sitting=false;
stuntimer.restart();
}
else if(keyrowhold==0)
{
if(moveable==true and sitting==false)
{
if(charsitsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*sit*"),false);
stuntimer.restart();
playfall();
jumpable=false;
onstaircase=false;
moveable=false;
sitting=true;
stuntimer.restart();
}
else
{
if(charstandsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*stand*"),false);
jumpable=true;
onstaircase=true;
moveable=true;
sitting=false;
stuntimer.restart();
}
}
}

void playcam()
{
for (uint i = 0; i < hazards.length(); i++)
{
if(cam.x>=hazards[i].minx && cam.x<=hazards[i].maxx && cam.y>=hazards[i].miny && cam.y<=hazards[i].maxy)
{
if(charcamsound2==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*camerahazard*"),false,0,0,cameravolume,100,false);
if(charcamsound2==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*camerahazard*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
}
for (uint i = 0; i < safezones.length(); i++)
{
bool camera_in_zone =safezones[i].minx <= cam.x && safezones[i].maxx >= cam.x && safezones[i].miny <= cam.y && safezones[i].maxy >= cam.y;
if (camera_in_zone && !safezones[i].cam_in_zone)
{
if(mfc==true) safezones[i].safesound=safepool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false,0,0,cameravolume,100,false);
if(mfc==false) safezones[i].safesound=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
safezones[i].cam_in_zone=true;
}
else if (!camera_in_zone && safezones[i].cam_in_zone)
{
if(mfc==true) safezones[i].safesound=safepool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false,0,0,cameravolume,100,false);
if(mfc==false) safezones[i].safesound=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
safezones[i].cam_in_zone=false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=cam.x and dest_walls[i].maxx>=cam.x and dest_walls[i].miny<=cam.y and dest_walls[i].maxy>=cam.y)
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
cbounce();
return;
}
}
if (string_contains(gct(cam.x,cam.y),"wall",1)>-1)
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gct(cam.x,cam.y)+"/*wall*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gct(cam.x,cam.y)+"/*wall*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
cbounce();
return;
}
if(me.x==cam.x and me.y==cam.y)
{
if(charcamsound3==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*cameraplayer*"),false,0,0,cameravolume,100,false);
if(charcamsound3==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*cameraplayer*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
if(gct(cam.x, cam.y)=="" || gct(cam.x, cam.y)=="air")
{
if(charcamsound==1 and mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*cameraair*"),false,0,0,cameravolume,100,false);
if(charcamsound==1 and mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*cameraair*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch,false);
}
else
{
if(mfc==true) camslot=campool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/*step*"),false,0,0,cameravolume,100);
if(mfc==false) camslot=campool.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/platforms/"+gct(cam.x,cam.y)+"/*step*"),me.x,me.y,cam.x,cam.y,0,0,0,0,false,0,0,cameravolume,camerapitch);
}
}
void playstep()
{
string current_text;
if(is_in_blockage(current_text))
{
speak(current_text);
pbounce();
return;
}
for(uint i=0; i<healzones.length(); i++)
{
bool currently_in_zone =healzones[i].minx <= me.x && healzones[i].maxx >= me.x && healzones[i].miny <= me.y && healzones[i].maxy >= me.y;
if (currently_in_zone && !healzones[i].in_zone)
{
if(healzones[i].healmode==1) healzones[i].healsound=healpool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*heal*"),false);
if(healzones[i].healmode==0) healzones[i].takesound=healpool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/heal zones/"+healzones[i].healtype+"/*take*"),false);
}
else if (!currently_in_zone && healzones[i].in_zone)
{
}
}
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<signs.length(); i++)
{
if(signs[i].looping==false) signs[i].signsound=signpool.play_2d(find_sound("data/sounds/"+soundpack+"/objects/signs/"+signs[i].signtype+"/*step*"),me.x,me.y,signs[i].signx,signs[i].signy,false);
}
for(uint i=0; i<forcefields.length(); i++)
{
if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==1 && shieldstrength<=maxshieldstrength && paused==0)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
shieldstrength-=forcefields[i].damage-shielddefence;
pbounce(5);
return;
}
else if(forcefields[i].forcefielded==true && forcefields[i].minx<=me.x && forcefields[i].maxx>=me.x && forcefields[i].miny<=me.y && forcefields[i].maxy>=me.y && shieldon==0 && paused==0)
{
forcefields[i].wepsound=forcepool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/force fields/"+forcefields[i].forcetype+"/*hit*"),false,0,0,painvolume,painpitch,false);
if(charhurtsound==1) painslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
health-=forcefields[i].damage-defence;
hearttime-=forcefields[i].damage-defence;
pbounce(5);
return;
}
}
for(uint i=0; i<hazards.length(); i++)
{
if(hazards[i].is_on_hazard() and lifecard>=2)
{
if(charlifesound==1) hazardpool.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*life*"),false);
lifecard-=1;
health=maxhealth;
hearttime=maxhealth;
pbounce(5);
return;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if (string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
if(jumping==0) tileslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*step*"),false,0,0,tilevolume,tilepitch);
}
void playfall()
{
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if(string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
tileslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*fall*"),false,0,0,tilevolume,tilepitch);
}
void playland()
{
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
}
if (string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
pbounce();
return;
}
if(charlandsound==1) p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*land*"),false);
tileslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/platforms/"+gmt(me.x,me.y)+"/*land*"),false,0,0,tilevolume,tilepitch);
}

void cbounce()
{
if(camdir=="right")
cam.x--;
else if(camdir=="left")
cam.x++;
else if(camdir=="up")
cam.y--;
else if(camdir=="down")
cam.y++;
}
void pbounce(int steps=1)
{
if(facing=="right")
me.x-=steps;
else if(facing=="left")
me.x+=steps;
else if(facing=="up")
me.y-=steps;
else if(facing=="down")
me.y+=steps;
}
void checkforplatforms()
{
if (gmt(me.x,me.y)!="")
{
playland();
jumping=0;
falling=false;
}
}
void checkforwalls()
{
for(uint i=0; i<dest_walls.length(); i++)
{
if(dest_walls[i].minx<=me.x and dest_walls[i].maxx>=me.x and dest_walls[i].miny<=me.y and dest_walls[i].maxy>=me.y)
{
wallvolume=dest_walls[i].volume;
wallpitch=dest_walls[i].pitch;
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+dest_walls[i].dest_wall+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
ascending=false;
jumptimer.restart();
atapex=true;
}
}
if(gmt(me.x,me.y)!="" and string_contains(gmt(me.x,me.y),"wall",1)>-1)
{
wallslot=p.play_extended_2d(find_sound("data/sounds/"+soundpack+"/objects/walls/"+gmt(me.x,me.y)+"/*wall*"),me.x,me.y,me.x,me.y,0,0,0,0,false,0,0,wallvolume,wallpitch);
ascending=false;
jumptimer.restart();
atapex=true;
}
}
void fallcheck()
{
if(jumping==0 && falling==false && (gmt(me.x,me.y)==""||gmt(me.x,me.y)=="air") && doormove==false && psdoormove==false and me.y>miny)
{
falling=true;
if(charfallsound==1 and me.y>7 or me.y<=0) fallslot=p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*fall*"),false);
if(charfallsound2==1 and me.y>7 or me.y<=0) fallslot=p.play_stationary(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*plummet*"),false);
}
if(falling)
{
for(uint i=0; i<safezones.length(); i++)
{
bool currently_in_zone =safezones[i].minx <= me.x && safezones[i].maxx >= me.x && safezones[i].miny <= me.y && safezones[i].maxy >= me.y;
if (currently_in_zone && !safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*in*"),false);
safezones[i].player_in_zone = true;
}
else if (!currently_in_zone && safezones[i].player_in_zone)
{
safezones[i].safesound=safepool.play_stationary(find_sound("data/sounds/"+soundpack+"/objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
safezones[i].player_in_zone = false;
}
}
if(falltimer.elapsed>=falltime and me.y>miny)
{
falltimer.restart();
me.y--;
fallcounter++;
}
if(gmt(me.x, me.y)!="" && gmt(me.x, me.y)!="air")
{
if(fallcounter>=0) p.destroy_sound(fallslot);
if(shieldhitsound==1 and fallcounter>=8 and shieldon==1) shieldslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch);
if(charhurtsound==1 and fallcounter>=8 and shieldon==0) painslot=p.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/characters/"+chartype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
if(fallcounter>=8) jumpable=false;
if(fallcounter>=8) moveable=false;
if(fallcounter>=8) sitting=true;
if(fallcounter<=7) playland();
else if(fallcounter>7)
{
playfall();
if(fallcounter>=8 and shieldon==1) shieldstrength-=fallcounter*21-shielddefence;
if(fallcounter>=8 and shieldon==0) health-=fallcounter*21-defence;
if(fallcounter>=8 and shieldon==0) hearttime-=fallcounter*21-defence;
}
falling=false;
fallcounter=0;
for(uint i=0; i<checkpoints.length(); i++)
{
if(me.x==checkpoints[i].checkx and me.y==checkpoints[i].checky)
{
checkpoints[i].getsound=checkpool.play_stationary_extended(find_sound("data/sounds/"+soundpack+"/objects/checkpoints/"+checkpoints[i].checktype+"/*get*"),false,0,0,itemvolume,itempitch,false);
@last_checkpoint=checkpoints[i];
checkpoints.remove_at(i);
return;
}
}
}
}
}
