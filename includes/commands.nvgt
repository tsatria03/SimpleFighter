cblocker@[]cblockers(0);
class cblocker
{
bool whitelist;
double minx, maxx, miny, maxy;
string[] commands;
cblocker(double mx,double mx2,double my,double my2,string[] coms,bool wtl)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
commands=coms;
whitelist=wtl;
}
}
bool is_command_blocked(string comname)
{
for (uint i = 0; i < cblockers.length(); i++)
{
cblocker@ cb = cblockers[i];
if (me.x >= cb.minx && me.x <= cb.maxx && me.y >= cb.miny && me.y <= cb.maxy)
{
if (cb.whitelist)
{
bool found = false;
for (uint j = 0; j < cb.commands.length(); j++)
{
if (cb.commands[j] == comname)
{
found = true;
break;
}
}
if (!found) return true;
}
else
{
for (uint j = 0; j < cb.commands.length(); j++)
{
if (cb.commands[j] == comname) return true;
}
}
}
}
return false;
}
void spawn_cblocker(double x1,double x2,double y1,double y2,string[] commands,bool wtl)
{
cblocker cblocker1(x1,x2,y1,y2,commands,wtl);
cblockers.insert_last(cblocker1);
}
void destroy_all_cblockers()
{
cblockers.resize(0);
}

void comparse(string comd="")
{
string cmd;
if (comd != "")
{
cmd = comd;
}
else
{
vd.set_disallowed_chars("", false, "This character is not allowed.");
cmd = vd.input_box("", "Enter the commands you'd like to use. Separate each command with a semicolon.");
if (cmd == "")
    return;
}
if (cmd.find(";") != -1)
{
    if (cmd.substr(0, 1) != "/")
    {
        speak("Invalid command syntax. Make sure to include '/' before the first command.");
        if (!in_commandstack) game();
        return;
    }
    comstack(cmd);
    return;
}
string[] sd=string_split(cmd, "/", true);
if(sd.length()<2)
{
speak("Invalid command syntax. Make sure to include '/' followed by a command.");
if(!in_commandstack) game();
}
string command = sd[1];
string[] parsed = string_split(command, " ", true);
if (parsed.length() < 1)
{
speak("No command entered after '/'.");
if(!in_commandstack) game();
}
string base_command = parsed[0];
if (is_command_blocked(base_command))
{
speak("This command cannot be used in this area.");
if(!in_commandstack) game();
return;
}
if (base_command == "go" && !map_is_compiled)
{
if (parsed.length() == 3)
{
double x = stn(parsed[1]);
double y = stn(parsed[2]);
gop("me", "", x, y);
}
else if (parsed.length() == 5)
{
string entity = parsed[1];
string id = parsed[2];
double x = stn(parsed[3]);
double y = stn(parsed[4]);
gop(entity, id, x, y);
}
else
{
speak("Invalid command syntax. Usage: /go x y, or /go entity id x y.");
if(!in_commandstack) game();
}
}
else if (base_command == "draw" || base_command == "dr")
{
    if (parsed.length() == 3)
    {
        string new_weapontype  = parsed[1];
        string new_weapontype2 = parsed[2];
        if (new_weapontype == "archery")
        {
        drawable = true;
        melee = false;
        p.destroy_sound(refslot);
        wepdef = 0;
        weapontype  = "archery";
        weapontype2 = new_weapontype2;
        destroy_all_weapons();
        weaponparse();
        draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
        }
else if (new_weapontype == "artillery")
        {
        drawable = true;
        melee = false;
        p.destroy_sound(refslot);
        wepdef = 0;
        weapontype  = "artillery";
        weapontype2 = new_weapontype2;
        destroy_all_weapons();
        weaponparse();
        draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
        }
else if (new_weapontype == "explosive")
        {
        drawable = true;
        melee = false;
        p.destroy_sound(refslot);
        wepdef = 0;
        weapontype  = "explosive";
        weapontype2 = new_weapontype2;
        destroy_all_weapons();
        weaponparse();
        draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
        }
else if (new_weapontype == "melee")
        {
        drawable = true;
        melee = true;
        p.destroy_sound(refslot);
        wepdef = 0;
        weapontype  = "melee";
        weapontype2 = new_weapontype2;
        destroy_all_weapons();
        weaponparse();
        draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
        }
}
    else
    {
        speak("Invalid command syntax. Usage: /draw weapontype weapontype2, or /dr weapontype weapontype2.");
        if (!in_commandstack) game();
    }
}
else if(base_command == "kn" || base_command=="kill")
{
if(parsed.length()==5)
{
string entity=parsed[1];
string id=parsed[2];
double x=stn(parsed[3]);
double y=stn(parsed[4]);
if(entity=="animal")
{
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animaltype==id && animals[i].amx==x && animals[i].amy==y)
{
animalpool.destroy_sound(animals[i].amsound);
animals[i].defsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animals[i].animaltype+"/*death*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=animals[i].amxp*animals[i].amlevel*xpmod;
kills+=1;
int falldelay = round(animalpool.get_sound_length(animals[i].defsound), 0);
spawn_bodyfall(animals[i].amx, animals[i].amy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and animals[i].dropitem==true) spawn_obj(animals[i].amx, animals[i].amy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,animals[i].amx,animals[i].amy,false);
speak("Killed the animal " + id + " at position " + x + ", " + y + ".");
animals.remove_at(i);
return;
}
}
}
else if(entity=="boss")
{
for(uint i=0; i<bosses.length(); i++)
{
if(bosses[i].bosstype==id && bosses[i].bossx==x && bosses[i].bossy==y)
{
bosspool.destroy_sound(bosses[i].bossesound);
bosses[i].defsound=bosspool.play_extended_2d(get_map_sound("npc/bosses/"+bosses[i].bosstype+"/*death*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=bosses[i].bossxp*bosses[i].bosslevel*xpmod;
kills+=1;
int falldelay = round(bosspool.get_sound_length(bosses[i].defsound), 0);
spawn_bodyfall(bosses[i].bossx, bosses[i].bossy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and bosses[i].dropitem==true) spawn_obj(bosses[i].bossx, bosses[i].bossy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,false);
speak("Killed the boss " + id + " at position " + x + ", " + y + ".");
bosses.remove_at(i);
return;
}
}
}
else if(entity=="human")
{
for(uint i=0; i<humans.length(); i++)
{
if(humans[i].humantype==id && humans[i].humx==x && humans[i].humy==y)
{
humanpool.destroy_sound(humans[i].humsound);
humans[i].defsound=humanpool.play_extended_2d(get_map_sound("npc/humans/"+humans[i].humantype+"/*death*"),me.x,me.y,humans[i].humx,humans[i].humy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=humans[i].humxp*humans[i].humlevel*xpmod;
kills+=1;
int falldelay = round(humanpool.get_sound_length(humans[i].defsound), 0);
spawn_bodyfall(humans[i].humx, humans[i].humy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and humans[i].dropitem==true) spawn_obj(humans[i].humx, humans[i].humy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,humans[i].humx,humans[i].humy,false);
speak("Killed the human " + id + " at position " + x + ", " + y + ".");
humans.remove_at(i);
return;
}
}
}
else if(entity=="helper")
{
for(uint i=0; i<helpers.length(); i++)
{
if(helpers[i].helpertype==id && helpers[i].helpx==x && helpers[i].helpy==y)
{
helperpool.destroy_sound(helpers[i].helpersound);
helpers[i].defsound=helperpool.play_extended_2d(get_map_sound("npc/helpers/"+helpers[i].helpertype+"/*death*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,0,0,0,0,false,0,0,painvolume,painpitch,false);
int falldelay = round(helperpool.get_sound_length(helpers[i].defsound), 0);
spawn_bodyfall(helpers[i].helpx, helpers[i].helpy, (falldelay <= 0 ? random(500, 1000) : falldelay));
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,false);
speak("Killed the helper " + id + " at position " + x + ", " + y + ".");
helpers.remove_at(i);
return;
}
}
}
else if(entity=="projectile")
{
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projtype==id && projectiles[i].prox==x && projectiles[i].proy==y)
{
projpool.destroy_sound(projectiles[i].projsound);
projectiles[i].defsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*death*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=projectiles[i].poxp*projectiles[i].projlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,false);
speak("Killed the projectile " + id + " at position " + x + ", " + y + ".");
projectiles.remove_at(i);
return;
}
}
}
else if(entity=="robot")
{
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].robottype==id && robots[i].robx==x && robots[i].roby==y)
{
robpool.destroy_sound(robots[i].robsound);
robots[i].defsound=robpool.play_extended_2d(get_map_sound("npc/robots/"+robots[i].robottype+"/*death*"),me.x,me.y,robots[i].robx,robots[i].roby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=robots[i].robxp*robots[i].roblevel*xpmod;
kills+=1;
int falldelay = round(robpool.get_sound_length(robots[i].defsound), 0);
spawn_bodyfall(robots[i].robx, robots[i].roby, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and robots[i].dropitem==true) spawn_obj(robots[i].robx, robots[i].roby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,robots[i].robx,robots[i].roby,false);
speak("Killed the robot " + id + " at position " + x + ", " + y + ".");
robots.remove_at(i);
return;
}
}
}
else if(entity=="turret")
{
for(uint i=0; i<turrets.length(); i++)
{
if(turrets[i].turtype==id && turrets[i].turx==x && turrets[i].tury==y)
{
turpool.destroy_sound(turrets[i].tursound);
turrets[i].defsound=turpool.play_extended_2d(get_map_sound("npc/turrets/"+turrets[i].turtype+"/*death*"),me.x,me.y,turrets[i].turx,turrets[i].tury,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=turrets[i].turxp*turrets[i].turlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,turrets[i].turx,turrets[i].tury,false);
speak("Killed the turret " + id + " at position " + x + ", " + y + ".");
turrets.remove_at(i);
return;
}
}
}
else if(entity=="bike")
{
for(uint i=0; i<bikes.length(); i++)
{
if(bikes[i].biketype==id && bikes[i].bikex==x && bikes[i].bikey==y)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
bikepool.destroy_sound(bikes[i].bellsound);
bikepool.destroy_sound(bikes[i].bikesound);
bikes[i].defsound=bikepool.play_extended_2d(get_map_sound("objects/bikes/"+bikes[i].biketype+"/misc/*death*"),me.x,me.y,bikes[i].bikex,bikes[i].bikey,0,0,0,0,false,0,0,painvolume,painpitch,false);
bikes[i].bikespeed=5;
onbike=false;
bikes[i].moveable=false;
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,bikes[i].bikex,bikes[i].bikey,false);
speak("Killed the bike " + id + " at position " + x + ", " + y + ".");
bikes.remove_at(i);
return;
}
}
}
else if(entity=="vehicle")
{
for(uint i=0; i<vehicles.length(); i++)
{
if(vehicles[i].vehtype==id && vehicles[i].vehx==x && vehicles[i].vehy==y)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
vehpool.destroy_sound(vehicles[i].beepsound);
vehpool.destroy_sound(vehicles[i].vehsound);
vehicles[i].defsound=vehpool.play_extended_2d(get_map_sound("objects/vehicles/"+vehicles[i].vehtype+"/*death*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,0,0,0,0,false,0,0,painvolume,painpitch,false);
vehicles[i].vehspeed=5;
invehicle=false;
vehicles[i].moveable=false;
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,false);
speak("Killed the vehicle " + id + " at position " + x + ", " + y + ".");
vehicles.remove_at(i);
return;
}
}
}
else if(entity=="zombie")
{
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombietype==id && zombies[i].zombx==x && zombies[i].zomby==y)
{
zombpool.destroy_sound(zombies[i].zombsound);
zombies[i].defsound=zombpool.play_extended_2d(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*death*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=zombies[i].zombxp*zombies[i].zomblevel*xpmod;
kills+=1;
int falldelay = round(zombpool.get_sound_length(zombies[i].defsound), 0);
spawn_bodyfall(zombies[i].zombx, zombies[i].zomby, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and zombies[i].dropitem==true) spawn_obj(zombies[i].zombx, zombies[i].zomby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,false);
speak("Killed the zombie " + id + " at position " + x + ", " + y + ".");
zombies.remove_at(i);
return;
}
}
}
else 
{
speak("Invalid entity type: "+entity+".");
}
}
else
{
speak("Invalid command syntax. Usage: /kill entity id x y, or /kn entity id x y.");
if(!in_commandstack) game();
}
}
else if (base_command == "kl" || base_command == "killall")
{
if (parsed.length() == 1)
{
int total_kills=0;
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animalhealth>0)
{
animalpool.destroy_sound(animals[i].amsound);
animals[i].defsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animals[i].animaltype+"/*death*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=animals[i].amxp*animals[i].amlevel*xpmod;
kills+=1;
int falldelay = round(animalpool.get_sound_length(animals[i].defsound), 0);
spawn_bodyfall(animals[i].amx, animals[i].amy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and animals[i].dropitem==true) spawn_obj(animals[i].amx, animals[i].amy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,animals[i].amx,animals[i].amy,false);
}
total_kills++;
}
animals.resize(0);
for(uint i=0; i<bosses.length(); i++)
{
if(bosses[i].bosshealth>0)
{
bosspool.destroy_sound(bosses[i].bossesound);
bosses[i].defsound=bosspool.play_extended_2d(get_map_sound("npc/bosses/"+bosses[i].bosstype+"/*death*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=bosses[i].bossxp*bosses[i].bosslevel*xpmod;
kills+=1;
int falldelay = round(bosspool.get_sound_length(bosses[i].defsound), 0);
spawn_bodyfall(bosses[i].bossx, bosses[i].bossy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and bosses[i].dropitem==true) spawn_obj(bosses[i].bossx, bosses[i].bossy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,bosses[i].bossx,bosses[i].bossy,false);
}
total_kills++;
}
bosses.resize(0);
for(uint i=0; i<humans.length(); i++)
{
if(humans[i].humanhealth>0)
{
humanpool.destroy_sound(humans[i].refsound);
humanpool.destroy_sound(humans[i].refsound2);
humanpool.destroy_sound(humans[i].hurtsound);
humanpool.destroy_sound(humans[i].humsound);
humans[i].defsound=humanpool.play_extended_2d(get_map_sound("npc/humans/"+humans[i].humantype+"/*death*"),me.x,me.y,humans[i].humx,humans[i].humy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=humans[i].humxp*humans[i].humlevel*xpmod;
kills+=1;
int falldelay = round(humanpool.get_sound_length(humans[i].defsound), 0);
spawn_bodyfall(humans[i].humx, humans[i].humy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and humans[i].dropitem==true) spawn_obj(humans[i].humx, humans[i].humy, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,humans[i].humx,humans[i].humy,false);
}
total_kills++;
}
humans.resize(0);
for(uint i=0; i<helpers.length(); i++)
{
if(helpers[i].helperhealth>0)
{
helperpool.destroy_sound(helpers[i].helpersound);
helpers[i].defsound=helperpool.play_extended_2d(get_map_sound("npc/helpers/"+helpers[i].helpertype+"/*death*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,0,0,0,0,false,0,0,painvolume,painpitch,false);
int falldelay = round(helperpool.get_sound_length(helpers[i].defsound), 0);
spawn_bodyfall(helpers[i].helpx, helpers[i].helpy, (falldelay <= 0 ? random(500, 1000) : falldelay));
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,helpers[i].helpx,helpers[i].helpy,false);
}
total_kills++;
}
helpers.resize(0);
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projhealth>0)
{
projpool.destroy_sound(projectiles[i].projsound);
projectiles[i].defsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*death*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=projectiles[i].poxp*projectiles[i].projlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,false);
}
total_kills++;
}
projectiles.resize(0);
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].robothealth>0)
{
robpool.destroy_sound(robots[i].robsound);
robots[i].defsound=robpool.play_extended_2d(get_map_sound("npc/robots/"+robots[i].robottype+"/*death*"),me.x,me.y,robots[i].robx,robots[i].roby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=robots[i].robxp*robots[i].roblevel*xpmod;
kills+=1;
int falldelay = round(robpool.get_sound_length(robots[i].defsound), 0);
spawn_bodyfall(robots[i].robx, robots[i].roby, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and robots[i].dropitem==true) spawn_obj(robots[i].robx, robots[i].roby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,robots[i].robx,robots[i].roby,false);
}
total_kills++;
}
robots.resize(0);
for(uint i=0; i<turrets.length(); i++)
{
if(turrets[i].turhealth>0)
{
turpool.destroy_sound(turrets[i].tursound);
turrets[i].defsound=turpool.play_extended_2d(get_map_sound("npc/turrets/"+turrets[i].turtype+"/*death*"),me.x,me.y,turrets[i].turx,turrets[i].tury,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=turrets[i].turxp*turrets[i].turlevel*xpmod;
kills+=1;
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,turrets[i].turx,turrets[i].tury,false);
}
total_kills++;
}
turrets.resize(0);
for(uint i=0; i<bikes.length(); i++)
{
if(bikes[i].bikehealth>0)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
bikepool.destroy_sound(bikes[i].bellsound);
bikepool.destroy_sound(bikes[i].bikesound);
bikes[i].defsound=bikepool.play_extended_2d(get_map_sound("objects/bikes/"+bikes[i].biketype+"/misc/*death*"),me.x,me.y,bikes[i].bikex,bikes[i].bikey,0,0,0,0,false,0,0,painvolume,painpitch,false);
bikes[i].bikespeed=5;
onbike=false;
bikes[i].moveable=false;
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,bikes[i].bikex,bikes[i].bikey,false);
}
total_kills++;
}
bikes.resize(0);
for(uint i=0; i<vehicles.length(); i++)
{
if(vehicles[i].vehhealth>0)
{
cammable=true;
jumpable=true;
moveable=true;
speedable=true;
spiable=true;
sittable=true;
turnable=true;
telable=true;
vehpool.destroy_sound(vehicles[i].beepsound);
vehpool.destroy_sound(vehicles[i].vehsound);
vehicles[i].defsound=vehpool.play_extended_2d(get_map_sound("objects/vehicles/"+vehicles[i].vehtype+"/*death*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,0,0,0,0,false,0,0,painvolume,painpitch,false);
vehicles[i].vehspeed=5;
invehicle=false;
vehicles[i].moveable=false;
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,vehicles[i].vehx,vehicles[i].vehy,false);
}
total_kills++;
}
vehicles.resize(0);
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombiehealth>0)
{
zombpool.destroy_sound(zombies[i].zombsound);
zombies[i].defsound=zombpool.play_extended_2d(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*death*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if(xpmod>=1) xp+=zombies[i].zombxp*zombies[i].zomblevel*xpmod;
kills+=1;
int falldelay = round(zombpool.get_sound_length(zombies[i].defsound), 0);
spawn_bodyfall(zombies[i].zombx, zombies[i].zomby, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] healtype=get_map_sound_folders("objects/items/health/*");
if(healtype.length()!=0 and zombies[i].dropitem==true) spawn_obj(zombies[i].zombx, zombies[i].zomby, 500, "health", random_string(healtype), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
p.play_2d(get_pack_sound("misc/*punch*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,false);
}
total_kills++;
}
zombies.resize(0);
speak("Killed all entities.");
}
else
{
speak("Invalid command syntax. Usage: /killall, or /kl.");
if(!in_commandstack) game();
}
}
else if (base_command == "hp" || base_command == "help")
{
    if (parsed.length() == 1)
    {
        if (coms.open("data/references/commands.txt", "rb"))
        {
            comsplit = coms.read();
            coms.close();
            string content = string_replace(comsplit, "\r\n", "\n", true);
            array<string> raw = content.split("\n");
            array<string> lines;
            for (uint i = 0; i < raw.length(); i++)
            {
                string l = string_trim_sides(raw[i]);
                if (l != "")
                    lines.insert_last(l);
            }
            if (lines.length() == 0)
            {
                speak("There are no commands available to view.");
                if (!in_commandstack) game();
            }
            setupmenu(false);
            m.add_item_tts("These are the available commands you can use in the game.");
            for (uint i = 0; i < lines.length(); i++)
            {
                m.add_item_tts(lines[i], lines[i]);
            }
            m.add_item_tts("Total commands: " + lines.length() + ".");
            int mres = m.run("Help menu.", true);
            if (mres == 0)
            {
                speak("canceled");
                if (!in_commandstack) game();
            }
        }
        else
        {
            speak("Failed to open data/references/commands.txt.");
            if (!in_commandstack) game();
        }
    }
    else
    {
        speak("Invalid command syntax. Usage: /help, or /hp.");
        if (!in_commandstack) game();
    }
}
else if (base_command == "gl" || base_command == "getall")
{
if (parsed.length() == 1)
{
if(objs.length() == 0)
{
speak("There are no items on this map.");
if(!in_commandstack) game();
}
else
{
for(uint i=0; i<objs.length(); i++)
{
objs[i].getsound=itempool.play_stationary_extended(get_map_sound("objects/items/"+objs[i].objtype+"/"+objs[i].objtype2+"/*get*"),false,0,0,itemvolume,itempitch,false);
give(objs[i].objtype2,1);
}
objs.resize(0);
speak("Collected all items.");
}
}
else
{
speak("Invalid command syntax. Usage: /getall, or /gl.");
if(!in_commandstack) game();
}
}
else if (base_command == "ic" || base_command == "invclear")
{
if (parsed.length() == 1)
{
if (inv.get_size()==0)
{
speak("There are no items in your inventory.");
if(!in_commandstack) game();
}
else
{
clear_inv();
speak("Your inventory has been cleared.");
}
}
else
{
speak("Invalid command syntax. Usage: /invclear, or /ic.");
if(!in_commandstack) game();
}
}
else if(base_command == "gv" || base_command=="give")
{
if(parsed.length()==3)
{
string item=parsed[1];
int amount=stn(parsed[2]);
if(amount>0)
{
p.play_stationary(get_pack_sound("misc/give.ogg"),false);
give(item,stn(amount));
speak("You received " + amount + " " + (amount == 1 ? item : item + "s") + ".");
}
else
{
p.play_stationary(get_pack_sound("misc/take.ogg"),false);
give(item,stn(amount));
speak("You recycled " + amount + " " + (amount == 1 ? item : item + "s") + ".");
}
}
else
{
speak("Invalid command syntax. Usage: /give item amount, or /gv item amount.");
}
}
else if (base_command == "mu"  && !map_is_compiled || base_command == "menu" && !map_is_compiled)
{
if (parsed.length() == 1)
{
pause_pools();
mapmenu2();
}
else
{
speak("Invalid command syntax. Usage: /menu, or /mu.");
if(!in_commandstack) game();
}
}
else if (base_command == "pf" || base_command == "preffs")
{
if (parsed.length() == 1)
{
pause_pools();
settingsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /preffs, or /pf.");
if(!in_commandstack) game();
}
}
else if (base_command == "st" || base_command == "stats")
{
if (parsed.length() == 1)
{
pause_pools();
statsmenu2();
}
else
{
speak("Invalid command syntax. Usage: /stats, or /st.");
if(!in_commandstack) game();
}
}
else if (base_command == "cm"  && !map_is_compiled || base_command == "changemap" && !map_is_compiled)
{
if (parsed.length() == 4)
{
string mapname=parsed[1];
int x = stn(parsed[2]);
int y = stn(parsed[3]);
if (directory_exists("data/maps/decompiled/" + mapname))
{
if (x >= minx && x <= maxx && y >= miny && y <= maxy)
{
load_map(mapname, mapowner, force_compiled:map_is_compiled, force_spawned:true);
}
}
else
{
speak("Map " + mapname + " not found. Please check the name and try again.");
if(!in_commandstack) game();
}
if(x >= minx && x <= maxx && y >= miny && y <= maxy)
{
gop("me", "", x, y);
}
else
{
speak("Invalid coordinates. Please make sure x and y are within the map boundaries.");
if(!in_commandstack) game();
}
}
else
{
speak("Invalid command syntax. Usage: /changemap mapname x y, or /cm mapname x y.");
if(!in_commandstack) game();
}
}
else if (base_command == "nm"  && !map_is_compiled || base_command == "newmap" && !map_is_compiled)
{
if (parsed.length() == 1)
{
vd.set_disallowed_chars("", false, "This character is not allowed.");
string name=vd.input_box("","Enter the name of this map.");
string name2=vd.input_box("","Enter the owner of this map. Press enter to use the default owner.", "noone");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("","Enter the minimum length of this map.");
string mx2=vd.input_box("","Enter the maximum length of this map.");
string my=vd.input_box("","Enter the minimum height of this map.");
string my2=vd.input_box("","Enter the maximum height of this map.");
if(mapname=="" and mapowner=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
string mapowner=name2;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
if(directory_exists("data/maps/decompiled/"+mapname))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
if(!in_commandstack) game();
}
else
{
create_map(mapname, mapowner, minx, maxx, miny, maxy);
load_map(mapname, mapowner);
}
}
else
{
speak("Invalid command syntax. Usage: /newmap, or /nm.");
if(!in_commandstack) game();
}
}
else if (base_command == "pl" || base_command == "play")
{
if (parsed.length() == 2)
{
string sfx = parsed[1];
temp.play_stationary(get_pack_sound("misc/"+sfx+"*"),false);
}
else
{
speak("Invalid command syntax. Usage: /play sound, or /pl sound.");
if(!in_commandstack) game();
}
}
else if (base_command == "sp" || base_command == "speek")
{
if (parsed.length() >= 2)
{
string txt=join_string_array(parsed, 1, parsed.length());
speak(txt);
}
else
{
speak("Invalid command syntax. Usage: /speek text, or /sp text.");
if(!in_commandstack) game();
}
}
else if (base_command == "rm" || base_command == "relmap")
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload "+mapname+"?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
load_map(mapname, mapowner, anounce_mapload:false, force_compiled:map_is_compiled, force_spawned:true);
speak("map reloaded");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
else
{
speak("Invalid command syntax. Usage: /relmap, or /rm.");
if(!in_commandstack) game();
}
}
else if (base_command == "rc" || base_command == "relchar")
{
if (parsed.length() == 1)
{
bonehealth=0;
broken_bones.delete_all();
clear_inv();
kombatlog.resize(0);
destroy_all_charas();
charparse();
speak("character reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relchar, or /rc.");
if(!in_commandstack) game();
}
}
else if (base_command == "rs" || base_command == "relshields")
{
if (parsed.length() == 1)
{
p.destroy_sound(shieldloop);
p.destroy_sound(shieldslot);
drawnshield=false;
fireable=true;
jumpable=true;
moveable=true;
shieldon=0;
shieldweight=1;
shieldtype="none";
destroy_all_shields();
shieldparse();
speak("shields reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relshields, or /rs.");
if(!in_commandstack) game();
}
}
else if (base_command == "rt" || base_command == "relscripts")
{
if (parsed.length() == 1)
{
load_scriptkeys();
speak("script keys reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relscripts, or /rk.");
if(!in_commandstack) game();
}
}
else if (base_command == "rw" || base_command == "relweps")
{
if (parsed.length() == 1)
{
destroy_all_weapons();
weaponparse();
speak("weapons reloaded");
}
else
{
speak("Invalid command syntax. Usage: /relweps, or /rw.");
if(!in_commandstack) game();
}
}
else if (base_command == "sm" || base_command == "scriptmode")
{
if (parsed.length() == 1)
{
if(scriptmode==false)
{
scriptmode=true;
if(switchsound==1) p.play_stationary(get_pack_sound("misc/switchon.ogg"),false);
speak("Script keys enabled.");
}
else if(scriptmode==true)
{
scriptmode=false;
if(switchsound==1) p.play_stationary(get_pack_sound("misc/switchoff.ogg"),false);
speak("Script keys disabled.");
}
}
else
{
speak("Invalid command syntax. Usage: /relchar, or /rc.");
if(!in_commandstack) game();
}
}
else if (base_command == "sd"  && !map_is_compiled || base_command == "suicide" && !map_is_compiled)
{
if (parsed.length() == 1)
{
if(lifecard>=2)
{
p.play_stationary(get_pack_sound("misc/*punch*"),false);
if(charlifesound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*life*"),false);
lifecard-=1;
health=maxhealth;
hearttime=maxhealth;
bonehealth=0;
broken_bones.delete_all();
}
else if(lifecard<=1)
{
destroymap();
p.destroy_sound(painslot);
p.play_stationary(get_pack_sound("misc/*punch*"),false);
if(chardeathsound==1) dlgplay(get_pack_sound("characters/"+chartype+"/*death*"), true, true, 30);
dlgplay(get_map_sound("objects/platforms/"+gmt(me.x,me.y)+"/*fall*"));
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("You have died. Would you like to try again?",true);
if(mres==0)
{
wait(500);
p.destroy_sound(refslot);
jumpable=false;
moveable=false;
sitting=true;
wepdef=0;
bonehealth=0;
broken_bones.delete_all();
clear_inv();
kombatlog.resize(0);
destroy_all_charas();
charparse();
}
if(mres==1)
{
wait(500);
p.destroy_sound(refslot);
jumpable=false;
moveable=false;
sitting=true;
wepdef=0;
broken_bones.delete_all();
clear_inv();
kombatlog.resize(0);
destroy_all_charas();
charparse();
}
if(mres==2)
{
p.destroy_sound(refslot);
jumpable=false;
moveable=false;
sitting=true;
wepdef=0;
broken_bones.delete_all();
clear_inv();
kombatlog.resize(0);
destroy_all_charas();
charparse();
me.x=0;
me.y=0;
mainmenu();
}
}
}
else
{
speak("Invalid command syntax. Usage: /relchar, or /rc.");
if(!in_commandstack) game();
}
}
else if (base_command == "gz"  && !map_is_compiled || base_command == "gozone" && !map_is_compiled)
{
if (parsed.length() == 1)
{
if (zones.length() == 0)
{
speak("There are no zones available on this map.");
if(!in_commandstack) game();
}
pause_pools();
setupmenu();
for (uint i = 0; i < zones.length(); i++)
{
double width = zones[i].maxx - zones[i].minx + 1;
double height = zones[i].maxy - zones[i].miny + 1;
string zone_desc = zones[i].text + ", " +int(width) + " x " + int(height) + " zone, at " +int(zones[i].minx) + ", " + int(zones[i].miny);
m.add_item_tts(zone_desc, zones[i].text);
}
int mres=m.run("Choose the zone you'd like to go to. There are "+zones.length()+" zones available on this map.", true);
if(mres==0)
{
resume_pools();
speak("canceled");
if(!in_commandstack) game();
}
if (mres==0 and mres>=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
if (mres>0 and mres<=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
}
else
{
speak("Invalid command syntax. Usage: /gozone, or /gz.");
if(!in_commandstack) game();
}
}
else if (base_command == "mp"  && !map_is_compiled || base_command == "maps" && !map_is_compiled)
{
if (parsed.length() == 1)
{
string[] maps=find_directories("data/maps/decompiled/*");
if(maps.length()==0)
{
pause_pools();
dlg_snd("Error. There are no decompiled maps available to view. Press enter to continue.");
resume_pools();
if(!in_commandstack) game();
}
else
{
pause_pools();
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".sif", "", true);
mapper.open("data/maps/decompiled/"+temp_map_name+"/"+"info.sif", "rb");
string temp_map_data = mapper.read();
mapper.close();            
string temp_owner;
string[] lines = delinear(temp_map_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "owner" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
uint64 size = get_directory_size("data/maps/decompiled/" + maps[i]);
string readable_size = measure_file_size(size);
m.add_item_tts(temp_map_name + " (by " + temp_owner + ". Total size: " + readable_size+")", maps[i]);
}
int mres=m.run("Decompiled maps menu", true);
if(mres==0)
{
resume_pools();
speak("canceled");
if(!in_commandstack) game();
}
if (mres==0 and mres>=maps.length())
{
resume_pools();
speak("canceled");
if(!in_commandstack) game();
}
if (mres>0 and mres<=maps.length())
{
resume_pools();
mapname=maps[mres-1];
mapname=string_replace(mapname, ".sif", "", true);
me.x=0;
me.y=0;
load_map(mapname, mapowner);
}
}
}
else
{
speak("Invalid command syntax. Usage: /maps, or /mp.");
if(!in_commandstack) game();
}
}
else if (base_command == "rp"  && !map_is_compiled || base_command == "rawmap" && !map_is_compiled)
{
if (parsed.length() == 1)
{
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
else
{
speak("Invalid command syntax. Usage: /rawmap, or /rp.");
if(!in_commandstack) game();
}
}
else if (base_command == "rd"  && !map_is_compiled || base_command == "rawdata" && !map_is_compiled)
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
if(!in_commandstack) game();
}
if(mres==1)
{
string clipboard_data = clipboard_read_text();
if (clipboard_data == "")
{
dlg_snd("Error. The clipboard is empty.");
resume_pools();
if(!in_commandstack) game();
}
string[] lines = string_split(clipboard_data, "\r\n", true);
bool is_valid = validate_map_data(lines);
if (!is_valid)
{
dlg_snd("Error. The clipboard data is invalid.");
resume_pools();
if(!in_commandstack) game();
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapper.write(clipboard_data);
mapper.close();
load_map(mapname, mapowner, force_spawned:true);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"), false);
speak("Map updated.");
}
if(mres==2)
{
resume_pools();
speak("canceled");
if(!in_commandstack) game();
}
}
else
{
speak("Invalid command syntax. Usage: /rawdata, or /rd.");
if(!in_commandstack) game();
}
}
else if (base_command == "dm"  && !map_is_compiled || base_command == "delmap" && !map_is_compiled)
{
if (parsed.length() == 1)
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete "+mapname+"? This action cannot be undone.",true);
if(mres==0)
{
speak("canceled");
if(!in_commandstack) game();
}
if(mres==1)
{
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
if(directory_exists("data/maps/decompiled/"+mapname)) directory_delete("data/maps/decompiled/"+mapname);
speak("map deleted");
dlgplay(get_pack_sound("misc/mapdelete.ogg"),false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
speak("canceled");
if(!in_commandstack) game();
}
}
else
{
speak("Invalid command syntax. Usage: /delmap, or /dm.");
if(!in_commandstack) game();
}
}
else
{
speak("Unknown command: /"+base_command);
if(!in_commandstack) game();
}
}
void comstack(string input)
{
    string[] parts = string_split(input, ";", true);
    for (uint i = 0; i < parts.length(); i++)
    {
        string part = string_trim_sides(parts[i]);
        if (part == "")
            continue;
        uint pos = 0;
        while (pos < part.length() && part.substr(pos, 1) >= "0" && part.substr(pos, 1) <= "9")
        {
            pos++;
        }
        if (pos > 0)
        {
            int delay = stn(part.substr(0, pos));
            if (delay > 0)
            {
                int start_time = stacktimer.elapsed;
                while(stacktimer.elapsed - start_time < delay)
                {
continue;
                }
            }
            part = string_trim_sides(part.substr(pos));
        }
        if (part == "")
            continue;
        if (part.substr(0, 1) != "/")
            part = "/" + part;
        in_commandstack = true;
        comparse(part);
        in_commandstack = false;
    }
}
void load_scriptkeys()
{
    string[] old_cmds = scriptkeys;
    int[] old_lastused = scriptkey_lastused;
    scriptkeys.resize(0);
    scriptkey_cooldown.resize(0);
    scriptkey_lastused.resize(0);
    scriptkey_speak.resize(0);
    if (!file_exists("data/references/scriptkeys.txt"))
        return;
    string[] lines = clean_lines("data/references/scriptkeys.txt");
    for (uint i = 0; i < lines.length(); i++)
    {
        string line = string_trim_sides(lines[i]);
        if (line == "")
            continue;
        string[] parts = string_split(line, " ", true);
        int cd = 0;
        bool speakflag = false;
        string cmd;
        uint idx = 0;
        if (parts.length() > idx && string_is_digits(parts[idx]))
        {
            cd = stn(parts[idx]);
            idx++;
        }
        if (parts.length() > idx && (parts[idx] == "true" || parts[idx] == "false"))
        {
            speakflag = (parts[idx] == "true");
            idx++;
        }
        cmd = join_string_array(parts, idx, parts.length());
        cmd = string_trim_sides(cmd);
        if (cmd == "")
            continue;
        scriptkeys.insert_last(cmd);
        scriptkey_cooldown.insert_last(cd);
        scriptkey_speak.insert_last(speakflag);
        if (i < old_lastused.length())
            scriptkey_lastused.insert_last(old_lastused[i]);
        else
            scriptkey_lastused.insert_last(0);
    }
    scriptkeys_loaded = true;
}
void use_scriptkey(uint index)
{
    if (!scriptkeys_loaded)
        load_scriptkeys();
    if (scriptkeys.length() == 0)
    {
        speak("No scriptkeys are defined.");
        return;
    }
    if (index >= scriptkeys.length())
    {
        speak("Scriptkey " + (index + 1) + " not found.");
        return;
    }
    int sctime = comtimer.elapsed;
    int last = scriptkey_lastused[index];
    int cooldown = scriptkey_cooldown[index];
    if (cooldown > 0 && sctime - last < cooldown)
    {
        if (scriptkey_speak[index])
            speak("This command cannot be used yet.");
        return;
    }
    string cmd = string_trim_sides(scriptkeys[index]);
    if (cmd == "")
    {
        speak("Scriptkey " + (index + 1) + " not found.");
        return;
    }
    scriptkey_lastused[index] = sctime;
    use_command(cmd);
}
void use_command(string cmd)
{
if (cmd == "")
return;
comparse(cmd);
}
