projectile@[]projectiles(0);
class projectile
{
bool fireable, moveable;
int defsound, hurtsound, projsound, wepsound;
double projlevel;
double poxp;
int projcard;
int projehealth;
double projhealth;
double projmaxhealth;
int prox;
int proy;
int projdir;
int damage;
int firetime=projtime;
int projtime;
string projtype;
timer firetimer, projtimer;
projectile(int px,int py,int dir,double hp,double maxhp,int pc,int dm,int sp,double plv,double pxp,string pt,bool pf,bool pm)
{
this.projehealth=hp;
prox=px;
proy=py;
projdir=dir;
projhealth=hp;
projmaxhealth=maxhp;
projcard=pc;
damage=dm;
projtime=sp;
projlevel=plv;
poxp=pxp;
projtype=pt;
fireable=pf;
moveable=pm;
projsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projtype+"/*loop*"),me.x,me.y,prox,proy,0,0,0,0,true,0,0,painvolume,painpitch,false);
}
}
void projloop()
{
for(uint i=0; i<projectiles.length(); i++)
{
if(projectiles[i].projtimer.elapsed>=projectiles[i].projtime)
{
projpool.update_sound_2d(projectiles[i].projsound,projectiles[i].prox,projectiles[i].proy);
projectiles[i].projtimer.restart();
if(projectiles[i].projdir==1 && projectiles[i].moveable==true && paused==0)
{
if(projectiles[i].prox>=maxx+1 || string_contains(gmt(projectiles[i].prox+1,projectiles[i].proy),"wall",1)>-1 || is_in_safe(projectiles[i].prox+1, projectiles[i].proy))
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
projectiles[i].projdir=0;
}
else 
{
projectiles[i].prox++;
}
}
else if(projectiles[i].projdir==0 && projectiles[i].moveable==true && paused==0)
{
if(projectiles[i].prox<=minx-1 || string_contains(gmt(projectiles[i].prox-1,projectiles[i].proy),"wall",1)>-1 || is_in_safe(projectiles[i].prox-1, projectiles[i].proy))
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
projectiles[i].projdir=1;
}
else 
{
projectiles[i].prox--;
}
}
if(me.x==projectiles[i].prox and me.y==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true and inplain==false and invehicle==false and paused==0)
{
if(melee==true and weapontype=="melee" and wepdef==1)
{
int refchance = random(0, 100);
int refprob = 80;
if(refchance < refprob)
{
weaponslot=p.play_stationary_extended(get_pack_sound("equipments/weapons/"+weapontype+"/"+weapontype2+"/*block*"),false,0,0,weaponvolume,weaponpitch,false);
}
else
{
if(shieldon==1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, ((projectiles[i].damage * 0.5) * projectiles[i].projlevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(projectiles[i].projtype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
projectiles[i].wepsound=projpool.play_stationary_extended(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, ((projectiles[i].damage * 0.5) * projectiles[i].projlevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(projectiles[i].projtype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
}
}
}
else if (shieldon == 1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, (projectiles[i].damage * projectiles[i].projlevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(projectiles[i].projtype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
projectiles[i].wepsound=projpool.play_stationary_extended(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, (projectiles[i].damage * projectiles[i].projlevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(projectiles[i].projtype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
}
projectiles[i].firetimer.restart();
}
for(uint i1=0; i1<animals.length(); i1++)
{
if(animals[i1].amx==projectiles[i].prox and animals[i1].amy==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true)
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
animals[i1].hurtsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animals[i1].animaltype+"/*hurt*"),me.x,me.y,animals[i1].amx,animals[i1].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
animals[i1].animalhealth-=projectiles[i].damage;
projectiles[i].firetimer.restart();
}
}
for(uint i2=0; i2<humans.length(); i2++)
{
if(humans[i2].humx==projectiles[i].prox and humans[i2].humy==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true)
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
humans[i2].hurtsound=humanpool.play_extended_2d(get_map_sound("npc/humans/"+humans[i2].humantype+"/*hurt*"),me.x,me.y,humans[i2].humx,humans[i2].humy,0,0,0,0,false,0,0,painvolume,painpitch,false);
humans[i2].humanhealth-=projectiles[i].damage;
projectiles[i].firetimer.restart();
}
}
for(uint i3=0; i3<robots.length(); i3++)
{
if(robots[i3].robx==projectiles[i].prox and robots[i3].roby==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true)
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
robots[i3].hurtsound=robpool.play_extended_2d(get_map_sound("npc/robots/"+robots[i3].robottype+"/*hurt*"),me.x,me.y,robots[i3].robx,robots[i3].roby,0,0,0,0,false,0,0,painvolume,painpitch,false);
robots[i3].robothealth-=projectiles[i].damage;
projectiles[i].firetimer.restart();
}
}
for(uint i4=0; i4<zombies.length(); i4++)
{
if(zombies[i4].zombx==projectiles[i].prox and zombies[i4].zomby==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true)
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
zombies[i4].hurtsound=zombpool.play_extended_2d(get_map_sound("npc/zombies/"+zombies[i4].zombietype+"/*hurt*"),me.x,me.y,zombies[i4].zombx,zombies[i4].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
zombies[i4].zombiehealth-=projectiles[i].damage;
projectiles[i].firetimer.restart();
}
}
for(uint i5=0; i5<vehicles.length(); i5++)
{
if(vehicles[i5].vehx==projectiles[i].prox and vehicles[i5].vehy==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true and invehicle==true)
{
vehicles[i5].hurtsound=vehpool.play_stationary_extended(get_map_sound("objects/vehicles/"+vehicles[i5].vehtype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
vehicles[i5].vehhealth-=projectiles[i].damage;
projectiles[i].firetimer.restart();
}
}
for(uint i6=0; i6<objs.length(); i6++)
{
if(objs[i6].itx==projectiles[i].prox and objs[i6].ity==projectiles[i].proy and projectiles[i].firetimer.elapsed>=projectiles[i].firetime and projectiles[i].fireable==true)
{
projectiles[i].wepsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*hit*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
objs[i6].hurtsound=itempool.play_extended_2d(get_map_sound("objects/items/"+objs[i6].objtype+"/"+objs[i6].objtype2+"/*break*"),me.x,me.y,objs[i6].itx,objs[i6].ity,0,0,0,0,false,0,0,itemvolume,itempitch,false);
projectiles[i].firetimer.restart();
objs.remove_at(i6);
return;
}
}
if(projectiles[i].projhealth<=0)
{
if(projectiles[i].projcard>=2 and paused==0)
{
projpool.play_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*life*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,false);
projectiles[i].projhealth=projectiles[i].projehealth;
projectiles[i].projcard-=1;
}
else if(projectiles[i].projcard<=1 and paused==0)
{
projpool.destroy_sound(projectiles[i].hurtsound);
projpool.destroy_sound(projectiles[i].projsound);
projectiles[i].defsound=projpool.play_extended_2d(get_map_sound("npc/projectiles/"+projectiles[i].projtype+"/*death*"),me.x,me.y,projectiles[i].prox,projectiles[i].proy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if (xpmod >= 1)
{
double gained_xp = projectiles[i].poxp * projectiles[i].projlevel * xpmod;
xp += gained_xp;
kombatlog.insert_last(gained_xp + " experience gained. Defeated " + projectiles[i].projtype + " level " + projectiles[i].projlevel + ".");
}
kills+=1;
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
projectiles.remove_at(i);
return;
}
}
}
}
}
void spawn_projectile(int x,int y,int dir,double hp,double maxhp,int pc,int dm,int projtime,double projlevel,double xp,string projtype,bool fireable,bool moveable)
{
projectile p1(x,y,dir,hp,maxhp,pc,dm,projtime,projlevel,xp,projtype,fireable,moveable);
projectiles.insert_last(p1);
}
void destroy_all_projectiles()
{
for(uint i=0; i<projectiles.length(); i++)
{
projpool.destroy_sound(projectiles[i].projsound);
}
projectiles.resize(0);
}
