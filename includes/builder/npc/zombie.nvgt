zombie@[]zombies(0);
class zombie
{
bool dropitem, fireable, moveable, moveable2, spotted;
int zombsound, defsound, hurtsound, stepsound, spawnsound, tilesound, wepsound;
int zombiecard;
int zombhealth;
double zomblevel;
double zombxp;
double zombiehealth;
double zombiemaxhealth;
int zombx;
int zomby;
int zombirange;
int zombirange2;
int zombirange3;
int zombirange4;
int damage;
int zombietime;
int firetime;
int taunttime;
string zombietype;
timer zombietimer, firetimer, taunttimer;
zombie(int zx,int zy,int zbrange,int zbrange2,int zbrange3,int zbrange4,double hp,double maxhp,int zc,int dm,int ft,int sp,double zomblv,double zxp,string zt,bool zombf,bool zombt,bool zombt2,bool dpm)
{
this.zombhealth=hp;
zombx=zx;
zomby=zy;
zombirange=zbrange;
zombirange2=zbrange2;
zombirange3=zbrange3;
zombirange4=zbrange4;
zombiehealth=hp;
zombiemaxhealth=maxhp;
zombiecard=zc;
damage=dm;
firetime=ft;
zombietime=sp;
zomblevel=zomblv;
zombxp=zxp;
zombietype=zt;
fireable=zombf;
moveable=zombt;
moveable2=zombt2;
dropitem=dpm;
spawnsound=zombpool.play_extended_2d(get_map_sound("npc/zombies/"+zombietype+"/*spawn*"),me.x,me.y,zombx,zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
}
}
void zombloop()
{
for(uint i=0; i<zombies.length(); i++)
{
if(zombies[i].zombietimer.elapsed>=zombies[i].zombietime)
{
bool within_horizontal_range = absolute(me.x - zombies[i].zombx) <= zombies[i].zombirange3;
bool within_vertical_range = absolute(me.y - zombies[i].zomby) <= zombies[i].zombirange4;
zombies[i].spotted = within_horizontal_range && within_vertical_range;
if(zombies[i].spotted)
{
bool moved = false;
if(zombies[i].zombx<me.x && zombies[i].moveable==true && paused==0)
{
if (string_contains(gmt(zombies[i].zombx+1, zombies[i].zomby), "wall", 1) > -1 or is_in_safe(zombies[i].zombx+1, zombies[i].zomby))
{
zombies[i].zombx--;
moved = true;
}
else
{
zombies[i].zombx++;
moved = true;
}
}
else if(zombies[i].zombx>me.x && zombies[i].moveable==true && paused==0)
{
if (string_contains(gmt(zombies[i].zombx-1, zombies[i].zomby), "wall", 1) > -1 or is_in_safe(zombies[i].zombx-1, zombies[i].zomby))
{
zombies[i].zombx++;
moved = true;
}
else
{
zombies[i].zombx--;
moved = true;
}
}
if(zombies[i].zomby<me.y && zombies[i].moveable2==true && paused==0)
{
if (string_contains(gmt(zombies[i].zombx, zombies[i].zomby+1), "wall", 1) > -1 or is_in_safe(zombies[i].zombx, zombies[i].zomby+1))
{
zombies[i].zomby--;
moved = true;
}
else
{
zombies[i].zomby++;
moved = true;
}
}
else if(zombies[i].zomby>me.y && zombies[i].moveable2==true && paused==0)
{
if (string_contains(gmt(zombies[i].zombx, zombies[i].zomby-1), "wall", 1) > -1 or is_in_safe(zombies[i].zombx, zombies[i].zomby-1))
{
zombies[i].zomby++;
moved = true;
}
else
{
zombies[i].zomby--;
moved = true;
}
}
if (moved)
{
zombies[i].tilesound = zombpool.play_extended_2d(get_map_sound("npc/zombies/" + zombies[i].zombietype + "/*step*"),me.x, me.y, zombies[i].zombx, zombies[i].zomby, 0, 0, 0, 0, false, 0, 0, tilevolume, tilepitch, false);
zombies[i].stepsound = 1;
}
else
{
zombies[i].stepsound = 0;
}
zombpool.update_sound_2d(zombies[i].zombsound, zombies[i].zombx, zombies[i].zomby);
zombies[i].zombietimer.restart();
}
}
if (zombies[i].taunttimer.elapsed >= zombies[i].taunttime)
{
zombies[i].zombsound = zombpool.play_extended_2d(get_map_sound("npc/zombies/" + zombies[i].zombietype + "/*taunt*"), me.x, me.y, zombies[i].zombx, zombies[i].zomby, 0, 0, 0, 0, false, 0, 0, painvolume, painpitch, false);
int zombdelay = round(zombpool.get_sound_length(zombies[i].zombsound), 0);
zombies[i].taunttime = (zombdelay <= 0 ? random(500, 1000) : zombdelay);
zombies[i].taunttimer.restart();
}
if(absolute(me.x-zombies[i].zombx)<=zombies[i].zombirange and absolute(me.y-zombies[i].zomby)<=zombies[i].zombirange2 and zombies[i].firetimer.elapsed>=zombies[i].firetime and zombies[i].fireable==true and inplain==false and invehicle==false and paused==0)
{
zombies[i].stepsound=0;
if(melee==true and weapontype=="melee" and wepdef==1)
{
int refchance = random(0, 100);
int refprob = 80;
if(refchance < refprob)
{
weaponslot=p.play_stationary_extended(get_pack_sound("equipments/weapons/"+weapontype+"/"+weapontype2+"/*block*"),false,0,0,weaponvolume,weaponpitch,false);
}
else
{
if(shieldon==1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, ((zombies[i].damage * 0.5) * zombies[i].zomblevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(zombies[i].zombietype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
zombies[i].wepsound=zombpool.play_stationary_extended(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, ((zombies[i].damage * 0.5) * zombies[i].zomblevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(zombies[i].zombietype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
if ((dmg >= 100 && dmg <= 500 && dmg >= random(100, 500)) || dmg > 500)
{
int ct = clamp(dmg * 2, 0, 100);
int count = clamp(dmg / 15, 1, 5);
break_charbones(ct, dmg, random(100, 200), count);
}
}
}
}
else if (shieldon == 1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, (zombies[i].damage * zombies[i].zomblevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(zombies[i].zombietype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
zombies[i].wepsound=zombpool.play_stationary_extended(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, (zombies[i].damage * zombies[i].zomblevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(zombies[i].zombietype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
if ((dmg >= 100 && dmg <= 500 && dmg >= random(100, 500)) || dmg > 500)
{
int ct = clamp(dmg * 2, 0, 100);
int count = clamp(dmg / 15, 1, 5);
break_charbones(ct, dmg, random(100, 200), count);
}
}
zombies[i].firetimer.restart();
}
for(uint i1=0; i1<objs.length(); i1++)
{
if(objs[i1].itx==zombies[i].zombx and objs[i1].ity==zombies[i].zomby and zombies[i].firetimer.elapsed>=zombies[i].firetime and zombies[i].fireable==true)
{
zombies[i].wepsound=turpool.play_extended_2d(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*hit*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
itempool.destroy_sound(objs[i1].objsound);
objs[i1].hurtsound=itempool.play_extended_2d(get_map_sound("objects/items/"+objs[i1].objtype+"/"+objs[i1].objtype2+"/*break*"),me.x,me.y,objs[i1].itx,objs[i1].ity,0,0,0,0,false,0,0,itemvolume,itempitch,false);
zombies[i].firetimer.restart();
objs.remove_at(i1);
return;
}
}
for(uint i2=0; i2<vehicles.length(); i2++)
{
if(vehicles[i2].vehx==zombies[i].zombx and vehicles[i2].vehy==zombies[i].zomby and zombies[i].firetimer.elapsed>=zombies[i].firetime and zombies[i].fireable==true and invehicle==true)
{
vehicles[i2].hurtsound=vehpool.play_stationary_extended(get_map_sound("objects/vehicles/"+vehicles[i2].vehtype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
vehicles[i2].vehhealth-=zombies[i].damage;
zombies[i].firetimer.restart();
}
}
if(zombies[i].zombiehealth<=0)
{
if(zombies[i].zombiecard>=2 and paused==0)
{
zombpool.play_2d(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*life*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,false);
zombies[i].zombiehealth=zombies[i].zombhealth;
zombies[i].zombiecard-=1;
}
else if(zombies[i].zombiecard<=1 and paused==0)
{
zombpool.destroy_sound(zombies[i].hurtsound);
zombpool.destroy_sound(zombies[i].zombsound);
zombies[i].defsound=zombpool.play_extended_2d(get_map_sound("npc/zombies/"+zombies[i].zombietype+"/*death*"),me.x,me.y,zombies[i].zombx,zombies[i].zomby,0,0,0,0,false,0,0,painvolume,painpitch,false);
if (xpmod >= 1)
{
double gained_xp = zombies[i].zombxp * zombies[i].zomblevel * xpmod;
xp += gained_xp;
kombatlog.insert_last(gained_xp + " experience gained. Defeated " + zombies[i].zombietype + " level " + zombies[i].zomblevel + ".");
}
kills+=1;
int falldelay = round(zombpool.get_sound_length(zombies[i].defsound), 0);
spawn_bodyfall(zombies[i].zombx, zombies[i].zomby, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] heal_folders={"health", "stamina"};
string chosen_folder = random_string(heal_folders);
string[] healtypes = get_map_sound_folders("objects/items/" + chosen_folder + "/*");
if(healtypes.length()!=0 and zombies[i].dropitem==true) spawn_obj(zombies[i].zombx, zombies[i].zomby, 500, chosen_folder, random_string(healtypes), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
zombies.remove_at(i);
return;
}
}
}
}
void spawn_zombie(int x,int y,int zombierange,int zombierange2,int zombierange3,int zombierange4,double hp,double maxhp,int zc,int dm,int firetime,int zombietime,double zomblevel,double xp,string zombietype,bool fireable,bool moveable,bool moveable2,bool dropitem)
{
zombie zb1(x,y,zombierange,zombierange2,zombierange3,zombierange4,hp,maxhp,zc,dm,firetime,zombietime,zomblevel,xp,zombietype,fireable,moveable,moveable2,dropitem);
zombies.insert_last(zb1);
}
void destroy_all_zombies()
{
for(uint i=0; i<zombies.length(); i++)
{
zombpool.destroy_sound(zombies[i].zombsound);
}
zombies.resize(0);
}
