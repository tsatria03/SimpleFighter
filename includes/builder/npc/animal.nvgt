animal@[]animals(0);
class animal
{
bool dropitem, fireable, moveable, moveable2, spotted;
int amsound, defsound, hurtsound, spawnsound, stepsound, tilesound, wepsound;
int animalcard;
int anihealth;
double amlevel;
double amxp;
double animalhealth;
double animalmaxhealth;
int amx;
int amy;
int anirange;
int anirange2;
int anirange3;
int anirange4;
int damage;
int animaltime;
int firetime;
int taunttime;
string animaltype;
timer animaltimer, firetimer, taunttimer;
animal(int ax,int ay,int anrange,int anrange2,int anrange3,int anrange4,double hp,double maxhp,int ac,int dm,int ft,int sp,double amlv,double axp,string at,bool amf,bool amt,bool amt2,bool dpm)
{
this.anihealth=hp;
amx=ax;
amy=ay;
anirange=anrange;
anirange2=anrange2;
anirange3=anrange3;
anirange4=anrange4;
animalhealth=hp;
animalmaxhealth=maxhp;
animalcard=ac;
damage=dm;
firetime=ft;
animaltime=sp;
amlevel=amlv;
amxp=axp;
animaltype=at;
fireable=amf;
moveable=amt;
moveable2=amt2;
dropitem=dpm;
spawnsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animaltype+"/*spawn*"),me.x,me.y,amx,amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
}
}
void animalloop()
{
for(uint i=0; i<animals.length(); i++)
{
if(animals[i].animaltimer.elapsed>=animals[i].animaltime)
{
bool within_horizontal_range= absolute(me.x - animals[i].amx) <= animals[i].anirange3;
bool within_vertical_range= absolute(me.y - animals[i].amy) <= animals[i].anirange4;
animals[i].spotted = within_horizontal_range and within_vertical_range;
if(animals[i].spotted)
{
bool moved = false;
if(animals[i].amx<me.x && animals[i].moveable==true && paused==0)
{
if (string_contains(gmt(animals[i].amx+1, animals[i].amy), "wall", 1) > -1 or is_in_safe(animals[i].amx+1, animals[i].amy))
{
animals[i].amx--;
moved = true;
}
else
{
animals[i].amx++;
moved = true;
}
}
else if(animals[i].amx>me.x && animals[i].moveable==true && paused==0)
{
if (string_contains(gmt(animals[i].amx-1, animals[i].amy), "wall", 1) > -1 or is_in_safe(animals[i].amx-1, animals[i].amy))
{
animals[i].amx++;
moved = true;
}
else
{
animals[i].amx--;
moved = true;
}
}
if(animals[i].amy<me.y && animals[i].moveable2==true && paused==0)
{
if (string_contains(gmt(animals[i].amx, animals[i].amy+1), "wall", 1) > -1 or is_in_safe(animals[i].amx, animals[i].amy+1))
{
animals[i].amy--;
moved = true;
}
else
{
animals[i].amy++;
moved = true;
}
}
else if(animals[i].amy>me.y && animals[i].moveable2==true && paused==0)
{
if (string_contains(gmt(animals[i].amx, animals[i].amy-1), "wall", 1) > -1 or is_in_safe(animals[i].amx, animals[i].amy-1))
{
animals[i].amy++;
moved = true;
}
else
{
animals[i].amy--;
moved = true;
}
}
if (moved)
{
animals[i].tilesound = animalpool.play_extended_2d(get_map_sound("npc/animals/" + animals[i].animaltype + "/*step*"),me.x, me.y, animals[i].amx, animals[i].amy, 0, 0, 0, 0, false, 0, 0, tilevolume, tilepitch, false);
animals[i].stepsound = 1;
}
else
{
animals[i].stepsound = 0;
}
animalpool.update_sound_2d(animals[i].amsound, animals[i].amx, animals[i].amy);
animals[i].animaltimer.restart();
}
}
if (animals[i].taunttimer.elapsed >= animals[i].taunttime)
{
animals[i].amsound = animalpool.play_extended_2d(get_map_sound("npc/animals/" + animals[i].animaltype + "/*taunt*"), me.x, me.y, animals[i].amx, animals[i].amy, 0, 0, 0, 0, false, 0, 0, painvolume, painpitch, false);
int amdelay = round(animalpool.get_sound_length(animals[i].amsound), 0);
animals[i].taunttime = (amdelay <= 0 ? random(500, 1000) : amdelay);
animals[i].taunttimer.restart();
}
if(absolute(me.x-animals[i].amx)<=animals[i].anirange and absolute(me.y-animals[i].amy)<=animals[i].anirange2 and animals[i].firetimer.elapsed>=animals[i].firetime and animals[i].fireable==true and inplain==false and invehicle==false and paused==0)
{
animals[i].stepsound=0;
if(melee==true and weapontype=="melee" and wepdef==1)
{
int refchance = random(0, 100);
int refprob = 80;
if(refchance < refprob)
{
weaponslot=p.play_stationary_extended(get_pack_sound("equipments/weapons/"+weapontype+"/"+weapontype2+"/*block*"),false,0,0,weaponvolume,weaponpitch,false);
}
else
{
if(shieldon==1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, ((animals[i].damage * 0.5) * animals[i].amlevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(animals[i].animaltype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
animals[i].wepsound=animalpool.play_stationary_extended(get_map_sound("npc/animals/"+animals[i].animaltype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, ((animals[i].damage * 0.5) * animals[i].amlevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(animals[i].animaltype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
if ((dmg >= 100 && dmg <= 500 && dmg >= random(100, 500)) || dmg > 500)
{
int ct = clamp(dmg * 2, 0, 100);
int count = clamp(dmg / 15, 1, 5);
break_charbones(ct, dmg, random(100, 200), count);
}
}
}
}
else if (shieldon == 1)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, (animals[i].damage * animals[i].amlevel) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(animals[i].animaltype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else
{
animals[i].wepsound=animalpool.play_stationary_extended(get_map_sound("npc/animals/"+animals[i].animaltype+"/*hit*"),false,0,0,weaponvolume,weaponpitch,false);
int dmg = max(1, (animals[i].damage * animals[i].amlevel) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(animals[i].animaltype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = get_pack_sound("characters/" + chartype + "/*crit*");
}
else
{
painfile = get_pack_sound("characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
if ((dmg >= 100 && dmg <= 500 && dmg >= random(100, 500)) || dmg > 500)
{
int ct = clamp(dmg * 2, 0, 100);
int count = clamp(dmg / 15, 1, 5);
break_charbones(ct, dmg, random(100, 200), count);
}
}
animals[i].firetimer.restart();
}
for(uint i1=0; i1<objs.length(); i1++)
{
if(objs[i1].itx==animals[i].amx and objs[i1].ity==animals[i].amy and animals[i].firetimer.elapsed>=animals[i].firetime and animals[i].fireable==true)
{
animals[i].wepsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animals[i].animaltype+"/*hit*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,weaponvolume,weaponpitch,false);
itempool.destroy_sound(objs[i1].objsound);
objs[i1].hurtsound=itempool.play_extended_2d(get_map_sound("objects/items/"+objs[i1].objtype+"/"+objs[i1].objtype2+"/*break*"),me.x,me.y,objs[i1].itx,objs[i1].ity,0,0,0,0,false,0,0,itemvolume,itempitch,false);
animals[i].firetimer.restart();
objs.remove_at(i1);
return;
}
}
for(uint i2=0; i2<vehicles.length(); i2++)
{
if(vehicles[i2].vehx==animals[i].amx and vehicles[i2].vehy==animals[i].amy and animals[i].firetimer.elapsed>=animals[i].firetime and animals[i].fireable==true and invehicle==true)
{
vehicles[i2].hurtsound=vehpool.play_stationary_extended(get_map_sound("objects/vehicles/"+vehicles[i2].vehtype+"/*hurt*"),false,0,0,painvolume,painpitch,false);
vehicles[i2].vehhealth-=animals[i].damage;
animals[i].firetimer.restart();
}
}
if(animals[i].animalhealth<=0)
{
if(animals[i].animalcard>=2 and paused==0)
{
animalpool.play_2d(get_map_sound("npc/animals/"+animals[i].animaltype+"/*life*"),me.x,me.y,animals[i].amx,animals[i].amy,false);
animals[i].animalhealth=animals[i].anihealth;
animals[i].animalcard-=1;
}
else if(animals[i].animalcard<=1 and paused==0)
{
animalpool.destroy_sound(animals[i].hurtsound);
animalpool.destroy_sound(animals[i].amsound);
animals[i].defsound=animalpool.play_extended_2d(get_map_sound("npc/animals/"+animals[i].animaltype+"/*death*"),me.x,me.y,animals[i].amx,animals[i].amy,0,0,0,0,false,0,0,painvolume,painpitch,false);
if (xpmod >= 1)
{
double gained_xp = animals[i].amxp * animals[i].amlevel * xpmod;
xp += gained_xp;
kombatlog.insert_last(gained_xp + " experience gained. Defeated " + animals[i].animaltype + " level " + animals[i].amlevel + ".");
}
kills+=1;
int falldelay = round(animalpool.get_sound_length(animals[i].defsound), 0);
spawn_bodyfall(animals[i].amx, animals[i].amy, (falldelay <= 0 ? random(500, 1000) : falldelay));
string[] heal_folders={"health", "stamina"};
string chosen_folder = random_string(heal_folders);
string[] healtypes = get_map_sound_folders("objects/items/" + chosen_folder + "/*");
if(healtypes.length()!=0 and animals[i].dropitem==true) spawn_obj(animals[i].amx, animals[i].amy, 500, chosen_folder, random_string(healtypes), true);
if(charkillsound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*kill*"),false);
animals.remove_at(i);
return;
}
}
}
}
void spawn_animal(int x,int y,int animrange,int animrange2,int animrange3,int animrange4,double hp,double maxhp,int ac,int dm,int firetime,int animaltime,double amlevel,double xp,string animaltype,bool fireable,bool moveable,bool moveable2,bool dropitem)
{
animal an1(x,y,animrange,animrange2,animrange3,animrange4,hp,maxhp,ac,dm,firetime,animaltime,amlevel,xp,animaltype,fireable,moveable,moveable2,dropitem);
animals.insert_last(an1);
}
void destroy_all_animals()
{
for(uint i=0; i<animals.length(); i++)
{
animalpool.destroy_sound(animals[i].amsound);
}
animals.resize(0);
}
