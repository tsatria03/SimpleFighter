bool string_starts_with(const string& in str, const string& in start)
{
if (str.length()>=start.length())
{
return (str.substr(0, start.length()) == start);
}
return false;
}
bool string_ends_with(const string& in str,const string& in ending)
{
if (str.length()>=ending.length())
{
return (str.substr(str.length()-ending.length())==ending);
}
return false;
}
bool string_to_bool(string str)
{
return str.trim_whitespace().lower()=="true"? true:false;
}
bool load_map_pack(const string&in name, const string&in key)
{
    mapname = name;
    string compiled_path = "data/maps/compiled/" + name + ".map";
    if (file_exists(compiled_path))
    {
        set_sound_storage(compiled_path);
        set_sound_decryption_key(key, true);
        map_pack_loaded = true;
        return true;
    }
    else
    {
        map_pack_loaded = false;
        return false;
    }
}
bool validate_map_data(string[] lines)
{
bool has_minx = false, has_maxx = false, has_miny = false, has_maxy = false, has_owner = false;
for (uint i = 0; i < lines.length(); i++)
{
string[] parts = string_split(lines[i], " ", true);
if (parts.length() < 2) continue;
string key = string_trim_sides(parts[0]);
if (key == "minx") has_minx = true;
if (key == "maxx") has_maxx = true;
if (key == "miny") has_miny = true;
if (key == "maxy") has_maxy = true;
if (key == "owner") has_owner = true;
}
return has_minx && has_maxx && has_miny && has_maxy && has_owner;
}

float stn(string str)
{
if (string_contains(str,"random",1)>-1)
{
string a=string_replace(str,"random(","",true);
a=string_replace(a,")","",true);
string[] b=string_split(a,",",true);
double c=0;
c=random(string_to_number(b[0]),string_to_number(b[1]));
return c;
}
else
return string_to_number(str);
}

string get_new_tile(string tile,int direction)
{
string[] plats=find_directories("sounds/objects/platforms/*");
int platindex=-1;
for (uint i=0; i<plats.length(); i++)
{
if(tile==plats[i])
{
platindex=i;
break;
}
}
if(platindex==-1)
return tile;
if (direction==1)
{
if(platindex>-1)
platindex--;
if(platindex<0)
platindex=plats.length()-1;
}
else if (direction==2)
{
if(platindex>-1)
platindex++;
if(platindex>=plats.length())
platindex=0;
}
else if (direction==3)
{
if(platindex>-1)
platindex=random(0,plats.length()-1);
}
return plats[platindex];
}
string get_new_wall(string wall,int direction)
{
string[] borders=find_directories("sounds/objects/walls/*");
int wallindex=-1;
for (uint i=0; i<borders.length(); i++)
{
if(wall==borders[i])
{
wallindex=i;
break;
}
}
if(wallindex==-1)
return wall;
if (direction==1)
{
if(wallindex>-1)
wallindex--;
if(wallindex<0)
wallindex=borders.length()-1;
}
else if (direction==2)
{
if(wallindex>-1)
wallindex++;
if(wallindex>=borders.length())
wallindex=0;
}
else if (direction==3)
{
if(wallindex>-1)
wallindex=random(0,borders.length()-1);
}
return borders[wallindex];
}
string join_string_array(string[] arr, uint start, uint end)
{
string result = "";
for(uint i = start; i < end; i++)
{
if(i>start) result+=" ";
result+=arr[i];
}
return result;
}
string[] get_map_sound_folders(const string&in path)
{
    dictionary seen;
    string[] result;
    string map_path = "data/maps/decompiled/" + mapname + "/assets/" + path;
    string[] map_dirs = find_directories(map_path);
    for (uint i = 0; i < map_dirs.length(); i++)
    {
        seen[map_dirs[i]] = true;
        result.insert_last(map_dirs[i]);
    }
    string global_path = "sounds/" + soundpack + "/" + path;
    string[] global_dirs = find_directories(global_path);
    for (uint i = 0; i < global_dirs.length(); i++)
    {
        if (!seen.exists(global_dirs[i]))
            result.insert_last(global_dirs[i]);
    }
    sort_naturally(result);
    return result;
}
string get_map_sound(const string&in path)
{
    if (map_pack_loaded)
    {
        string basepath = "assets/" + path;
        string result = find_sound_in_pack(basepath);
        if (result != "")
            return result;
    }
    string soundpath = "data/maps/decompiled/" + mapname + "/assets/" + path;
    string result = find_sound_in_disk(soundpath);
    if (result != "")
        return result;
    string global_path = "sounds/" + soundpack + "/" + path;
    return find_sound_in_disk(global_path);
}

string gmt(double x, double y)
{
string mt;
for(uint i=0; i<platforms.length(); i++)
{
if(platforms[i].minx<=x and platforms[i].maxx>=x and platforms[i].miny<=y and platforms[i].maxy>=y)
{
mt=platforms[i].tile;
tilevolume=platforms[i].volume;
tilepitch=platforms[i].pitch;
}
}
for (uint i = 0; i < dest_plats.length(); i++)
{
if (dest_plats[i].minx <= x && dest_plats[i].maxx >= x && dest_plats[i].miny <= y && dest_plats[i].maxy >= y)
{
mt=dest_plats[i].plat;
tilevolume = dest_plats[i].volume;
tilepitch = dest_plats[i].pitch;
}
}
for (uint i = 0; i < dest_staircases.length(); i++)
{
if (dest_staircases[i].minx <= x && dest_staircases[i].maxx >= x && dest_staircases[i].miny <= y && dest_staircases[i].maxy >= y)
{
mt=dest_staircases[i].stairstile;
tilevolume = dest_staircases[i].volume;
tilepitch = dest_staircases[i].pitch;
}
}
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=x and walls[i].maxx>=x and walls[i].miny<=y and walls[i].maxy>=y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
}
}
return mt;
}
string gct(double x, double y)
{
string ct;
for(uint i=0; i<platforms.length(); i++)
{
if(platforms[i].minx<=x and platforms[i].maxx>=x and platforms[i].miny<=y and platforms[i].maxy>=y)
{
ct=platforms[i].tile;
tilevolume=platforms[i].volume;
tilepitch=platforms[i].pitch;
}
}
for (uint i = 0; i < dest_plats.length(); i++)
{
if (dest_plats[i].minx <= x && dest_plats[i].maxx >= x && dest_plats[i].miny <= y && dest_plats[i].maxy >= y)
{
ct=dest_plats[i].plat;
tilevolume = dest_plats[i].volume;
tilepitch = dest_plats[i].pitch;
}
}
for(uint i=0; i<walls.length(); i++)
{
if(walls[i].minx<=x and walls[i].maxx>=x and walls[i].miny<=y and walls[i].maxy>=y)
{
wallvolume=walls[i].volume;
wallpitch=walls[i].pitch;
}
}
return ct;
}

string[] delinear(string a)
{
return string_split(a, "\r\n", false);
}
string linear(string[] a)
{
string final;
for(uint i=0; i<a.length(); i++)
{
final+=(a[i]+"\r\n");
}
return final;
}
void filter_empty_lines(string[] lines, string[]& filtered_lines, uint[]& original_lines)
{
filtered_lines.resize(0);
original_lines.resize(0);
for (uint i=0; i<lines.length(); i++)
{
if (lines[i].length()>0)
{
filtered_lines.insert_last(lines[i]);
original_lines.insert_last(i);
}
}
}

void get_all_platform_tiles(double x, double y, array<string>@ tiles, array<double>@ volumes, array<double>@ pitches)
{
for (uint i = 0; i < platforms.length(); i++)
{
if (platforms[i].minx <= x && platforms[i].maxx >= x && platforms[i].miny <= y && platforms[i].maxy >= y)
{
tiles.insert_last(platforms[i].tile);
volumes.insert_last(platforms[i].volume);
pitches.insert_last(platforms[i].pitch);
}
}
}
void get_all_wall_tiles(double x, double y, array<string>@ walls_out, array<double>@ volumes, array<double>@ pitches)
{
for (uint i = 0; i < walls.length(); i++)
{
if (walls[i].minx <= x && walls[i].maxx >= x && walls[i].miny <= y && walls[i].maxy >= y)
{
walls_out.insert_last(walls[i].wall);
volumes.insert_last(walls[i].volume);
pitches.insert_last(walls[i].pitch);
}
}
}

void compile_map()
{
    filename = input_box("Map Compiler", "Enter the name of the map file to create. Example, main.map.");
    if (filename == "")
    {
        alert("Error", "You may not compile an empty map!");
        mapmenu();
    }
    if (!string_ends_with(filename, ".map"))
        filename += ".map";
    string full_output_path = "data/maps/compiled/" + filename;
    if (!directory_exists("data/maps/compiled"))
        directory_create("data/maps/compiled");
    foldername = input_box("Map Compiler", "Enter the path containing files to compile. Example, main.");
    if (foldername == "")
        mapmenu();
if (!string_starts_with(foldername, "data/maps/decompiled/"))
    foldername = "data/maps/decompiled/" + foldername;
    if (!directory_exists(foldername))
    {
        alert("Error", "Folder does not exist!");
        mapmenu();
    }
    if (!pfile.open(full_output_path, PACK_OPEN_MODE_CREATE))
    {
        alert("Error", "Failed to create map file at: " + full_output_path);
        mapmenu();
    }
file_list.resize(0);
    find_stuff(foldername, foldername);
    alert("Map Compiler", "There are " + file_list.length() + " files in the map. Press OK to start compiling!");
show_window("Compiling map.");
wait(5);
    int percent = -1;
    for (uint i = 0; i < file_list.length(); i++)
    {
        double progress = (double(i) / double(file_list.length())) * 100.0;
        int rounded = int(progress);
        if (rounded != percent)
        {
            percent = rounded;
            beep_percentage(percent);
        }
        string relative = string_replace(file_list[i], foldername + "/", "", true);
        pfile.add_file(file_list[i], relative);
    }
    pfile.close();
    alert("Success!", "Map compiled to " + full_output_path);
show_window("Simple fighter, version "+version);
    mapmenu();
}
void decompile_map()
{
    filename = input_box("Map Decompiler", "Enter the name of the map file to decompile. Example, main.map.");
    if (filename == "")
    {
        alert("Error", "You may not decompile an empty map!");
        mapmenu();
    }
    if (!string_starts_with(filename, "data/maps/compiled/"))
        filename = "data/maps/compiled/" + filename;
    if (!pfile.open(filename, PACK_OPEN_MODE_READ))
    {
        alert("Error", "Could not open the specified map file: " + filename);
        mapmenu();
    }
    contents = pfile.list_files();
    if (contents.length() == 0)
    {
        alert("Error", "No files found in this map.");
        mapmenu();
    }
    alert("Get Ready", contents.length() + " files are about to be extracted!");
    if (!directory_exists("data/maps/decompiled"))
        directory_create("data/maps/decompiled");
string base_name = strip_extension(strip_directory(filename));
    string base_dir = "data/maps/decompiled/" + base_name;
    if (!directory_exists(base_dir))
        directory_create(base_dir);
show_window("Decompiling map.");
wait(5);
    double prev_percent = -1;
    for (uint i = 0; i < contents.length(); i++)
    {
        double percent = ((i + 1.0) / contents.length()) * 100.0;
        percent = round(percent, 0);
        if (percent != prev_percent)
        {
            beep_percentage(int(percent));
            prev_percent = percent;
        }
        string relative_path = contents[i];
        string output_path = base_dir + "/" + relative_path;
        create_subfolders(output_path);
        extract_file(pfile, relative_path, output_path);
    }
    pfile.close();
    alert("Success", "Extraction completed. " + contents.length() + " files extracted to " + base_dir);
show_window("Simple fighter, version "+version);
    mapmenu();
}

