void load_map(string name, string owner, bool instent_update=true, bool speak_percentage=false, bool anounce_mapload=true, int loadtime=50, int loadbeeps=maploadbeeps, int loadsounds=maploadsounds, bool force_compiled=false, bool force_spawned=false)
{
    mapname = name;
    mapowner = owner;
    maploadbeeps = loadbeeps;
    maploadsounds = loadsounds;
    clearmap();
    destroymap();
    if (string_ends_with(mapname, ".sif"))
        mapname = string_replace(mapname, ".sif", "", true);
    if (string_ends_with(mapname, ".map"))
        mapname = string_replace(mapname, ".map", "", true);
    string decompiled_info_path = "data/maps/decompiled/" + mapname + "/info.sif";
    string compiled_path = "data/maps/compiled/" + mapname + ".map";
    string mapdata = "";
    bool loaded = false;
    map_is_compiled = false;
    if (!force_compiled && file_exists(decompiled_info_path))
    {
        set_sound_storage("");
        set_sound_decryption_key("", true);
        map_pack_loaded = false;
        mapper.open(decompiled_info_path, "rb");
        mapdata = mapper.read();
        mapper.close();
        loaded = true;
        map_is_compiled = false;
    }
    else if (file_exists(compiled_path))
    {
        if (!load_map_pack(mapname, ""))
        {
            dlg_snd("Error: Map failed to load.");
            mapmenu();
        }
        if (map_pack.open(compiled_path, PACK_OPEN_MODE_READ))
        {
            if (map_pack.file_exists("info.sif"))
            {
                uint size = map_pack.get_file_size("info.sif");
                mapdata = map_pack.read_file("info.sif", 0, size);
                loaded = true;
                map_is_compiled = true;
            }
            map_pack.close();
        }
    }
    if (!loaded)
    {
        dlg_snd("Error: Map not found or missing info.sif.");
        mapmenu();
    }
sound mapload;
timer maploadtimer;
if(anounce_mapload==true) speak("loading map");
if(loadsounds==1) mpool.play_stationary(get_pack_sound("map/"+maptype+"/player/*start*"),false);
if(loadsounds==1) mapload.load(get_pack_sound("map/"+maptype+"/player/*load*"));
if(loadsounds==1) mapload.play_looped();
string[] lines=delinear(mapdata);
double percent=0;
double last_beep_percent=-1;
for (uint i=0; i<lines.length(); i++)
{
if(loadbeeps == 1)
{
double l=lines.length(), ind=i;
int current_percent=int(ind/l*100);
if(current_percent>last_beep_percent && maploadtimer.elapsed>=loadtime)
{
if(speak_percentage==true) speak(current_percent+" percent");
beep_percentage(current_percent);
last_beep_percent=current_percent;
maploadtimer.restart();
}
}        
if(!instent_update)
{
wait(5);
}
string[] sd=string_split(lines[i], " ", true);
if(sd[0]=="minx" && sd.length()==2)
{
minx=stn(sd[1]);
}
else if(sd[0]=="maxx" && sd.length()==2)
{
maxx=stn(sd[1]);
}
else if(sd[0]=="miny" && sd.length()==2)
{
miny=stn(sd[1]);
}
else if(sd[0]=="maxy" && sd.length()==2)
{
maxy=stn(sd[1]);
}
else if(sd[0]=="owner" && sd.length()==2)
{
mapowner=sd[1];
}
else if(sd[0]=="platform" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double hp=stn(sd[4]);
string tiletype=sd[5];
double tilevol=stn(sd[6]);
double tilepitch=stn(sd[7]);
bool dbl=string_to_bool(sd[8]);
spawn_platform(mx, mx2, my, my, hp, hp, tiletype, tilevol, tilepitch, dbl);
}
else if(sd[0]=="staircase" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
string tiletype=sd[6];
double stairsvol=stn(sd[7]);
double stairspitch=stn(sd[8]);
bool dbl=string_to_bool(sd[9]);
spawn_staircase(mx, mx2, my, my2, hp, hp, tiletype, stairsvol, stairspitch, dbl);
}
else if(sd[0]=="vanishing_hazard" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string hazardtype=sd[5];
int sp=stn(sd[6]);
spawn_vanishing_hazard(mx, mx2, my, my2, hazardtype, sp);
}
else if(sd[0]=="vanishing_platform" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
string tiletype=sd[4];
double tilevol=stn(sd[5]);
double tilepitch=stn(sd[6]);
string vplattype=sd[7];
double vplatvol=stn(sd[8]);
double vplatpitch=stn(sd[9]);
int sp=stn(sd[10]);
spawn_vanishing_platform(mx, mx2, my, my, tiletype, tilevol, tilepitch, vplattype, vplatvol, vplatpitch, sp);
}
else if(sd[0]=="wall" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
string walltype=sd[6];
double wallvol=stn(sd[7]);
double wallpitch=stn(sd[8]);
bool dbl=string_to_bool(sd[9]);
spawn_wall(mx, mx2, my, my2, hp, hp, walltype, wallvol, wallpitch, dbl);
}
else if(sd[0]=="blockage" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_blockage(mx, mx2, my, my2, txt);
}
else if(sd[0]=="door" && sd.length()==14)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string lotype=sd[7];
string motype=sd[8];
string optype=sd[9];
string cotype=sd[10];
string dotype=sd[11];
bool amt=string_to_bool(sd[12]);
bool dbl=string_to_bool(sd[13]);
spawn_door(sx, sy, sx2, sy2, hp, hp, sp, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="psdoor" && sd.length()==15)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
double hp=stn(sd[5]);
int sp=stn(sd[6]);
string drpass=sd[7];
string lotype=sd[8];
string motype=sd[9];
string optype=sd[10];
string cotype=sd[11];
string dotype=sd[12];
bool amt=string_to_bool(sd[13]);
bool dbl=string_to_bool(sd[14]);
spawn_psdoor(sx, sy, sx2, sy2, hp, hp, sp, drpass, lotype, motype, optype, cotype, dotype, amt, dbl);
}
else if(sd[0]=="elevator" && sd.length()>=11)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int sp=stn(sd[3]);
string txt=join_string_array(sd, 4, sd.length()-6);
string ellotype=sd[sd.length()-6];
string elmotype=sd[sd.length()-5];
string eloptype=sd[sd.length()-4];
string elcotype=sd[sd.length()-3];
string elbetype=sd[sd.length()-2];
bool fsp=string_to_bool(sd[sd.length()-1]);
spawn_elevator(x, y, sp, txt, ellotype, elmotype, eloptype, elcotype, elbetype, fsp);
}
else if(sd[0]=="el_floor" && sd.length()>=5)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
string txt=join_string_array(sd, 4, sd.length());
spawn_el_floor(mx, mx2, y, txt);
}
else if(sd[0]=="passage" && sd.length()==11)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
string tiletype=sd[5];
string lotype=sd[6];
string optype=sd[7];
string cotype=sd[8];
int sp=stn(sd[9]);
int sp2=stn(sd[10]);
spawn_passage(sx, sy, dir, lt, tiletype, lotype, optype, cotype, sp, sp2);
}
else if(sd[0]=="pspassage" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int dir=stn(sd[3]);
int lt=stn(sd[4]);
string tiletype=sd[5];
string lotype=sd[6];
string optype=sd[7];
string cotype=sd[8];
string pspass=sd[9];
int sp=stn(sd[10]);
int sp2=stn(sd[11]);
spawn_pspassage(sx, sy, dir, lt, tiletype, lotype, optype, cotype, pspass, sp, sp2);
}
else if(sd[0]=="menu_zone" && sd.length()==5)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
spawn_menuzone(mx, mx2, my, my2);
}
else if(sd[0]=="safe_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string safetype=sd[5];
spawn_safezone(mx, mx2, my, my2, safetype);
}
else if(sd[0]=="zone" && sd.length()>=6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length());
spawn_zone(mx, mx2, my, my2, txt);
}
else if(sd[0]=="reverb" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string id=sd[5];
float dry=stn(sd[6]);
float wet=stn(sd[7]);
float size=stn(sd[8]);
float damp=stn(sd[9]);
float width=stn(sd[10]);
spawn_reverb_space(mx, mx2, my, my2, id, dry, wet, size, damp, width);
}
else if(sd[0]=="text_square" && sd.length()>=4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length());
spawn_text_square(x, y, txt);
}
else if(sd[0]=="clock" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string clocktype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_clock(x, y, txt, clocktype, dbl);
}
else if(sd[0]=="calendar" && sd.length()>=6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-2);
string calandertype=sd[sd.length()-2];
bool dbl=string_to_bool(sd[sd.length()-1]);
spawn_calendar(x, y, txt, calandertype, dbl);
}
else if(sd[0]=="chblocker" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string[] chsets = string_split(join_string_array(sd, 5, sd.length() - 1), ", ", true);
bool wtl = string_to_bool(sd[sd.length() - 1]);
spawn_chblocker(mx, mx2, my, my2, chsets, wtl);
}
else if(sd[0]=="cblocker" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string[] coms = string_split(join_string_array(sd, 5, sd.length() - 1), ", ", true);
bool wtl = string_to_bool(sd[sd.length() - 1]);
spawn_cblocker(mx, mx2, my, my2, coms, wtl);
}
else if(sd[0]=="ex_ambience" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
double mx3=stn(sd[9]);
double mx4=stn(sd[10]);
double my3=stn(sd[11]);
double my4=stn(sd[12]);
spawn_ex_ambsource(mx, mx2, my, my2, sorcetype, sorcetype2, soundvol, soundpitch, mx3, mx4, my3, my4);
}
else if(sd[0]=="ex_source" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
double mx3=stn(sd[9]);
double mx4=stn(sd[10]);
double my3=stn(sd[11]);
double my4=stn(sd[12]);
spawn_ex_soundsource(mx, mx2, my, my2, sorcetype, sorcetype2, soundvol, soundpitch, mx3, mx4, my3, my4);
}
else if(sd[0]=="sound_ambience" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
spawn_ambsource(mx, mx2, my, my2, sorcetype, sorcetype2, soundvol, soundpitch);
}
else if(sd[0]=="sound_source" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
spawn_soundsource(mx, mx2, my, my2, sorcetype, sorcetype2, soundvol, soundpitch);
}
else if(sd[0]=="timebomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string timbotype=sd[5];
spawn_timebomb(x, y, dmg, sp, timbotype);
}
else if(sd[0]=="timed_ambience" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
int sourcetime=stn(sd[9]);
spawn_timedamb(mx, mx2, my, my2, soundvol, soundpitch, sourcetime, sorcetype, sorcetype2);
}
else if(sd[0]=="timed_source" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string sorcetype=sd[5];
string sorcetype2=sd[6];
double soundvol=stn(sd[7]);
double soundpitch=stn(sd[8]);
int sourcetime=stn(sd[9]);
spawn_timedsource(mx, mx2, my, my2, soundvol, soundpitch, sourcetime, sorcetype, sorcetype2);
}
else if(sd[0]=="timed_text" && sd.length()>=7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int texttime=stn(sd[5]);
string txt=join_string_array(sd, 6, sd.length());
spawn_timedtext(mx, mx2, my, my2, texttime, txt);
}
else if(sd[0]=="heal_zone" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int hm=stn(sd[5]);
int hp=stn(sd[6]);
int ht=stn(sd[7]);
string hlt=sd[8];
spawn_healzone(mx, mx2, my, my2, hm, hp, ht,hlt);
}
else if(sd[0]=="hazard" && sd.length()==7)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string hazardtype=sd[5];
bool lgp=string_to_bool(sd[6]);
spawn_hazard(mx, mx2, my, my2, hazardtype, lgp);
}
else if(sd[0]=="lift" && sd.length()==13)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
double tilevol=stn(sd[8]);
double tilepitch=stn(sd[9]);
string lifttype=sd[10];
double liftvol=stn(sd[11]);
double liftpitch=stn(sd[12]);
spawn_lift(mx, mx2, my, my2, dir, sp, tiletype, tilevol, tilepitch, lifttype, liftvol, liftpitch);
}
else if(sd[0]=="mine" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
string minetype=sd[4];
bool tg=string_to_bool(sd[5]);
spawn_mine(x, y, dmg, minetype, tg);
}
else if(sd[0]=="mhazard" && sd.length()==11)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
double sy=stn(sd[6]);
int dir=stn(sd[7]);
int dir2=stn(sd[8]);
int sp=stn(sd[9]);
string hazardtype=sd[10];
spawn_moving_hazard(mx, mx2, my, my2, sx, sy, dir, dir2, sp, hazardtype);
}
else if(sd[0]=="mplatform" && sd.length()==16)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double sx=stn(sd[5]);
int dir=stn(sd[6]);
int dir2=stn(sd[7]);
int sp=stn(sd[8]);
string tiletype=sd[9];
double tilevol=stn(sd[10]);
double tilepitch=stn(sd[11]);
string mplattype=sd[12];
double mplatvol=stn(sd[13]);
double mplatpitch=stn(sd[14]);
int vs=stn(sd[15]);
spawn_moving_platform(mx, mx2, my, my2, sx, dir, dir2, sp, tiletype, tilevol, tilepitch, mplattype, mplatvol, mplatpitch, vs);
}
else if(sd[0]=="sign" && sd.length()>=7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string txt=join_string_array(sd, 3, sd.length()-3);
string signtype=sd[sd.length()-3];
bool dbl=string_to_bool(sd[sd.length()-2]);
bool lps=string_to_bool(sd[sd.length()-1]);
spawn_sign(x, y, txt, signtype, dbl, lps);
}
else if(sd[0]=="checkpoint" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int checktime=stn(sd[3]);
string checktype=sd[4];
spawn_checkpoint(x, y, checktime, checktype);
}
else if(sd[0]=="dialog" && sd.length()>=8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string txt=join_string_array(sd, 5, sd.length()-2);
string dlgtype=sd[sd.length()-2];
dlgtyp=dlgtype;
bool dlm=string_to_bool(sd[sd.length()-1]);
spawn_dialog(mx, mx2, my, my2, txt, dlgtype, dlm);
}
else if(sd[0]=="item" && sd.length()==7)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int objtime=stn(sd[3]);
string objtype=sd[4];
string objtype2=sd[5];
bool automatic=string_to_bool(sd[6]);
spawn_obj(x, y, objtime, objtype, objtype2, automatic);
}
else if(sd[0]=="item_zone" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int sp=stn(sd[5]);
string objtype=sd[6];
string objtype2=sd[7];
spawn_objzone(mx, mx2, my, my2, sp, objtype, objtype2);
}
else if(sd[0]=="spike" && sd.length()==10)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
double hp=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
string spiketype=sd[8];
bool dbl=string_to_bool(sd[9]);
spawn_spike(mx, mx2, my, my2, hp, hp, dmg, sp, spiketype, dbl);
}
else if(sd[0]=="spawnpoint" && sd.length()==3)
{
int spx=stn(sd[1]);
int spy=stn(sd[2]);
create_spawnpoint(spx, spy);
}
else if(sd[0]=="travelpoint" && sd.length()>=9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
string destmap=sd[5];
int destx=stn(sd[6]);
int desty=stn(sd[7]);
string endtext=sd[8];
spawn_travelpoint(mx, mx2, my, my2, destmap, destx, desty, endtext);
}
else if(sd[0]=="aircraft" && sd.length()==5)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
string airtype=sd[4];
plaintyp=airtype;
spawn_aircraft(x, y, hp, hp, airtype);
}
else if(sd[0]=="airbeacon" && sd.length()==3)
{
int x=stn(sd[1]);
int w=stn(sd[2]);
spawn_airbeacon(x, 0, w);
}
else if(sd[0]=="animal" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int anirange=stn(sd[3]);
int anirange2=stn(sd[4]);
int anirange3=stn(sd[5]);
int anirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string amtype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_animal(x, y, anirange, anirange2, anirange3, anirange4, hp, hp, card, dmg, ft, sp, lv, xp, amtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="camera" && sd.length()==11)
{
int camx=stn(sd[1]);
int cammy=stn(sd[2]);
int cammer=stn(sd[3]);
int cammer2=stn(sd[4]);
int camdir=stn(sd[5]);
int camtime=stn(sd[6]);
double camhp=stn(sd[7]);
double camlev=stn(sd[8]);
double camxp=stn(sd[9]);
string camtype=sd[10];
spawn_camera(camx, cammy, cammer, cammer2, camdir, camtime, camhp, camhp, camlev, camxp, camtype);
}
else if(sd[0]=="human" && sd.length()==20)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int humrange=stn(sd[3]);
int humrange2=stn(sd[4]);
int humrange3=stn(sd[5]);
int humrange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int dc=stn(sd[10]);
int ft=stn(sd[11]);
int sp=stn(sd[12]);
double lv=stn(sd[13]);
double xp=stn(sd[14]);
string humtype=sd[15];
bool fb=string_to_bool(sd[16]);
bool mb=string_to_bool(sd[17]);
bool mb2=string_to_bool(sd[18]);
bool dpm=string_to_bool(sd[19]);
spawn_human(x, y, humrange, humrange2, humrange3, humrange4, hp, hp, card, dmg, dc, ft, sp, lv, xp, humtype, fb, mb, mb2, dpm);
}
else if(sd[0]=="floor_breaker" && sd.length()==4)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
string floorbtype=sd[3];
spawn_floorbreaker(x, y, floorbtype);
}
else if(sd[0]=="fire" && sd.length()==9)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int firerange=stn(sd[3]);
int firerange2=stn(sd[4]);
int sp=stn(sd[5]);
string firetype=sd[6];
bool mb=string_to_bool(sd[7]);
bool mb2=string_to_bool(sd[8]);
spawn_fire(sx, sy, firerange, firerange2, sp, firetype, mb, mb2);
}
else if(sd[0]=="forcefield" && sd.length()==8)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dmg=stn(sd[5]);
int sp=stn(sd[6]);
string forcetype=sd[7];
spawn_forcefield(mx, mx2, my, my2, dmg, sp, forcetype);
}
else if(sd[0]=="helper" && sd.length()==10)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
string helptyp=sd[9];
spawn_helper(x, y, hp, hp, card, dmg, ft, sp, lv, helptyp);
}
else if(sd[0]=="projectile" && sd.length()==13)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dir=stn(sd[3]);
double hp=stn(sd[4]);
int card=stn(sd[5]);
int dmg=stn(sd[6]);
int sp=stn(sd[7]);
double lv=stn(sd[8]);
double xp=stn(sd[9]);
string potype=sd[10];
bool fb=string_to_bool(sd[11]);
bool mb=string_to_bool(sd[12]);
spawn_projectile(x, y, dir, hp, hp, card, dmg, sp, lv, xp, potype, fb, mb);
}
else if(sd[0]=="robot" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int roborange=stn(sd[3]);
int roborange2=stn(sd[4]);
int roborange3=stn(sd[5]);
int roborange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string rotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_robot(x, y, roborange, roborange2, roborange3, roborange4, hp, hp, card, dmg, ft, sp, lv, xp, rotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="turret" && sd.length()==17)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int card=stn(sd[4]);
int dmg=stn(sd[5]);
int ft=stn(sd[6]);
int lt=stn(sd[7]);
int sp=stn(sd[8]);
double lv=stn(sd[9]);
double xp=stn(sd[10]);
string tutype=sd[11];
string tutype2=sd[12];
string tutype3=sd[13];
bool fb=string_to_bool(sd[14]);
bool mb=string_to_bool(sd[15]);
bool mb2=string_to_bool(sd[16]);
spawn_turret(x, y, hp, hp, card, dmg, ft, lt, sp, lv, xp, tutype, tutype2, tutype3, fb, mb, mb2);
}
else if(sd[0]=="zombie" && sd.length()==19)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int zombirange=stn(sd[3]);
int zombirange2=stn(sd[4]);
int zombirange3=stn(sd[5]);
int zombirange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int sp=stn(sd[11]);
double lv=stn(sd[12]);
double xp=stn(sd[13]);
string zotype=sd[14];
bool fb=string_to_bool(sd[15]);
bool mb=string_to_bool(sd[16]);
bool mb2=string_to_bool(sd[17]);
bool dpm=string_to_bool(sd[18]);
spawn_zombie(x, y, zombirange, zombirange2, zombirange3, zombirange4, hp, hp, card, dmg, ft, sp, lv, xp, zotype, fb, mb, mb2, dpm);
}
else if(sd[0]=="animal_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string amtype=sd[5];
spawn_animalzone(mx, mx2, y, sp, amtype);
}
else if(sd[0]=="bike" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int sp=stn(sd[4]);
string biktyp=sd[5];
spawn_bike(x, y, hp, hp, sp, biktyp);
}
else if(sd[0]=="bomb" && sd.length()==6)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int dmg=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bomb(x, y, dmg, sp, botype);
}
else if(sd[0]=="bomb_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string botype=sd[5];
spawn_bombzone(mx, mx2, y, sp, botype);
}
else if(sd[0]=="boss" && sd.length()==27)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
int boserange=stn(sd[3]);
int boserange2=stn(sd[4]);
int boserange3=stn(sd[5]);
int boserange4=stn(sd[6]);
double hp=stn(sd[7]);
int card=stn(sd[8]);
int dmg=stn(sd[9]);
int ft=stn(sd[10]);
int lt=stn(sd[11]);
int sp=stn(sd[12]);
int tt=stn(sd[13]);
int ht=stn(sd[14]);
double lv=stn(sd[15]);
double xp=stn(sd[16]);
string bosstyp=sd[17];
string bosstyp2=sd[18];
string bosstyp3=sd[19];
bool fb=string_to_bool(sd[20]);
bool mb=string_to_bool(sd[21]);
bool mb2=string_to_bool(sd[22]);
bool tb=string_to_bool(sd[23]);
bool tb2=string_to_bool(sd[24]);
bool hb=string_to_bool(sd[25]);
bool dpm=string_to_bool(sd[26]);
spawn_boss(x, y, boserange, boserange2, boserange3, boserange4, hp, hp, card, dmg, ft, lt, sp, tt, ht, lv, xp, bosstyp, bosstyp2, bosstyp3, fb, mb, mb2, tb, tb2, hb, dpm);
}
else if(sd[0]=="belt" && sd.length()==9)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
double my=stn(sd[3]);
double my2=stn(sd[4]);
int dir=stn(sd[5]);
int sp=stn(sd[6]);
string tiletype=sd[7];
string belttyp=sd[8];
spawn_belt(mx, mx2, my, my2, dir, sp, tiletype, belttyp);
}
else if(sd[0]=="human_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string emtype=sd[5];
spawn_humanzone(mx, mx2, y, sp, emtype);
}
else if(sd[0]=="projectile_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string potype=sd[5];
spawn_projzone(mx, mx2, y, sp, potype);
}
else if(sd[0]=="robot_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string rotype=sd[5];
spawn_robotzone(mx, mx2, y, sp, rotype);
}
else if(sd[0]=="switch" && sd.length()==6)
{
int scx=stn(sd[1]);
int scy=stn(sd[2]);
string sct=sd[3];
bool tg=string_to_bool(sd[4]);
bool scl=string_to_bool(sd[5]);
spawn_switcher(scx, scy, sct, tg, scl);
}
else if(sd[0]=="teleporter" && sd.length()==12)
{
int sx=stn(sd[1]);
int sy=stn(sd[2]);
int sx2=stn(sd[3]);
int sy2=stn(sd[4]);
int telrange=stn(sd[5]);
int telrange2=stn(sd[6]);
int sp=stn(sd[7]);
string teltype=sd[8];
bool mb=string_to_bool(sd[9]);
bool mb2=string_to_bool(sd[10]);
bool ss=string_to_bool(sd[11]);
spawn_teleporter(sx, sy, sx2, sy2, telrange, telrange2, sp, teltype, mb, mb2, ss);
}
else if(sd[0]=="vehicle" && sd.length()==10)
{
int x=stn(sd[1]);
int y=stn(sd[2]);
double hp=stn(sd[3]);
int dmg=stn(sd[4]);
int sp=stn(sd[5]);
int sp2=stn(sd[6]);
int sp3=stn(sd[7]);
string vehtyp=sd[8];
bool fb=string_to_bool(sd[9]);
spawn_vehicle(x, y, hp, hp, dmg, sp, sp2, sp3, vehtyp, fb);
}
else if(sd[0]=="zombie_zone" && sd.length()==6)
{
double mx=stn(sd[1]);
double mx2=stn(sd[2]);
int y=stn(sd[3]);
int sp=stn(sd[4]);
string zotype=sd[5];
spawn_zombiezone(mx, mx2, y, sp, zotype);
}
if (force_spawned)
{
    if (last_spawnpoint !is null)
    {
        me.x = last_spawnpoint.spawnx;
        me.y = last_spawnpoint.spawny;
    }
    else if (spawnpoints.length() > 0)
    {
        me.x = spawnpoints[0].spawnx;
        me.y = spawnpoints[0].spawny;
    }
}
cammable = true;
jumpable = true;
moveable = true;
quittable=true;
speedable = true;
spiable=true;
turnable = true;
telable = true;
}
if(loadsounds==1) mapload.stop();
if(loadsounds==1) mpool.play_stationary(get_pack_sound("map/"+maptype+"/player/*stop*"),false);
if(loadbeeps == 1 && last_beep_percent<100)
{
if(speak_percentage==true) speak("100 "+"percent");
if(loadbeeps == 1) beep_percentage(100);
}
if(anounce_mapload==true) speak("map loded.");
}
