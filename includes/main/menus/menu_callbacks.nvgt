string charsmenu(bool ingame=false)
{
string[] chars=get_pack_sound_folders("characters/*");
setupmenu();
m.set_callback(@chars_callback,"");
for (uint i=0; i<chars.length(); i++)
{
m.add_item_tts(chars[i],chars[i],"",true);
}
int mres=m.run("Character themes menu", true);
if(mres==0)
{
speak("canceled");
if(ingame==false) settingsmenu();
if(ingame==true) game();
}
if(mres>0 and mres<=chars.length())
{
chartype=chars[mres-1];
destroy_all_charas();
charparse();
if(ingame==false)
{
dlg("Character set. Press enter to continue.");
settingsmenu();
}
else if(ingame==true)
{
speak("Character set to "+chartype+".");
writepreffs();
game();
}
}
return m.get_item_name(mres);
}
int chars_callback(dynamic_menu_pro@ m, string data)
{
string chars;
if(m.menu_position>0)
chars=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("characters/"+chars+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("characters/"+chars+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_D) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_D) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("characters/"+chars+"/*death*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_J) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_J) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("characters/"+chars+"/*jump*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_U) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_U) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("characters/"+chars+"/*turn*"), false);
}
return 0;
}
string keyboardchoosers()
{
string[] keyboardchanges=get_pack_sound_folders("keyboards/*");
setupmenu();
m.set_callback(@keyboardchanges_callback,"");
for (uint i=0; i<keyboardchanges.length(); i++)
{
m.add_item_tts(keyboardchanges[i],keyboardchanges[i],"",true);
}
int mres=m.run("Choose the keyboard theme you'd like to use in all input boxes.",true);
if(mres==0)
{
speak("canceled");
settingsmenu();
}
if(mres>0 and mres<=keyboardchanges.length())
{
keyboardtheme=keyboardchanges[mres-1];
dlg("Keyboard theme set. Press enter to continue.");
settingsmenu();
}
return m.get_item_name(mres);
}
int keyboardchanges_callback(dynamic_menu_pro@ m, string data)
{
string keyboardchanges;
if(m.menu_position>0)
keyboardchanges=m.item_list[m.menu_position-1].name;
if(key_down(KEY_LCONTROL) and key_repeating(KEY_T) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_T) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("keyboards/"+keyboardchanges+"/*type*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_S) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_S) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("keyboards/"+keyboardchanges+"/*space*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_R) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_R) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("keyboards/"+keyboardchanges+"/*return*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_D) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_D) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("keyboards/"+keyboardchanges+"/*delete*"),false);
}
return 0;
}
string mapchoosers()
{
string[] mapchanges=get_pack_sound_folders("map/*");
setupmenu();
m.set_callback(@mapchanges_callback,"");
for (uint i=0; i<mapchanges.length(); i++)
{
m.add_item_tts(mapchanges[i],mapchanges[i],"",true);
}
int mres=m.run("Map themes menu.",true);
if(mres==0)
{
speak("canceled");
settingsmenu();
}
if(mres>0 and mres<=mapchanges.length())
{
maptype=mapchanges[mres-1];
dlg("Map theme set. Press enter to continue.");
settingsmenu();
}
return m.get_item_name(mres);
}
int mapchanges_callback(dynamic_menu_pro@ m, string data)
{
string mapchanges;
if(m.menu_position>0)
mapchanges=m.item_list[m.menu_position-1].name;
if(key_down(KEY_LCONTROL) and key_repeating(KEY_D) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_D) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*delete*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_F) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_F) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*finish*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*load*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_M) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_M) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*move*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_S) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_S) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*Start*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_P) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_P) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*stop*"),false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_U) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_U) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("map/"+mapchanges+"/player/*update*"),false);
}
return 0;
}
string menuchoosers()
{
string[] menuchanges=get_pack_sound_folders("menus/*");
setupmenu();
m.set_callback(@menuchanges_callback,"");
for (uint i=0; i<menuchanges.length(); i++)
{
m.add_item_tts(menuchanges[i],menuchanges[i],"",true);
}
int mres=m.run("Choose the menu theme you'd like to use in all menus.",true);
if(mres==0)
{
speak("canceled");
settingsmenu();
}
if(mres>0 and mres<=menuchanges.length())
{
menutype=menuchanges[mres-1];
dlg("Menu sounds set. Press enter to continue.");
settingsmenu();
}
return m.get_item_name(mres);
}
int menuchanges_callback(dynamic_menu_pro@ m, string data)
{
string menuchanges;
if(m.menu_position>0)
menuchanges=m.item_list[m.menu_position-1].name;
if(key_down(KEY_LCONTROL) and key_repeating(KEY_C) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_C) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*click*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*close*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_D) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_D) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*edge*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_N) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_N) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*enter*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_O) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_O) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*open*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_P) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_P) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("menus/"+menuchanges+"/*wrap*"), false);
}
return 0;
}

string archersmenu()
{
    string[] archers =get_pack_sound_folders("equipments/weapons/archery/*");
    setupmenu();
    m.set_callback(@archers_callback, "");
    for (uint i = 0; i < archers.length(); i++)
    {
        string weapon_name = archers[i];
        string info_path = "data/layouts/weapons/archery/" + weapon_name + "/info.sif";
        double unlock_level = 0;
        if (file_exists(info_path))
        {
            file f;
            f.open(info_path, "rb");
            string[] lines = string_split(f.read(), "\r\n", true);
            f.close();
            for (uint j = 0; j < lines.length(); j++)
            {
                string[] kv = string_split(lines[j], "=", true);
                if (kv.length() == 2 && kv[0] == "unlock level")
                {
                    unlock_level = parse_double(kv[1]);
                    break;
                }
            }
        }
        bool is_unlocked = level >= unlock_level;
string label = weapon_name;
if (!is_unlocked)
    label += " (Unlocked at level " + int_to_string(int(unlock_level)) + ")";
        m.add_item_tts(label, weapon_name, "", is_unlocked);
    }
    int mres = m.run("Archery menu", true);
    if (mres == 0) weaponsmenu();
    if (mres > 0 && mres <= archers.length())
    {
        resume_pools();
        weapontype2 = archers[mres - 1];
        destroy_all_weapons();
        weaponparse();
    }
    return m.get_item_name(mres);
}
int archers_callback(dynamic_menu_pro@ m, string data)
{
string archers;
if(m.menu_position>0)
archers=m.item_list[m.menu_position-1].name;
    if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*fire*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*fire*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*draw*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_E) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_E) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*empty*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_R) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_R) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/archery/"+archers+"/*reload*"), false);
}
return 0;
}
string gunsmenu()
{
    string[] fighters =get_pack_sound_folders("equipments/weapons/artillery/*");
    setupmenu();
    m.set_callback(@guns_callback, "");
    for (uint i = 0; i < fighters.length(); i++)
    {
        string weapon_name = fighters[i];
        string info_path = "data/layouts/weapons/artillery/" + weapon_name + "/info.sif";
        double unlock_level = 0;
        if (file_exists(info_path))
        {
            file f;
            f.open(info_path, "rb");
            string[] lines = string_split(f.read(), "\r\n", true);
            f.close();
            for (uint j = 0; j < lines.length(); j++)
            {
                string[] kv = string_split(lines[j], "=", true);
                if (kv.length() == 2 && kv[0] == "unlock level")
                {
                    unlock_level = parse_double(kv[1]);
                    break;
                }
            }
        }
        bool is_unlocked = level >= unlock_level;
        string label = weapon_name;
        if (!is_unlocked)
            label += " (Unlocked at level " + int_to_string(int(unlock_level)) + ")";
        m.add_item_tts(label, weapon_name, "", is_unlocked);
    }
    int mres = m.run("Artillery menu", true);
    if (mres == 0) weaponsmenu();
    if (mres > 0 && mres <= fighters.length())
    {
        resume_pools();
        weapontype2 = fighters[mres - 1];
        destroy_all_weapons();
        weaponparse();
    }
    return m.get_item_name(mres);
}
int guns_callback(dynamic_menu_pro@ m, string data)
{
string fighters;
if(m.menu_position>0)
fighters=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*fire*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*fire*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*draw*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_E) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_E) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*empty*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_R) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_R) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/artillery/"+fighters+"/*reload*"), false);
}
return 0;
}
string explosesmenu()
{
    string[] killers =get_pack_sound_folders("equipments/weapons/explosive/*");
    setupmenu();
    m.set_callback(@bombs_callback, "");
    for (uint i = 0; i < killers.length(); i++)
    {
        string weapon_name = killers[i];
        string info_path = "data/layouts/weapons/explosive/" + weapon_name + "/info.sif";
        double unlock_level = 0;
        if (file_exists(info_path))
        {
            file f;
            f.open(info_path, "rb");
            string[] lines = string_split(f.read(), "\r\n", true);
            f.close();
            for (uint j = 0; j < lines.length(); j++)
            {
                string[] kv = string_split(lines[j], "=", true);
                if (kv.length() == 2 && kv[0] == "unlock level")
                {
                    unlock_level = parse_double(kv[1]);
                    break;
                }
            }
        }
        bool is_unlocked = level >= unlock_level;
        string label = weapon_name;
        if (!is_unlocked)
            label += " (Unlocked at level " + int_to_string(int(unlock_level)) + ")";
        m.add_item_tts(label, weapon_name, "", is_unlocked);
    }
    int mres = m.run("Explosive menu", true);
    if (mres == 0) weaponsmenu();
    if (mres > 0 && mres <= killers.length())
    {
        resume_pools();
        weapontype2 = killers[mres - 1];
        destroy_all_weapons();
        weaponparse();
    }
    return m.get_item_name(mres);
}
int bombs_callback(dynamic_menu_pro@ m, string data)
{
string killers;
if(m.menu_position>0)
killers=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*fire*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*fire*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*draw*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_E) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_E) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*empty*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_R) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_R) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/explosive/"+killers+"/*reload*"), false);
}
return 0;
}
string meleesmenu()
{
    string[] brawlers =get_pack_sound_folders("equipments/weapons/melee/*");
    setupmenu();
    m.set_callback(@swords_callback, "");
    for (uint i = 0; i < brawlers.length(); i++)
    {
        string weapon_name = brawlers[i];
        string info_path = "data/layouts/weapons/melee/" + weapon_name + "/info.sif";
        double unlock_level = 0;
        if (file_exists(info_path))
        {
            file f;
            f.open(info_path, "rb");
            string[] lines = string_split(f.read(), "\r\n", true);
            f.close();
            for (uint j = 0; j < lines.length(); j++)
            {
                string[] kv = string_split(lines[j], "=", true);
                if (kv.length() == 2 && kv[0] == "unlock level")
                {
                    unlock_level = parse_double(kv[1]);
                    break;
                }
            }
        }
        bool is_unlocked = level >= unlock_level;
        string label = weapon_name;
        if (!is_unlocked)
            label += " (Unlocked at level " + int_to_string(int(unlock_level)) + ")";
        m.add_item_tts(label, weapon_name, "", is_unlocked);
    }
    int mres = m.run("Melee menu", true);
    if (mres == 0) weaponsmenu();
    if (mres > 0 && mres <= brawlers.length())
    {
        resume_pools();
        weapontype2 = brawlers[mres - 1];
        destroy_all_weapons();
        weaponparse();
    }
    return m.get_item_name(mres);
}
int swords_callback(dynamic_menu_pro@ m, string data)
{
string brawlers;
if(m.menu_position>0)
brawlers=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/melee/"+brawlers+"/*fire*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/melee/"+brawlers+"/*fire*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/melee/"+brawlers+"/*draw*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/weapons/melee/"+brawlers+"/*hit*"), false);
}
return 0;
}
string shieldsmenu()
{
    string[] armors = get_pack_sound_folders("equipments/shields/*");
    setupmenu();
    m.set_callback(@shields_callback, "");
    for (uint i = 0; i < armors.length(); i++)
    {
        string shield_name = armors[i];
        string info_path = "data/layouts/shields/" + shield_name + "/info.sif";
        double unlock_level = 0;
        if (file_exists(info_path))
        {
            file f;
            f.open(info_path, "rb");
            string[] lines = string_split(f.read(), "\r\n", true);
            f.close();
            for (uint j = 0; j < lines.length(); j++)
            {
                string[] kv = string_split(lines[j], "=", true);
                if (kv.length() == 2 && kv[0] == "unlock level")
                {
                    unlock_level = parse_double(kv[1]);
                    break;
                }
            }
        }
        bool is_unlocked = level >= unlock_level;
        string label = shield_name;
        if (!is_unlocked)
            label += " (Unlocked at level " + int_to_string(int(unlock_level)) + ")";
        m.add_item_tts(label, shield_name, "", is_unlocked);
    }
    int mres = m.run("Shields menu", true);
    if (mres == 0)
    {
        resume_pools();
        speak("Canceled");
    }
    if (mres > 0 && mres <= armors.length())
    {
        resume_pools();
        shieldtype = armors[mres - 1];
        destroy_all_shields();
        shieldparse();
        t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*draw*"), false);
        speak(shieldtype + " " + "equipped");
    }
    return m.get_item_name(mres);
}
int shields_callback(dynamic_menu_pro@ m, string data)
{
string shieldtype;
if(m.menu_position>0)
shieldtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*draw*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*break*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_R) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_R) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*remove*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_W) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_W) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_pack_sound("equipments/shields/"+shieldtype+"/*wear*"), false);
}
return 0;
}

string animalsmenu(bool include_random=false)
{
string[] animaltype=get_map_sound_folders("npc/animals/*");
setupmenu();
m.set_callback(@animals_callback,"");
for (uint i=0; i<animaltype.length(); i++)
{
m.add_item_tts(animaltype[i],animaltype[i],"",true);
}
if(include_random==true) m.add_item_tts("random","random");
int mres=m.run("Animals menu", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="random")
{
return "random";
}
if(mres>0 and mres<=animals.length())
{
amtype=animaltype[mres-1];
}
return m.get_item_name(mres);
}
int animals_callback(dynamic_menu_pro@ m, string data)
{
string animaltype;
if(m.menu_position>0)
animaltype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/animals/"+animaltype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/animals/"+animaltype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/animals/"+animaltype+"/*taunt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/animals/"+animaltype+"/*death*"), false);
}
return 0;
}
string humansmenu(bool include_random=false)
{
string[] humantype=get_map_sound_folders("npc/humans/*");
setupmenu();
m.set_callback(@humans_callback,"");
for (uint i=0; i<humantype.length(); i++)
{
m.add_item_tts(humantype[i], humantype[i],"",true);
}
if(include_random==true) m.add_item_tts("random","random");
int mres=m.run("humans menu", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="random")
{
return "random";
}
if(mres>0 and mres<=humans.length())
{
humtype=humantype[mres-1];
}
return m.get_item_name(mres);
}
int humans_callback(dynamic_menu_pro@ m, string data)
{
string humantype;
if(m.menu_position>0)
humantype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/humans/"+humantype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/humans/"+humantype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/humans/"+humantype+"/*taunt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/humans/"+humantype+"/*death*"), false);
}
return 0;
}
string projesmenu(bool include_random=false)
{
string[] projtype=get_map_sound_folders("npc/projectiles/*");
setupmenu();
m.set_callback(@projectiles_callback,"");
for (uint i=0; i<projtype.length(); i++)
{
m.add_item_tts(projtype[i],projtype[i],"",true);
}
if(include_random==true) m.add_item_tts("random","random");
int mres=m.run("projectiles menu", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="random")
{
return "random";
}
if(mres>0 and mres<=projectiles.length())
{
potype=projtype[mres-1];
}
return m.get_item_name(mres);
}
int projectiles_callback(dynamic_menu_pro@ m, string data)
{
string projtype;
if(m.menu_position>0)
projtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/projectiles/"+projtype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/projectiles/"+projtype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/projectiles/"+projtype+"/*loop*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/projectiles/"+projtype+"/*death*"), false);
}
return 0;
}
string robotsmenu(bool include_random=false)
{
string[] robottype=get_map_sound_folders("npc/robots/*");
setupmenu();
m.set_callback(@robots_callback,"");
for (uint i=0; i<robottype.length(); i++)
{
m.add_item_tts(robottype[i],robottype[i],"",true);
}
if(include_random==true) m.add_item_tts("random","random");
int mres=m.run("robots menu", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="random")
{
return "random";
}
if(mres>0 and mres<=robots.length())
{
rotype=robottype[mres-1];
}
return m.get_item_name(mres);
}
int robots_callback(dynamic_menu_pro@ m, string data)
{
string robottype;
if(m.menu_position>0)
robottype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/robots/"+robottype+"/*hurts*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/robots/"+robottype+"/*hurts*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/robots/"+robottype+"/*taunt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/robots/"+robottype+"/*death*"), false);
}
return 0;
}
string zombiesmenu(bool include_random=false)
{
string[] zombietype=get_map_sound_folders("npc/zombies/*");
setupmenu();
m.set_callback(@zombies_callback,"");
for (uint i=0; i<zombietype.length(); i++)
{
m.add_item_tts(zombietype[i],zombietype[i],"",true);
}
if(include_random==true) m.add_item_tts("random","random");
int mres=m.run("zombies menu", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="random")
{
return "random";
}
if(mres>0 and mres<=zombies.length())
{
zotype=zombietype[mres-1];
}
return m.get_item_name(mres);
}
int zombies_callback(dynamic_menu_pro@ m, string data)
{
string zombietype;
if(m.menu_position>0)
zombietype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/zombies/"+zombietype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/zombies/"+zombietype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/zombies/"+zombietype+"/*taunt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/zombies/"+zombietype+"/*death*"), false);
}
return 0;
}

string miscsoundsmenu()
{
string[] miscsounds=find_files("sounds/"+soundpack+"/misc/*");
sort_naturally(miscsounds);
setupmenu2();
m.set_callback(@miscsounds_callback,"");
for(uint i=0; i<miscsounds.length(); i++)
{
string letter=string_replace(miscsounds[i],".ogg","",true)[0];
m.add_item(get_pack_sound("misc/"+miscsounds[i]), miscsounds[i], letter, true);
}
int mres=m.run("Select a misc sound to play",true);
if(mres==0)
{
miscmenu();
}
if(mres>0 and mres<=miscsounds.length())
{
miscmenu();
}
return m.get_item_name(mres);
}
int miscsounds_callback(dynamic_menu_pro@ m, string data)
{
string misctyp;
if(m.menu_position>0)
misctyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(misctyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(misctyp);
}
return 0;
}
string liftsmenu()
{
string[] lifts=get_map_sound_folders("objects/lifts/*");
setupmenu2();
m.set_callback(@lifts_callback,"");
for (uint i=0; i<lifts.length(); i++)
{
string letter=string_replace(lifts[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/lifts/"+lifts[i]+"/*loop*"), lifts[i], letter, true);
}
int mres=m.run("lifts menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=lifts.length())
{
}
return m.get_item_name(mres);
}
int lifts_callback(dynamic_menu_pro@ m, string data)
{
string lifttyp;
if(m.menu_position>0)
lifttyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(lifttyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(lifttyp);
}
return 0;
}
string mplatsmenu()
{
string[] mplats=get_map_sound_folders("objects/moving platforms/*");
setupmenu2();
m.set_callback(@mplats_callback,"");
for (uint i=0; i<mplats.length(); i++)
{
string letter=string_replace(mplats[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/moving platforms/"+mplats[i]+"/*loop*"), mplats[i], letter, true);
}
int mres=m.run("moving platforms menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=mplats.length())
{
}
return m.get_item_name(mres);
}
int mplats_callback(dynamic_menu_pro@ m, string data)
{
string mplattyp;
if(m.menu_position>0)
mplattyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(mplattyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(mplattyp);
}
return 0;
}
string dloopsmenu()
{
string[] looptype=get_map_sound_folders("objects/doors/loop/*");
setupmenu2();
m.set_callback(@dloops_callback,"");
for (uint i=0; i<looptype.length(); i++)
{
string letter=string_replace(looptype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/doors/loop/"+looptype[i]+"/*loop*"), looptype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("Loop sounds menu", true);
if(mres==0)
{
looptyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
looptyp="none";
return "none";
}
if(mres>0 and mres<=looptype.length())
{
looptyp=looptype[mres-1];
}
return m.get_item_name(mres);
}
int dloops_callback(dynamic_menu_pro@ m, string data)
{
string looptype;
if(m.menu_position>0)
looptype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(looptype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(looptype);
}
return 0;
}
string dmovesmenu()
{
string[] movetype=get_map_sound_folders("objects/doors/move/*");
setupmenu2();
m.set_callback(@dmoves_callback,"");
for (uint i=0; i<movetype.length(); i++)
{
string letter=string_replace(movetype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/doors/move/"+movetype[i]+"/*move*"), movetype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("move sounds menu", true);
if(mres==0)
{
movtyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
movtyp="none";
return "none";
}
if(mres>0 and mres<=movetype.length())
{
movtyp=movetype[mres-1];
}
return m.get_item_name(mres);
}
int dmoves_callback(dynamic_menu_pro@ m, string data)
{
string movetype;
if(m.menu_position>0)
movetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(movetype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(movetype);
}
return 0;
}
string dopensmenu()
{
string[] opentype=get_map_sound_folders("objects/doors/open/*");
setupmenu2();
m.set_callback(@dopens_callback,"");
for (uint i=0; i<opentype.length(); i++)
{
string letter=string_replace(opentype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/doors/open/"+opentype[i]+"/*open*"), opentype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("open sounds menu", true);
if(mres==0)
{
opentyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
opentyp="none";
return "none";
}
if(mres>0 and mres<=opentype.length())
{
opentyp=opentype[mres-1];
}
return m.get_item_name(mres);
}
int dopens_callback(dynamic_menu_pro@ m, string data)
{
string opentype;
if(m.menu_position>0)
opentype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(opentype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(opentype);
}
return 0;
}
string dclosesmenu()
{
string[] closetype=get_map_sound_folders("objects/doors/close/*");
setupmenu2();
m.set_callback(@dcloses_callback,"");
for (uint i=0; i<closetype.length(); i++)
{
string letter=string_replace(closetype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/doors/close/"+closetype[i]+"/*close*"), closetype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("close sounds menu", true);
if(mres==0)
{
clostyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
clostyp="none";
return "none";
}
if(mres>0 and mres<=closetype.length())
{
clostyp=closetype[mres-1];
}
return m.get_item_name(mres);
}
int dcloses_callback(dynamic_menu_pro@ m, string data)
{
string closetype;
if(m.menu_position>0)
closetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(closetype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(closetype);
}
return 0;
}
string eldloopsmenu()
{
string[] ellooptype=get_map_sound_folders("objects/elevators/loop/*");
setupmenu2();
m.set_callback(@eldloops_callback,"");
for (uint i=0; i<ellooptype.length(); i++)
{
string letter=string_replace(ellooptype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/elevators/loop/"+ellooptype[i]+"/*loop*"), ellooptype[i], letter ,true);
}
m.add_item_tts("none","none");
int mres=m.run("Loop sounds menu", true);
if(mres==0)
{
ellooptyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
ellooptyp="none";
return "none";
}
if(mres>0 and mres<=ellooptype.length())
{
ellooptyp=ellooptype[mres-1];
}
return m.get_item_name(mres);
}
int eldloops_callback(dynamic_menu_pro@ m, string data)
{
string ellooptype;
if(m.menu_position>0)
ellooptype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(ellooptype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(ellooptype);
}
return 0;
}
string eldmovesmenu()
{
string[] elmovetype=get_map_sound_folders("objects/elevators/move/*");
setupmenu2();
m.set_callback(@eldmoves_callback,"");
for (uint i=0; i<elmovetype.length(); i++)
{
string letter=string_replace(elmovetype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/elevators/move/"+elmovetype[i]+"/*move*"), elmovetype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("move sounds menu", true);
if(mres==0)
{
elmovtyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
elmovtyp="none";
return "none";
}
if(mres>0 and mres<=elmovetype.length())
{
elmovtyp=elmovetype[mres-1];
}
return m.get_item_name(mres);
}
int eldmoves_callback(dynamic_menu_pro@ m, string data)
{
string elmovetype;
if(m.menu_position>0)
elmovetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(elmovetype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(elmovetype);
}
return 0;
}
string eldopensmenu()
{
string[] elopentype=get_map_sound_folders("objects/elevators/open/*");
setupmenu2();
m.set_callback(@eldopens_callback,"");
for (uint i=0; i<elopentype.length(); i++)
{
string letter=string_replace(elopentype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/elevators/open/"+elopentype[i]+"/*open*"), elopentype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("open sounds menu", true);
if(mres==0)
{
elopentyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
elopentyp="none";
return "none";
}
if(mres>0 and mres<=elopentype.length())
{
elopentyp=elopentype[mres-1];
}
return m.get_item_name(mres);
}
int eldopens_callback(dynamic_menu_pro@ m, string data)
{
string elopentype;
if(m.menu_position>0)
elopentype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(elopentype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(elopentype);
}
return 0;
}
string eldclosesmenu()
{
string[] elclosetype=get_map_sound_folders("objects/elevators/close/*");
setupmenu2();
m.set_callback(@eldcloses_callback,"");
for (uint i=0; i<elclosetype.length(); i++)
{
string letter=string_replace(elclosetype[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/elevators/close/"+elclosetype[i]+"/*close*"), elclosetype[i], letter, true);
}
m.add_item_tts("none","none");
int mres=m.run("close sounds menu", true);
if(mres==0)
{
elclostyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
elclostyp="none";
return "none";
}
if(mres>0 and mres<=elclosetype.length())
{
elclostyp=elclosetype[mres-1];
}
return m.get_item_name(mres);
}
int eldcloses_callback(dynamic_menu_pro@ m, string data)
{
string elclosetype;
if(m.menu_position>0)
elclosetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(elclosetype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(elclosetype);
}
return 0;
}
string musicsmenu()
{
string[] musics=get_map_sound_folders("soundtracks/musics/*");
setupmenu2();
m.set_callback(@musics_callback,"");
for (uint i=0; i<musics.length(); i++)
{
string letter=string_replace(musics[i],".ogg","",true)[0];
m.add_item(get_map_sound("soundtracks/musics/"+musics[i]+"/*loop*"), musics[i], letter, true);
}
int mres=m.run("musics menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=musics.length())
{
}
return m.get_item_name(mres);
}
int musics_callback(dynamic_menu_pro@ m, string data)
{
string mustyp;
if(m.menu_position>0)
mustyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(mustyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(mustyp);
}
return 0;
}
string sorcesmenu()
{
string[] sorces=get_map_sound_folders("soundtracks/sources/*");
setupmenu2();
m.set_callback(@sources_callback,"");
for (uint i=0; i<sorces.length(); i++)
{
string letter=string_replace(sorces[i],".ogg","",true)[0];
m.add_item(get_map_sound("soundtracks/sources/"+sorces[i]+"/*loop*"), sorces[i], letter, true);
}
int mres=m.run("sources menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=sorces.length())
{
}
return m.get_item_name(mres);
}
int sources_callback(dynamic_menu_pro@ m, string data)
{
string sorcetyp;
if(m.menu_position>0)
sorcetyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(sorcetyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(sorcetyp);
}
return 0;
}
string vplatsmenu()
{
string[] vplats=get_map_sound_folders("objects/vanishing platforms/*");
setupmenu2();
m.set_callback(@vplats_callback,"");
for (uint i=0; i<vplats.length(); i++)
{
string letter=string_replace(vplats[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/vanishing platforms/"+vplats[i]+"/*loop*"), vplats[i], letter, true);
}
int mres=m.run("vanishers menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=vplats.length())
{
}
return m.get_item_name(mres);
}
int vplats_callback(dynamic_menu_pro@ m, string data)
{
string vplattyp;
if(m.menu_position>0)
vplattyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(vplattyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(vplattyp);
}
return 0;
}
string beltsmenu()
{
string[] belts=get_map_sound_folders("objects/belts/*");
setupmenu();
m.set_callback(@belts_callback,"");
for (uint i=0; i<belts.length(); i++)
{
string letter=string_replace(belts[i],".ogg","",true)[0];
m.add_item(get_map_sound("objects/belts/"+belts[i]+"/*loop*"), belts[i], letter, true);
}
int mres=m.run("belts menu.", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=belts.length())
{
}
return m.get_item_name(mres);
}
int belts_callback(dynamic_menu_pro@ m, string data)
{
string belttyp;
if(m.menu_position>0)
belttyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(belttyp);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(belttyp);
}
return 0;
}
string wallsmenu()
{
string[] borders=get_map_sound_folders("objects/walls/*");
setupmenu2();
m.set_callback(@walls_callback,"");
for (uint i=0; i<borders.length(); i++)
{
string letter=string_replace(borders[i],"wall","",true)[0];
m.add_item(get_map_sound("objects/walls/"+borders[i]+"/*bump*"), borders[i], letter, true);
}
m.add_item_tts("wall","wall");
int mres=m.run("Select a wall.", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="wall")
{
walltype="wall";
return walltype;
}
if(mres>0 and mres<=borders.length())
{
walltype=borders[mres-1];
}
return m.get_item_name(mres);
}
int walls_callback(dynamic_menu_pro@ m, string data)
{
string walltype;
if(m.menu_position>0)
walltype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
speak(walltype);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
speak(walltype);
}
return 0;
}

string invmenu()
{
    setupmenu();
    m.set_callback(@invmenu_callback, "");
    int total = count_total_items();
m.add_item_tts("Total items " + total + ".");
    string[] keys = inv.get_keys();
    keys.sort_ascending();
    for (uint i = 0; i < keys.length(); i++)
    {
        int amt;
        inv.get(keys[i], amt);
        string label = keys[i] + (amt == 1 ? "" : "s") + ", you have " + amt;
        m.add_item_tts(label, keys[i]);
    }
    int mres = m.run("Inventory menu.", true);
    if (mres <= 0)
    {
resume_pools();
        speak("Canceled");
        return "";
    }
    string choice = m.get_item_name(mres);
    if (choice == "")
    {
resume_pools();
        return "";
    }
resume_pools();
    focus_item(choice);
    double invpan = convert_to_pan(keys.length(), invpos, -25, 25);
    if (charinvsound == 1) invslot = p.play_stationary_extended(get_pack_sound("characters/" + chartype + "/*inv*"), false, 0, invpan, 0, 100, false);
int amt;
inv.get(choice, amt);
speak(choice + (amt == 1 ? "" : "s") + " focused");
    return m.get_item_name(mres);
}
int invmenu_callback(dynamic_menu_pro@ m, string data)
{
if (key_repeating(KEY_DELETE) || key_repeating(KEY_BACK) && usetimer.elapsed >= usetime)
{
    if (inv.get_size() == 0)
    {
        speak("No item in focus.");
        return 0;
    }
    string[] keys = inv.get_keys();
    keys.sort_ascending();
    if (invpos < 0 || invpos >= keys.length())
    {
        speak("No item in focus.");
        return 0;
    }
    string item = keys[invpos];
    string[] healtype = get_map_sound_folders("objects/items/health/*");
string[] healtype2 = get_map_sound_folders("objects/items/stamina/*");
    string[] misktype = get_map_sound_folders("objects/items/other/*");
    bool matched = false;
    for (uint i = 0; i < healtype.length(); i++)
    {
        if (item == healtype[i])
        {
            drop_item(facing, "health", item);
            give(item, -1);
            matched = true;
            break;
        }
    }
if (!matched)
    {
        speak("Cannot drop this item.");
}
    for (uint i = 0; i < healtype2.length(); i++)
    {
        if (item == healtype2[i])
        {
            drop_item(facing, "stamina", item);
            give(item, -1);
            matched = true;
            break;
        }
    }
    if (!matched)
    {
        speak("Cannot drop this item.");
        }
for (uint i = 0; i < misktype.length(); i++)
        {
            if (item == misktype[i])
            {
                drop_item(facing, "other", item);
                give(item, -1);
                matched = true;
                break;
            }
        }
    if (!matched)
    {
        speak("Cannot drop this item.");
return 0;
    }
    usetimer.restart();
}
return 0;
}
string platsmenu()
{
string[] plats=get_map_sound_folders("objects/platforms/*");
setupmenu();
m.set_callback(@steps_callback,"");
for (uint i=0; i<plats.length(); i++)
{
m.add_item_tts(plats[i],plats[i],"",true);
}
m.add_item_tts("air","air");
int mres=m.run("Select a surface.", true);
if(mres==0)
{
speak("canceled");
}
if(m.get_item_name(mres)=="air")
{
tiletype="air";
return tiletype;
}
if(mres>0 and mres<=plats.length())
{
tiletype=plats[mres-1];
}
return m.get_item_name(mres);
}
int steps_callback(dynamic_menu_pro@ m, string data)
{
string tiletype;
if(m.menu_position>0)
tiletype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/platforms/"+tiletype+"/*step*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/platforms/"+tiletype+"/*step*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/platforms/"+tiletype+"/*fall*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/platforms/"+tiletype+"/*land*"), false);
}
return 0;
}
string healthsmenu()
{
string[] healtype=get_map_sound_folders("objects/items/health/*");
setupmenu();
m.set_callback(@healths_callback,"");
for (uint i=0; i<healtype.length(); i++)
{
m.add_item_tts(healtype[i],healtype[i],"",true);
}
int mres=m.run("Healths menu", true);
if(mres==0)
{
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
m.add_item_tts("stamina", "st");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
}
if(itsm=="hp")
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
if(itsm=="ot")
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
if(itsm=="st")
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
itemtype2=res;
}
}
}
if(mres>0 and mres<=healtype.length())
{
itemtype2=healtype[mres-1];
}
return m.get_item_name(mres);
}
int healths_callback(dynamic_menu_pro@ m, string data)
{
string healtype;
if(m.menu_position>0)
healtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/health/"+healtype+"/*get*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/health/"+healtype+"/*get*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/health/"+healtype+"/*loop*"), false);
}
return 0;
}
string othersmenu()
{
string[] misktype=get_map_sound_folders("objects/items/other/*");
setupmenu();
m.set_callback(@others_callback,"");
for (uint i=0; i<misktype.length(); i++)
{
m.add_item_tts(misktype[i],misktype[i],"",true);
}
int mres=m.run("others menu", true);
if(mres==0)
{
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
m.add_item_tts("stamina", "st");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
}
if(itsm=="hp")
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
itemtype2=res;
}
}
if(itsm=="ot")
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
if(itsm=="st")
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
itemtype2=res;
}
}
}
if(mres>0 and mres<=misktype.length())
{
itemtype2=misktype[mres-1];
}
return m.get_item_name(mres);
}
int others_callback(dynamic_menu_pro@ m, string data)
{
string misktype;
if(m.menu_position>0)
misktype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/other/"+misktype+"/*get*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/other/"+misktype+"/*get*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/other/"+misktype+"/*loop*"), false);
}
return 0;
}
string staminasmenu()
{
string[] healtype2=get_map_sound_folders("objects/items/stamina/*");
setupmenu();
m.set_callback(@staminas_callback,"");
for (uint i=0; i<healtype2.length(); i++)
{
m.add_item_tts(healtype2[i],healtype2[i],"",true);
}
int mres=m.run("staminas menu", true);
if(mres==0)
{
setupmenu();
m.add_item_tts("stamina", "hp");
m.add_item_tts("other", "ot");
m.add_item_tts("stamina", "st");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
}
if(itsm=="hp")
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
itemtype2=res;
}
}
if(itsm=="ot")
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
itemtype2=res;
}
}
if(itsm=="st")
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
itemtype2=res;
}
}
}
if(mres>0 and mres<=healtype2.length())
{
itemtype2=healtype2[mres-1];
}
return m.get_item_name(mres);
}
int staminas_callback(dynamic_menu_pro@ m, string data)
{
string healtype2;
if(m.menu_position>0)
healtype2=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/stamina/"+healtype2+"/*get*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/stamina/"+healtype2+"/*get*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/items/stamina/"+healtype2+"/*loop*"), false);
}
return 0;
}
string bikesmenu()
{
string[] biketypes=get_map_sound_folders("objects/bikes/*");
setupmenu();
m.set_callback(@bikes_callback,"");
for (uint i=0; i<biketypes.length(); i++)
{
m.add_item_tts(biketypes[i],biketypes[i],"",true);
}
int mres=m.run("bikes menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=biketypes.length())
{
biktyp=biketypes[mres-1];
}
return m.get_item_name(mres);
}
int bikes_callback(dynamic_menu_pro@ m, string data)
{
string biketype;
if(m.menu_position>0)
biketype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bikes/"+biketype+"/misc/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bikes/"+biketype+"/misc/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bikes/"+biketype+"/misc/*beacon*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bikes/"+biketype+"/misc/*death*"), false);
}
return 0;
}
string bombsmenu()
{
string[] bombtype=get_map_sound_folders("OBJECTS/BOMBS/*");
setupmenu();
m.set_callback(@bombes_callback,"");
for (uint i=0; i<bombtype.length(); i++)
{
m.add_item_tts(bombtype[i],bombtype[i],"",true);
}
int mres=m.run("bombs menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=bombs.length())
{
botype=bombtype[mres-1];
}
return m.get_item_name(mres);
}
int bombes_callback(dynamic_menu_pro@ m, string data)
{
string bombtype;
if(m.menu_position>0)
bombtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bombs/"+bombtype+"/*land*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bombs/"+bombtype+"/*land*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/bombs/"+bombtype+"/*fall*"), false);
}
return 0;
}
string camsmenu()
{
string[] camtypes=get_map_sound_folders("objects/cameras/*");
setupmenu();
m.set_callback(@cameras_callback,"");
for (uint i=0; i<camtypes.length(); i++)
{
m.add_item_tts(camtypes[i],camtypes[i],"",true);
}
int mres=m.run("security cameras menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=camtypes.length())
{
camtyp=camtypes[mres-1];
}
return m.get_item_name(mres);
}
int cameras_callback(dynamic_menu_pro@ m, string data)
{
string camtype;
if(m.menu_position>0)
camtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/cameras/"+camtype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/cameras/"+camtype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/cameras/"+camtype+"/*turn*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/cameras/"+camtype+"/*alert*"), false);
}
return 0;
}
string floorsmenu()
{
string[] floorbtype=get_map_sound_folders("objects/floor breakers/*");
setupmenu();
m.set_callback(@floores_callback,"");
for (uint i=0; i<floorbtype.length(); i++)
{
m.add_item_tts(floorbtype[i],floorbtype[i],"",true);
}
int mres=m.run("floor breakers menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=bombs.length())
{
floortyp=floorbtype[mres-1];
}
return m.get_item_name(mres);
}
int floores_callback(dynamic_menu_pro@ m, string data)
{
string floorbtype;
if(m.menu_position>0)
floorbtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/floor breakers/"+floorbtype+"/*spawn*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/floor breakers/"+floorbtype+"/*spawn*"), false);
}
return 0;
}
string timbombsmenu()
{
string[] timbombtype=get_map_sound_folders("objects/time bombs/*");
setupmenu();
m.set_callback(@timbombes_callback,"");
for (uint i=0; i<timbombtype.length(); i++)
{
m.add_item_tts(timbombtype[i],timbombtype[i],"",true);
}
int mres=m.run("time bombs menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=bombs.length())
{
timbotype=timbombtype[mres-1];
}
return m.get_item_name(mres);
}
int timbombes_callback(dynamic_menu_pro@ m, string data)
{
string timbombtype;
if(m.menu_position>0)
timbombtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/time bombs/"+timbombtype+"/*land*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/time bombs/"+timbombtype+"/*land*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/time bombs/"+timbombtype+"/*fall*"), false);
}
return 0;
}
string checksmenu()
{
string[] checktype=get_map_sound_folders("objects/checkpoints/*");
setupmenu();
m.set_callback(@checks_callback,"");
for (uint i=0; i<checktype.length(); i++)
{
m.add_item_tts(checktype[i],checktype[i],"",true);
}
int mres=m.run("checkpoints menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=checkpoints.length())
{
checktyp=checktype[mres-1];
}
return m.get_item_name(mres);
}
int checks_callback(dynamic_menu_pro@ m, string data)
{
string checktype;
if(m.menu_position>0)
checktype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/checkpoints/"+checktype+"/*get*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/checkpoints/"+checktype+"/*get*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/checkpoints/"+checktype+"/*loop*"), false);
}
return 0;
}
string destsmenu()
{
string[] desttype=get_map_sound_folders("objects/doors/dest/*");
setupmenu();
m.set_callback(@dests_callback,"");
m.add_item_tts("none","none");
for (uint i=0; i<desttype.length(); i++)
{
m.add_item_tts(desttype[i],desttype[i],"",true);
}
int mres=m.run_extended("Door destructions menu. Press enter to use the default door destruction sound.", true, 1, false);
if(mres==0)
{
desttyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
desttyp="none";
return "none";
}
if(mres>0 and mres<=desttype.length())
{
desttyp=desttype[mres-1];
}
return m.get_item_name(mres);
}
int dests_callback(dynamic_menu_pro@ m, string data)
{
string desttype;
if(m.menu_position>0)
desttype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/doors/dest/"+desttype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/doors/dest/"+desttype+"/*death*"), false);
}
return 0;
}
string helpersmenu()
{
string[] helpertype=get_map_sound_folders("npc/helpers/*");
setupmenu();
m.set_callback(@helps_callback,"");
for (uint i=0; i<helpertype.length(); i++)
{
m.add_item_tts(helpertype[i],helpertype[i],"",true);
}
int mres=m.run("helpers menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=helpertype.length())
{
helptyp=helpertype[mres-1];
}
return m.get_item_name(mres);
}
int helps_callback(dynamic_menu_pro@ m, string data)
{
string helpertype;
if(m.menu_position>0)
helpertype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/helpers/"+helpertype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/helpers/"+helpertype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/helpers/"+helpertype+"/*loop*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/helpers/"+helpertype+"/*death*"), false);
}
return 0;
}
string bossesmenu()
{
string[] bosstype=get_map_sound_folders("npc/bosses/*");
setupmenu();
m.set_callback(@bosses_callback,"");
for (uint i=0; i<bosstype.length(); i++)
{
m.add_item_tts(bosstype[i],bosstype[i],"",true);
}
int mres=m.run("bosses menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=bosses.length())
{
bosstyp=bosstype[mres-1];
}
return m.get_item_name(mres);
}
int bosses_callback(dynamic_menu_pro@ m, string data)
{
string bosstype;
if(m.menu_position>0)
bosstype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/bosses/"+bosstype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/bosses/"+bosstype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/bosses/"+bosstype+"/*taunt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/bosses/"+bosstype+"/*death*"), false);
}
return 0;
}
string turretsmenu()
{
string[] turtype=get_map_sound_folders("npc/turrets/*");
setupmenu();
m.set_callback(@turrets_callback,"");
for (uint i=0; i<turtype.length(); i++)
{
m.add_item_tts(turtype[i],turtype[i],"",true);
}
int mres=m.run("turrets menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=turrets.length())
{
tutype=turtype[mres-1];
}
return m.get_item_name(mres);
}
int turrets_callback(dynamic_menu_pro@ m, string data)
{
string turtype;
if(m.menu_position>0)
turtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/turrets/"+turtype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/turrets/"+turtype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/turrets/"+turtype+"/*loop*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("npc/turrets/"+turtype+"/*death*"), false);
}
return 0;
}
string hazardsmenu()
{
string[] hazardtype=get_map_sound_folders("objects/hazards/*");
setupmenu();
m.set_callback(@hazards_callback,"");
for (uint i=0; i<hazardtype.length(); i++)
{
m.add_item_tts(hazardtype[i],hazardtype[i],"",true);
}
int mres=m.run("Hazards menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=hazardtype.length())
{
hazztype=hazardtype[mres-1];
}
return m.get_item_name(mres);
}
int hazards_callback(dynamic_menu_pro@ m, string data)
{
string hazardtype;
if(m.menu_position>0)
hazardtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/hazards/"+hazardtype+"/*fall*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/hazards/"+hazardtype+"/*fall*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/hazards/"+hazardtype+"/*loop*"), false);
}
return 0;
}
string teleportersmenu()
{
string[] teletype=get_map_sound_folders("objects/teleporters/*");
setupmenu();
m.set_callback(@teleporters_callback,"");
for (uint i=0; i<teletype.length(); i++)
{
m.add_item_tts(teletype[i],teletype[i],"",true);
}
int mres=m.run("teleporters menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=teletype.length())
{
teltype=teletype[mres-1];
}
return m.get_item_name(mres);
}
int teleporters_callback(dynamic_menu_pro@ m, string data)
{
string teletype;
if(m.menu_position>0)
teletype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/teleporters/"+teletype+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/teleporters/"+teletype+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/teleporters/"+teletype+"/*loop*"), false);
}
return 0;
}
string firesmenu()
{
string[] firetyp=get_map_sound_folders("objects/fires/*");
setupmenu();
m.set_callback(@fires_callback,"");
for (uint i=0; i<firetyp.length(); i++)
{
m.add_item_tts(firetyp[i],firetyp[i],"",true);
}
int mres=m.run("fires menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=firetyp.length())
{
firetype=firetyp[mres-1];
}
return m.get_item_name(mres);
}
int fires_callback(dynamic_menu_pro@ m, string data)
{
string firetyp;
if(m.menu_position>0)
firetyp=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/fires/"+firetyp+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/fires/"+firetyp+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/fires/"+firetyp+"/*loop*"), false);
}
return 0;
}
string forcesmenu()
{
string[] forcetype=get_map_sound_folders("objects/force fields/*");
setupmenu();
m.set_callback(@forcefields_callback,"");
for (uint i=0; i<forcetype.length(); i++)
{
m.add_item_tts(forcetype[i],forcetype[i],"",true);
}
int mres=m.run("force fields menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=forcetype.length())
{
forcetyp=forcetype[mres-1];
}
return m.get_item_name(mres);
}
int forcefields_callback(dynamic_menu_pro@ m, string data)
{
string forcetype;
if(m.menu_position>0)
forcetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/force fields/"+forcetype+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/force fields/"+forcetype+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_N) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_N) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/force fields/"+forcetype+"/*on*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_O) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_O) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/force fields/"+forcetype+"/*off*"), false);
}
return 0;
}
string minesmenu()
{
string[] minetype=get_map_sound_folders("objects/mines/*");
setupmenu();
m.set_callback(@mines_callback,"");
for (uint i=0; i<minetype.length(); i++)
{
m.add_item_tts(minetype[i],minetype[i],"",true);
}
int mres=m.run("mines menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=minetype.length())
{
minetyp=minetype[mres-1];
}
return m.get_item_name(mres);
}
int mines_callback(dynamic_menu_pro@ m, string data)
{
string minetype;
if(m.menu_position>0)
minetype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/mines/"+minetype+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/mines/"+minetype+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/mines/"+minetype+"/*loop*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_I) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_I) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/mines/"+minetype+"/*light*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_N) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_N) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/mines/"+minetype+"/*spawn*"), false);
}
return 0;
}
string spikesmenu()
{
string[] spiketype=get_map_sound_folders("objects/spikes/*");
setupmenu();
m.set_callback(@spikes_callback,"");
for (uint i=0; i<spiketype.length(); i++)
{
m.add_item_tts(spiketype[i],spiketype[i],"",true);
}
int mres=m.run("spikes menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=spiketype.length())
{
spiktype=spiketype[mres-1];
}
return m.get_item_name(mres);
}
int spikes_callback(dynamic_menu_pro@ m, string data)
{
string spiketype;
if(m.menu_position>0)
spiketype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/spikes/"+spiketype+"/*hit*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/spikes/"+spiketype+"/*hit*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/spikes/"+spiketype+"/*loop*"), false);
}
return 0;
}
string elbeepsmenu()
{
string[] elbeeptype=get_map_sound_folders("objects/elevators/*");
setupmenu();
m.set_callback(@elbeeps_callback,"");
m.add_item_tts("none","none");
for (uint i=0; i<elbeeptype.length(); i++)
{
m.add_item_tts(elbeeptype[i],elbeeptype[i],"",true);
}
int mres=m.run_extended("Elevator beeps menu. Press enter to use the default elevator beep sound.", true, 1, false);
if(mres==0)
{
elbeeptyp="none";
return "none";
}
if(m.get_item_name(mres)=="none")
{
elbeeptyp="none";
return "none";
}
if(mres>0 and mres<=elbeeptype.length())
{
elbeeptyp=elbeeptype[mres-1];
}
return m.get_item_name(mres);
}
int elbeeps_callback(dynamic_menu_pro@ m, string data)
{
string elbeeptype;
if(m.menu_position>0)
elbeeptype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/elevators/"+elbeeptype+"/*beep*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/elevators/"+elbeeptype+"/*beep*"), false);
}
return 0;
}
string dlgsmenu()
{
string[] dlgtype=get_map_sound_folders("objects/dialogs/*");
setupmenu();
m.set_callback(@dialogs_callback,"");
for (uint i=0; i<dlgtype.length(); i++)
{
m.add_item_tts(dlgtype[i],dlgtype[i],"",true);
}
int mres=m.run("Dialogs menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=dlgtype.length())
{
dlgtyp=dlgtype[mres-1];
}
return m.get_item_name(mres);
}
int dialogs_callback(dynamic_menu_pro@ m, string data)
{
string dlgtype;
if(m.menu_position>0)
dlgtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/dialogs/"+dlgtype+"/*scroll*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/dialogs/"+dlgtype+"/*scroll*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/dialogs/"+dlgtype+"/*open*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/dialogs/"+dlgtype+"/*close*"), false);
}
return 0;
}
string calandersmenu()
{
string[] calandertype=get_map_sound_folders("objects/calendars/*");
setupmenu();
m.set_callback(@calanders_callback,"");
for (uint i=0; i<calandertype.length(); i++)
{
m.add_item_tts(calandertype[i],calandertype[i],"",true);
}
int mres=m.run("calendars menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=calandertype.length())
{
calandertyp=calandertype[mres-1];
}
return m.get_item_name(mres);
}
int calanders_callback(dynamic_menu_pro@ m, string data)
{
string calandertype;
if(m.menu_position>0)
calandertype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/calendars/"+calandertype+"/*press*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/calendars/"+calandertype+"/*press*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/calendars/"+calandertype+"/*loop*"), false);
}
return 0;
}
string clocksmenu()
{
string[] clocktype=get_map_sound_folders("objects/clocks/*");
setupmenu();
m.set_callback(@clocks_callback,"");
for (uint i=0; i<clocktype.length(); i++)
{
m.add_item_tts(clocktype[i],clocktype[i],"",true);
}
int mres=m.run("clocks menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=clocktype.length())
{
clocktyp=clocktype[mres-1];
}
return m.get_item_name(mres);
}
int clocks_callback(dynamic_menu_pro@ m, string data)
{
string clocktype;
if(m.menu_position>0)
clocktype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/clocks/"+clocktype+"/*press*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/clocks/"+clocktype+"/*press*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/clocks/"+clocktype+"/*loop*"), false);
}
return 0;
}
string signsmenu()
{
string[] signtype=get_map_sound_folders("objects/signs/*");
setupmenu();
m.set_callback(@signs_callback,"");
for (uint i=0; i<signtype.length(); i++)
{
m.add_item_tts(signtype[i],signtype[i],"",true);
}
int mres=m.run("signs menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=signtype.length())
{
signtyp=signtype[mres-1];
}
return m.get_item_name(mres);
}
int signs_callback(dynamic_menu_pro@ m, string data)
{
string signtype;
if(m.menu_position>0)
signtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/signs/"+signtype+"/*press*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/signs/"+signtype+"/*press*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/signs/"+signtype+"/*loop*"), false);
}
return 0;
}
string switchesmenu()
{
string[] switchtype=get_map_sound_folders("objects/switches/*");
setupmenu();
m.set_callback(@switches_callback,"");
for (uint i=0; i<switchtype.length(); i++)
{
m.add_item_tts(switchtype[i],switchtype[i],"",true);
}
int mres=m.run("switches menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=switchtype.length())
{
switchtyp=switchtype[mres-1];
}
return m.get_item_name(mres);
}
int switches_callback(dynamic_menu_pro@ m, string data)
{
string switchtype;
if(m.menu_position>0)
switchtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/switches/"+switchtype+"/*press*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/switches/"+switchtype+"/*press*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/switches/"+switchtype+"/*loop*"), false);
}
return 0;
}
string healsmenu()
{
string[] healthtype=get_map_sound_folders("objects/heal zones/*");
setupmenu();
m.set_callback(@heals_callback,"");
for (uint i=0; i<healthtype.length(); i++)
{
m.add_item_tts(healthtype[i],healthtype[i],"",true);
}
int mres=m.run("heal zones menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=healthtype.length())
{
healtyp=healthtype[mres-1];
}
return m.get_item_name(mres);
}
int heals_callback(dynamic_menu_pro@ m, string data)
{
string healthtype;
if(m.menu_position>0)
healthtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/heal zones/"+healthtype+"/*heal*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/heal zones/"+healthtype+"/*heal*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/heal zones/"+healthtype+"/*take*"), false);
}
return 0;
}
string safsmenu()
{
string[] saftype=get_map_sound_folders("objects/safe zones/*");
setupmenu();
m.set_callback(@safes_callback,"");
for (uint i=0; i<saftype.length(); i++)
{
m.add_item_tts(saftype[i],saftype[i],"",true);
}
int mres=m.run("safe zones menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=saftype.length())
{
saftyp=saftype[mres-1];
}
return m.get_item_name(mres);
}
int safes_callback(dynamic_menu_pro@ m, string data)
{
string saftype;
if(m.menu_position>0)
saftype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/safe zones/"+saftype+"/*out*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/safe zones/"+saftype+"/*out*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/safe zones/"+saftype+"/*in*"), false);
}
return 0;
}
string plainsmenu()
{
string[] plaintype=get_map_sound_folders("objects/aircrafts/*");
setupmenu();
m.set_callback(@aircrafts_callback,"");
for (uint i=0; i<plaintype.length(); i++)
{
m.add_item_tts(plaintype[i],plaintype[i],"",true);
}
int mres=m.run("aircrafts menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=aircrafts.length())
{
plaintyp=plaintype[mres-1];
}
return m.get_item_name(mres);
}
int aircrafts_callback(dynamic_menu_pro@ m, string data)
{
string plaintype;
if(m.menu_position>0)
plaintype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/aircrafts/"+plaintype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/aircrafts/"+plaintype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/aircrafts/"+plaintype+"/*engin*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/aircrafts/"+plaintype+"/*death*"), false);
}
return 0;
}
string vehsmenu()
{
string[] vehtype=get_map_sound_folders("objects/vehicles/*");
setupmenu();
m.set_callback(@vehicles_callback,"");
for (uint i=0; i<vehtype.length(); i++)
{
m.add_item_tts(vehtype[i],vehtype[i],"",true);
}
int mres=m.run("vehicles menu", true);
if(mres==0)
{
speak("canceled");
}
if(mres>0 and mres<=vehicles.length())
{
vehtyp=vehtype[mres-1];
}
return m.get_item_name(mres);
}
int vehicles_callback(dynamic_menu_pro@ m, string data)
{
string vehtype;
if(m.menu_position>0)
vehtype=m.item_list[m.menu_position-1].name;
if(key_down(KEY_SPACE) and m.menu_position>0 and spacehold==1 and keytimer.elapsed>=keytime)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/vehicles/"+vehtype+"/*hurt*"), false);
keytimer.restart();
}
if(key_pressed(KEY_SPACE) and m.menu_position>0 and spacehold==0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/vehicles/"+vehtype+"/*hurt*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_L) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_L) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/vehicles/"+vehtype+"/*motor*"), false);
}
if(key_down(KEY_LCONTROL) and key_repeating(KEY_H) and m.menu_position>0 or key_down(KEY_RCONTROL) and key_repeating(KEY_H) and m.menu_position>0)
{
t.destroy_sound(prevslot);
prevslot=t.play_stationary(get_map_sound("objects/vehicles/"+vehtype+"/*death*"), false);
}
return 0;
}
