void mapmenu()
{
setupmenu(true);
m.add_item_tts("load compiled map", "mg");
m.add_item_tts("load decompiled map", "mg2");
m.add_item_tts("compile map", "cpm");
m.add_item_tts("decompile map", "dpm");
m.add_item_tts("new map", "nm");
m.add_item_tts("back", "back");
int mres=m.run("Map menu",true);
string buildem=m.get_item_name(mres);
if(mres==0)
{
mainmenu();
}
if(buildem=="mg")
{
m.fade_music();
string[] maps=find_files("data/maps/compiled/*.map");
if(maps.length()==0)
{
dlg_snd("Error. There are no compiled maps available to view. Press enter to continue.");
mapmenu();
}
else
{
m.fade_music();
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".map", "", true);
    string map_path = "data/maps/compiled/" + temp_map_name + ".map";
string temp_owner="";
    string temp_map_data = "";
    if (map_pack.open(map_path, PACK_OPEN_MODE_READ))
    {
        if (map_pack.file_exists("info.sif"))
        {
uint size = map_pack.get_file_size("info.sif");
            string info_data = map_pack.read_file("info.sif", 0, size);
            string[] lines = delinear(info_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "owner" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
}
        map_pack.close();
}
    uint64 size = file_get_size(map_path);
    string readable_size = measure_file_size(size);
    m.add_item_tts(temp_map_name + " (by " + temp_owner + ": total size: " + readable_size + ")");
}
int mres=m.run("Compiled maps menu", true);
if(mres==0)
{
mapmenu();
}
if (mres==0 and mres>=maps.length())
{
mapmenu();
}
if (mres>0 and mres<=maps.length())
{
mapname=maps[mres-1];
mapname=string_replace(mapname, ".map", "", true);
load_map(mapname, mapowner, force_compiled:true, force_spawned:true);
game();
}
}
}
if(buildem=="mg2")
{
m.fade_music();
string[] maps=find_directories("data/maps/decompiled/*");
if(maps.length()==0)
{
dlg_snd("Error. There are no decompiled maps available to view. Press enter to continue.");
mapmenu();
}
else
{
m.fade_music();
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".sif", "", true);
mapper.open("data/maps/decompiled/"+temp_map_name+"/"+"info.sif", "rb");
string temp_map_data = mapper.read();
mapper.close();            
string temp_owner;
string[] lines = delinear(temp_map_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "owner" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
uint64 size = get_directory_size("data/maps/decompiled/" + maps[i]);
string readable_size = measure_file_size(size);
m.add_item_tts(temp_map_name + " (by " + temp_owner + ": total size: " + readable_size+")", maps[i]);
}
int mres=m.run("Decompiled maps menu", true);
if(mres==0)
{
mapmenu();
}
if (mres==0 and mres>=maps.length())
{
mapmenu();
}
if (mres>0 and mres<=maps.length())
{
mapname=maps[mres-1];
mapname=string_replace(mapname, ".sif", "", true);
load_map(mapname, mapowner, force_compiled:false, force_spawned:true);
game();
}
}
}
if (buildem == "cpm")
{
m.fade_music();
compile_map();
}
if (buildem == "dpm")
{
m.fade_music();
decompile_map();
}
if(buildem=="nm")
{
m.fade_music();
vd.set_disallowed_chars("", false, "This character is not allowed.");
string name=vd.input_box("","Enter the name of this map.");
string name2=vd.input_box("","Enter the owner of this map. Press enter to use the default owner.", "noone");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("","Enter the minimum length of this map.");
string mx2=vd.input_box("","Enter the maximum length of this map.");
string my=vd.input_box("","Enter the minimum height of this map.");
string my2=vd.input_box("","Enter the maximum height of this map.");
if(mapname=="" and mapowner=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
string mapowner=name2;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
if(directory_exists("data/maps/decompiled/"+mapname))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
mapmenu();
}
else
{
create_map(mapname, mapowner, minx, maxx, miny, maxy);
load_map(mapname, mapowner);
game();
}
}
if(buildem=="back")
{
mainmenu();
}
}
void mapmenu2()
{
setupmenu();
m.add_item_tts("add a line", "addline");
m.add_item_tts("edit a line", "editline");
m.add_item_tts("remove a line", "remline");
m.add_item_tts("copy raw map data to clipboard", "clboard");
m.add_item_tts("paste raw map data from clipboard", "clboard2");
m.add_item_tts("Go to a zone on the map","gmz");
m.add_item_tts("delete map", "dcm");
m.add_item_tts("load decompiled map", "lm");
m.add_item_tts("new map", "nm");
m.add_item_tts("reload map", "rcm");
int mres=m.run("Map menu",true);
string mapem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mapem=="addline")
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "ab");
mapdata=mapper.read();
vd.set_disallowed_chars("", false, "This character is not allowed.");
string newline=vd.input_box("","Enter the line you'd like to add.");
mapper.write("\r\n"+newline);
mapper.close();
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(mapem=="remline")
{
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to remove", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>=1 and mres<=5)
{
resume_pools();
speak("This line cannot be removed.");
return;
}
if(mres>5 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
lines.remove_at(original_index);
string final;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) final+="\r\n";
final+=lines[i];
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapdata=mapper.read();
mapper.write(final);
mapper.close();
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
}
if(mapem=="editline")
{
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
mapper.close();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to edit", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>0 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
vd.set_disallowed_chars("", false, "This character is not allowed.");
string final=vd.input_box("","line editor", lines[original_index]);
lines[original_index]=final; 
string mapline;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) mapline+="\r\n";
mapline += lines[i];
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapper.write(mapline);
mapper.close();
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
}
if(mapem=="dcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete "+mapname+"? This action cannot be undone.",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
if(directory_exists("data/maps/decompiled/"+mapname)) directory_delete("data/maps/decompiled/"+mapname);
speak("map deleted");
dlgplay(get_pack_sound("misc/mapdelete.ogg"),false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(mapem=="gmz")
{
if (zones.length() == 0)
{
resume_pools();
speak("There are no zones available on this map.");
return;
}
setupmenu();
for (uint i = 0; i < zones.length(); i++)
{
double width = zones[i].maxx - zones[i].minx + 1;
double height = zones[i].maxy - zones[i].miny + 1;
string zone_desc = zones[i].text + ", " +int(width) + " x " + int(height) + " zone, at " +int(zones[i].minx) + ", " + int(zones[i].miny);
m.add_item_tts(zone_desc, zones[i].text);
}
int mres=m.run("Choose the zone you'd like to go to. There are "+zones.length()+" zones available on this map.", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if (mres==0 and mres>=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
if (mres>0 and mres<=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
}
if(mapem=="clboard")
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
if(mapem=="clboard2")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
string clipboard_data = clipboard_read_text();
if (clipboard_data == "")
{
dlg_snd("Error. The clipboard is empty.");
resume_pools();
return;
}
string[] lines = string_split(clipboard_data, "\r\n", true);
bool is_valid = validate_map_data(lines);
if (!is_valid)
{
dlg_snd("Error. The clipboard data is invalid.");
resume_pools();
return;
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapper.write(clipboard_data);
mapper.close();
load_map(mapname, mapowner, force_spawned:true);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"), false);
speak("Map updated.");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(mapem=="lm")
{
string[] maps=find_directories("data/maps/decompiled/*");
if(maps.length()==0)
{
dlg_snd("Error. There are no decompiled maps available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".sif", "", true);
mapper.open("data/maps/decompiled/"+temp_map_name+"/"+"info.sif", "rb");
string temp_map_data = mapper.read();
mapper.close();            
string temp_owner;
string[] lines = delinear(temp_map_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "owner" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
uint64 size = get_directory_size("data/maps/decompiled/" + maps[i]);
string readable_size = measure_file_size(size);
m.add_item_tts(temp_map_name + " (by " + temp_owner + ": total size: " + readable_size+")", maps[i]);
}
int mres=m.run("Decompiled maps menu", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if (mres==0 and mres>=maps.length())
{
resume_pools();
speak("canceled");
return;
}
if (mres>0 and mres<=maps.length())
{
resume_pools();
mapname=maps[mres-1];
mapname=string_replace(mapname, ".sif", "", true);
load_map(mapname, mapowner, force_compiled:false, force_spawned:true);
}
}
}
if(mapem=="nm")
{
resume_pools();
vd.set_disallowed_chars("", false, "This character is not allowed.");
string name=vd.input_box("","Enter the name of this map.");
string name2=vd.input_box("","Enter the owner of this map. Press enter to use the default owner.", "noone");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("","Enter the minimum length of this map.");
string mx2=vd.input_box("","Enter the maximum length of this map.");
string my=vd.input_box("","Enter the minimum height of this map.");
string my2=vd.input_box("","Enter the maximum height of this map.");
if(mapname=="" and mapowner=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
string mapowner=name2;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
if(directory_exists("data/maps/decompiled/"+mapname))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
return;
}
else
{
create_map(mapname, mapowner, minx, maxx, miny, maxy);
load_map(mapname, mapowner);
}
}
if(mapem=="rcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload "+mapname+"?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
load_map(mapname, mapowner, anounce_mapload:false, force_compiled:map_is_compiled, force_spawned:true);
speak("map reloaded");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
}
