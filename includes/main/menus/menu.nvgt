void mainmenu()
{
setupmenu(true);
if(hidedocks==false) m.add_item_tts("documentation menu", "help");
if(hidemaps==false) m.add_item_tts("map menu", "map");
if(hidemisc==false) m.add_item_tts("miscellaneous menu", "msm");
if(hidesets==false) m.add_item_tts("settings menu", "settings");
m.add_item_tts("check for updates", "chup");
if(directory_exists("sounds") and !directory_empty("sounds") and system_is_windows) m.add_item_tts("redownload all sounds", "rdl");
m.add_item_tts("test speakers", "st");
if(system_is_windows) m.add_item_tts("restart game", "rx");
m.add_item_tts("exit game", "ex");
int mres=m.run("Main menu. Please choose an option with your arrow keys, then press enter to activate one.",true);
string main=m.get_item_name(mres);
if(mres==0)
{
speak("exiting");
m.fade_music();
exit();
}
if(main=="map")
{
mapmenu();
}
if(main=="msm")
{
miscmenu();
}
if(main=="help")
{
docksmenu();
}
if(main=="rdl")
{
m.fade_music();
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete and redownload all sounds? This action cannot be undone.",true);
if(mres==0)
{
speak("canceled");
mainmenu();
}
if(mres==1)
{
if(directory_exists("sounds")) directory_delete("sounds");
downloadsounds();
}
if(mres==2)
{
mainmenu();
}
}
if(main=="st")
{
m.fade_music();
dlgplay(get_pack_sound("menus/"+menutype+"/*speaker*"), true, true, 30);
mainmenu();
}
if(main=="ex")
{
speak("exiting");
m.fade_music();
exit();
}
if (main == "chup")
{
m.fade_music();
check_for_updates(version, "SimpleFighter", true);
}
if(main=="rx")
{
speak("restarting");
m.fade_music();
restart("sf.exe");
}
if(main=="settings")
{
m.fade_music();
settingsmenu();
}
}
void miscmenu()
{
setupmenu(true);
m.add_item_tts("layouts editor", "ldr");
m.add_item_tts("layouts viewer", "ldv");
m.add_item_tts("misc sounds viewer", "msr");
m.add_item_tts("back", "back");
int mres=m.run("Miscellaneous menu",true);
string mcm=m.get_item_name(mres);
if(mres==0)
{
mainmenu();
}
if(mcm=="ldr")
{
m.fade_music();
edit_layouts();
}
if(mcm=="ldv")
{
m.fade_music();
view_layouts();
}
if(mcm=="msr")
{
m.fade_music();
string[] miscsound=find_files("sounds/"+soundpack+"/misc/*");
if(miscsound.length()==0)
{
dlg_snd("Error. There are no misc sounds available to view. Press enter to continue.");
miscmenu();
}
else
{
m.fade_music();
string res=miscsoundsmenu();
if(res!="")
{
string misctyp=res;
}
}
}
if(mcm=="back")
{
mainmenu();
}
}
void edit_layouts()
{
    setupmenu();
    m.add_item_tts("Characters", "characters");
    m.add_item_tts("Shields", "shields");
    m.add_item_tts("Weapons", "weapons");
    m.add_item_tts("Back", "back");
    int res = m.run("Select a layout type to edit", true);
    string choice = m.get_item_name(res);
    if (choice == "back" || res == 0)
{
        miscmenu();
        return;
    }
    string path = "data/layouts/" + choice + "/";
    string selected = "";
    string category = "";
    if (choice == "weapons")
    {
        setupmenu();
        string[] categories = find_directories(path + "*");
        for (uint i = 0; i < categories.length(); i++)
            m.add_item_tts(categories[i], categories[i]);
        m.add_item_tts("Create new category", "new_cat");
        m.add_item_tts("Back", "back");
        int c_res = m.run("Select a weapon category to edit", true);
        category = m.get_item_name(c_res);
        if (category == "back" || c_res == 0)
{
            edit_layouts();
            return;
        }
        if (category == "new_cat")
{
            category = input_box("category name", "Enter new category name:");
            if (category == "")
{
                edit_layouts();
                return;
            }
            directory_create(path + category);
        }
        setupmenu();
        string[] weapons = find_directories(path + category + "/*");
        for (uint i = 0; i < weapons.length(); i++)
            m.add_item_tts(weapons[i], weapons[i]);
        m.add_item_tts("Create new weapon", "new");
        m.add_item_tts("Back", "back");
        int w_res = m.run("Select a weapon to edit", true);
        selected = m.get_item_name(w_res);
        if (selected == "back" || w_res == 0)
{
            edit_layouts();
            return;
        }
        if (selected == "new")
{
            selected = input_box("weapon name", "Enter new weapon name:");
            if (selected == "")
{
                edit_layouts();
                return;
            }
            directory_create(path + category + "/" + selected);
        }
        path = path + category + "/" + selected + "/info.sif";
    }
    else
    {
        setupmenu();
        string[] entries = find_directories(path + "*");
        for (uint i = 0; i < entries.length(); i++)
            m.add_item_tts(entries[i], entries[i]);
        m.add_item_tts("Create a new layout", "new");
        m.add_item_tts("Back", "back");
        int l_res = m.run("Select the " + choice + " to edit", true);
        selected = m.get_item_name(l_res);
        if (selected == "back" || l_res == 0)
{
            edit_layouts();
            return;
        }
        if (selected == "new")
{
            selected = input_box("layout name", "Enter new " + choice + " name:");
            if (selected == "")
{
                edit_layouts();
                return;
            }
            directory_create(path + selected);
        }
        path = path + selected + "/info.sif";
    }
    string[] lines;
    file f;
    if (file_exists(path))
{
        if (!f.open(path, "rb"))
{
            alert("Error", "Could not open info.sif.");
            edit_layouts();
            return;
        }
        lines = string_split(f.read(), "\r\n", true);
        f.close();
    }
else
{
        alert("Notice", "info.sif not found. A new one will be created.");
    }
    while (true)
    {
        wait(5);
setupmenu();
        for (uint i = 0; i < lines.length(); i++) {
            string[] parts = string_split(lines[i], "=", true);
            if (parts.length() == 2)
                m.add_item_tts(parts[0] + "=" + parts[1], parts[0]);
        }
        m.add_item_tts("Add a stat line", "add");
        m.add_item_tts("Remove a stat line", "remove");
        m.add_item_tts("Save and exit", "save");
        m.add_item_tts("Back", "back");
        int ed_res = m.run("Editing " + selected, true);
        string option = m.get_item_name(ed_res);
        if (option == "save")
{
            file f;
            f.open(path, "wb");
            f.write(string_join(lines, "\r\n"));
            f.close();
            speak("Stat saved.");
edit_layouts();
        }
        if (option == "back" || ed_res == 0)
{
            edit_layouts();
            return;
        }
if (option == "add")
{
    string newline = input_box("Line editor", "Enter new line (key=value):");
    if (newline == "")
    {
        alert("Error", "No line added.");
        continue;
    }
    if (string_contains(newline, "=", 1) == -1)
    {
        alert("Error", "Invalid format. Use key=value.");
        continue;
    }
    lines.insert_last(newline);
    alert("Success", "Line added: " + newline);
    continue;
}
        else if (option == "remove")
{
            setupmenu();
            for (uint i = 0; i < lines.length(); i++) {
                string[] parts = string_split(lines[i], "=", true);
                if (parts.length() == 2)
                    m.add_item_tts(parts[0] + "=" + parts[1], parts[0]);
            }
            m.add_item_tts("Back", "back");
            int rm_res = m.run("Select a stat line to remove", true);
            string remove = m.get_item_name(rm_res);
            if (remove == "back" || rm_res == 0) continue;
            for (uint i = 0; i < lines.length(); i++)
{
                if (string_starts_with(lines[i], remove + "="))
{
                    lines.remove_at(i);
                    break;
                }
            }
        }
else
{
string val = "";
for (uint i = 0; i < lines.length(); i++)
{
    if (string_starts_with(lines[i], option + "="))
{
        val = string_trim_sides(lines[i].substr(option.length() + 1));
        break;
    }
}
string newval = input_box("Line editor", "Enter new value for " + option + ":", val);
if (newval == "")
{
    alert("Error", "No changes have been made to " + option + ".");
    continue;
}
            for (uint i = 0; i < lines.length(); i++)
{
                if (string_starts_with(lines[i], option + "="))
{
                    lines[i] = option + "=" + newval;
                    break;
                }
            }
        alert("Success", option + " set to " + newval + ".");
continue;
}
    }
}
void view_layouts()
{
    setupmenu();
    m.add_item_tts("Characters", "characters");
    m.add_item_tts("Shields", "shields");
    m.add_item_tts("Weapons", "weapons");
    m.add_item_tts("Back", "back");
    int res = m.run("Select a layout type to view", true);
    string choice = m.get_item_name(res);
    if (choice == "back" || res == 0) {
        miscmenu();
        return;
    }
    string path = "data/layouts/" + choice + "/";
    string selected = "";
    if (choice == "weapons")
    {
        setupmenu();
        string[] categories = find_directories(path + "*");
        for (uint i = 0; i < categories.length(); i++)
            m.add_item_tts(categories[i], categories[i]);
        m.add_item_tts("Back", "back");
        int c_res = m.run("Select a weapon category to view", true);
        string cat = m.get_item_name(c_res);
        if (cat == "back" || c_res == 0) {
            view_layouts();
            return;
        }
        setupmenu();
        string[] weapons = find_directories(path + cat + "/*");
        for (uint i = 0; i < weapons.length(); i++)
            m.add_item_tts(weapons[i], weapons[i]);
        m.add_item_tts("Back", "back");
        int w_res = m.run("Select a weapon to view", true);
        selected = m.get_item_name(w_res);
        if (selected == "back" || w_res == 0) {
            view_layouts();
            return;
        }
        path = path + cat + "/" + selected + "/info.sif";
    }
    else
    {
        setupmenu();
        string[] entries = find_directories(path + "*");
        for (uint i = 0; i < entries.length(); i++)
            m.add_item_tts(entries[i], entries[i]);
        m.add_item_tts("Back", "back");
        int l_res = m.run("Select the " + choice + " to view", true);
        selected = m.get_item_name(l_res);
        if (selected == "back" || l_res == 0) {
            view_layouts();
            return;
        }
        path = path + selected + "/info.sif";
    }
    if (!file_exists(path))
    {
        alert("Error", "info.sif does not exist at: " + path);
        view_layouts();
        return;
    }
    file f;
    if (!f.open(path, "rb")) {
        alert("Error", "Failed to open " + path);
        view_layouts();
        return;
    }
    string[] lines = string_split(f.read(), "\r\n", true);
    f.close();
    setupmenu();
    for (uint i = 0; i < lines.length(); i++) {
        if (lines[i] != "") m.add_item_tts(lines[i], "", "", false);
    }
    m.add_item_tts("Back", "back");
    m.run("Viewing info for " + selected, true);
    view_layouts();
}
void docksmenu()
{
setupmenu(true);
m.add_item_tts("changelog", "changelog");
m.add_item_tts("credits", "credits");
m.add_item_tts("readme", "readme");
m.add_item_tts("todo_list", "todo_list");
m.add_item_tts("back", "back");
int mres=m.run("Documentation menu",true);
string dnm=m.get_item_name(mres);
if(mres==0)
{
mainmenu();
}
if(dnm=="changelog")
{
m.fade_music();
dockread("docks/changelog.txt");
}
if(dnm=="credits")
{
m.fade_music();
dockread("docks/credits.txt");
}
if(dnm=="readme")
{
m.fade_music();
dockread("docks/readme.txt");
}
if(dnm=="todo_list")
{
m.fade_music();
dockread("docks/todo_list.txt");
}
if(dnm=="back")
{
mainmenu();
}
}
void hidemenu()
{
if(hidedocks==false)
{
hidstatus="unhidden";
}
else
{
hidstatus="hidden";
}
if(hidemaps==false)
{
hidstatus2="unhidden";
}
else
{
hidstatus2="hidden";
}
if(hidemisc==false)
{
hidstatus3="unhidden";
}
else
{
hidstatus3="hidden";
}
if(hidesets==false)
{
hidstatus4="unhidden";
}
else
{
hidstatus4="hidden";
}
setupmenu();
m.add_item_tts("Documentation menu. Status, "+hidstatus, "docks");
m.add_item_tts("Map menu. Status, "+hidstatus2, "maps");
m.add_item_tts("Miscellaneous menu. Status, "+hidstatus3, "misc");
m.add_item_tts("Settings menu. Status, "+hidstatus4, "settings");
m.add_item_tts("back", "back");
int mres=m.run("Choose the main menu items you'd like to show or hide.",true);
string hdm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
settingsmenu();
}
if(hdm=="docks")
{
if(hidedocks==false)
{
hidedocks=true;
hidstatus="hidden";
dlg("Documentation menu hidden. Press enter to continue.");
}
else
{
hidedocks=false;
hidstatus="unhidden";
dlg("Documentation menu unhidden. Press enter to continue.");
}
hidemenu();
}
if(hdm=="maps")
{
if(hidemaps==false)
{
hidemaps=true;
hidstatus2="hidden";
dlg("Map menu hidden. Press enter to continue.");
}
else
{
hidemaps=false;
hidstatus2="unhidden";
dlg("Map menu unhidden. Press enter to continue.");
}
hidemenu();
}
if(hdm=="misc")
{
if(hidemisc==false)
{
hidemisc=true;
hidstatus3="hidden";
dlg("Miscellaneous menu hidden. Press enter to continue.");
}
else
{
hidemisc=false;
hidstatus3="unhidden";
dlg("Miscellaneous menu unhidden. Press enter to continue.");
}
hidemenu();
}
if(hdm=="settings")
{
if(hidesets==false)
{
hidesets=true;
hidstatus4="hidden";
dlg("Settings menu hidden. Press enter to continue.");
}
else
{
hidesets=false;
hidstatus4="unhidden";
dlg("Settings menu unhidden. Press enter to continue.");
}
hidemenu();
}
if(hdm=="back")
{
speak("canceled");
settingsmenu();
}
}
void buildmenu()
{
setupmenu3();
string sub0 = "all";
sb.add_submenu(sub0);

string sub1  = "audio";
sb.add_submenu(sub1);
sb.add_item(sub1, "music ambience", "music_ambience");
sb.add_item(sub1, "music source", "music_source");
sb.add_item(sub1, "sound ambience", "sound_ambience");
sb.add_item(sub1, "sound source", "sound_source");
sb.add_item(sub1, "timed music", "timed_music");
sb.add_item(sub1, "timed source", "timed_source");

string sub2  = "combat";
sb.add_submenu(sub2);
sb.add_item(sub2, "boss", "boss");
sb.add_item(sub2, "helper", "helper");
sb.add_item(sub2, "turret", "turret");

string sub3  = "construction";
sb.add_submenu(sub3);
sb.add_item(sub3, "blockage", "blockage");
sb.add_item(sub3, "conveyor belt", "conveyor_belt");
sb.add_item(sub3, "destroyable platform", "destroyable_platform");
sb.add_item(sub3, "destroyable staircase", "destroyable_staircase");
sb.add_item(sub3, "destroyable wall", "destroyable_wall");
sb.add_item(sub3, "elevator floor", "elevator_floor");
sb.add_item(sub3, "moving platform", "moving_platform");
sb.add_item(sub3, "platform", "platform");
sb.add_item(sub3, "staircase", "staircase");
sb.add_item(sub3, "vanishing platform", "vanishing_platform");
sb.add_item(sub3, "wall", "wall");

string sub4  = "interaction";
sb.add_submenu(sub4);
sb.add_item(sub4, "command blocker", "command_blocker");
sb.add_item(sub4, "calendar", "calendar");
sb.add_item(sub4, "clock", "clock");
sb.add_item(sub4, "dialog", "dialog");
sb.add_item(sub4, "item", "item");
sb.add_item(sub4, "sign", "sign");
sb.add_item(sub4, "switch", "switch");
sb.add_item(sub4, "text square", "text_square");

string sub5  = "misc";
sb.add_submenu(sub5);
sb.add_item(sub5, "checkpoint", "checkpoint");
sb.add_item(sub5, "reverb space", "reverb_space");
sb.add_item(sub5, "spawnpoint", "spawnpoint");
sb.add_item(sub5, "timed text", "timed_text");
sb.add_item(sub5, "travelpoint", "travelpoint");
sb.add_item(sub5, "tts_enemie", "tts_enemie");

string sub6  = "npc";
sb.add_submenu(sub6);
sb.add_item(sub6, "animal", "animal");
sb.add_item(sub6, "human", "human");
sb.add_item(sub6, "projectile", "projectile");
sb.add_item(sub6, "robot", "robot");
sb.add_item(sub6, "zombie", "zombie");

string sub7  = "transitions";
sb.add_submenu(sub7);
sb.add_item(sub7, "door", "door");
sb.add_item(sub7, "elevator", "elevator");
sb.add_item(sub7, "lift", "lift");
sb.add_item(sub7, "lockable door", "lockable_door");
sb.add_item(sub7, "lockable passage", "lockable_passage");
sb.add_item(sub7, "passage", "passage");
sb.add_item(sub7, "teleporter", "teleporter");

string sub8  = "traps";
sb.add_submenu(sub8);
sb.add_item(sub8, "bomb", "bomb");
sb.add_item(sub8, "fire", "fire");
sb.add_item(sub8, "floor breaker", "floor_breaker");
sb.add_item(sub8, "force field", "force_field");
sb.add_item(sub8, "hazard", "hazard");
sb.add_item(sub8, "mine", "mine");
sb.add_item(sub8, "moving hazard", "moving_hazard");
sb.add_item(sub8, "security camera", "security_camera");
sb.add_item(sub8, "spike", "spike");
sb.add_item(sub8, "time bomb", "time_bomb");
sb.add_item(sub8, "vanishing hazard", "vanishing_hazard");

string sub9  = "transportation";
sb.add_submenu(sub9);
sb.add_item(sub9, "aircraft", "aircraft");
sb.add_item(sub9, "aircraft beacon", "aircraft_beacon");
sb.add_item(sub9, "bike", "bike");
sb.add_item(sub9, "vehicle", "vehicle");

string sub10 = "zones";
sb.add_submenu(sub10);
sb.add_item(sub10, "animal zone", "animal_zone");
sb.add_item(sub10, "bomb zone", "bomb_zone");
sb.add_item(sub10, "heal zone", "heal_zone");
sb.add_item(sub10, "human zone", "human_zone");
sb.add_item(sub10, "item zone", "item_zone");
sb.add_item(sub10, "menu zone", "menu_zone");
sb.add_item(sub10, "projectile zone", "projectile_zone");
sb.add_item(sub10, "robot zone", "robot_zone");
sb.add_item(sub10, "safe zone", "safe_zone");
sb.add_item(sub10, "zombie zone", "zombie_zone");
sb.add_item(sub10, "zone", "zone");

int all_index = sb.get_sub_index("all");
array<string> names;
dictionary id_lookup;
for (int i = 0; i < int(sb.subs.length()); i++)
{
    if (i == all_index)
        continue;
    submenu@ s = sb.subs[i];
    for (int j = 0; j < int(s.items.length()); j++)
    {
        names.insert_last(s.items[j].name);
        id_lookup[s.items[j].name] = s.items[j].id;
    }
}
names.sort_ascending();
sb.subs[all_index].items.resize(0);
for (int i = 0; i < int(names.length()); i++)
{
    string name = names[i];
    string id;
    id_lookup.get(name, id);
    sb.subs[all_index].items.insert_last(submenu_item(name, id));
}

int res = sb.run("Build menu");
if (res < 0)
{
resume_pools();
    speak("Canceled");
    return;
}
buildobj(sb.get_selected_item_id());
}
void infomenu()
{
setupmenu();
m.add_item_tts("total objects "+(aircrafts.length()+animals.length()+bikes.length()+bosses.length()+dest_plats.length()+dest_staircases.length()+dest_walls.length()+doors.length()+psdoors.length()+humans.length()+helpers.length()+projectiles.length()+robots.length()+spikes.length()+sucams.length()+turrets.length()+vehicles.length()+zombies.length()));
for(uint i=0; i<aircrafts.length(); i++)
{
m.add_item_tts(aircrafts[i].plaintype+" "+"at "+aircrafts[i].plainx+" "+aircrafts[i].plainy+" "+"HP"+round(aircrafts[i].plainhealth/aircrafts[i].plainmaxhealth*100,2)+"percent");
}
for(uint i=0; i<animals.length(); i++)
{
m.add_item_tts(animals[i].animaltype+" "+"at;"+animals[i].amx+" "+animals[i].amy+" "+"HP"+round(animals[i].animalhealth/animals[i].animalmaxhealth*100,2)+"percent"+" "+"level"+animals[i].amlevel);
}
for(uint i=0; i<bikes.length(); i++)
{
m.add_item_tts(bikes[i].biketype+" "+"at;"+bikes[i].bikex+" "+bikes[i].bikey+" "+"HP"+round(bikes[i].bikehealth/bikes[i].bikemaxhealth*100,2)+"percent");
}
for(uint i=0; i<bosses.length(); i++)
{
m.add_item_tts(bosses[i].bosstype+" "+"at;"+bosses[i].bossx+" "+bosses[i].bossy+" "+"HP"+round(bosses[i].bosshealth/bosses[i].bossmaxhealth*100,2)+"percent"+" "+"level"+bosses[i].bosslevel);
}
for(uint i=0; i<sucams.length(); i++)
{
m.add_item_tts(sucams[i].cameratype + " at " + sucams[i].sucamx + " " + sucams[i].sucamy + " facing " + (sucams[i].camdir == 1 ? "left" : "right") + " HP " + round(sucams[i].camhealth / sucams[i].cammaxhealth * 100, 2) + " percent" + " level " + sucams[i].camlevel
);
}
for(uint i=0; i<doors.length(); i++)
{
m.add_item_tts("door at;"+doors[i].startx+" "+doors[i].starty+" "+"HP"+round(doors[i].doorhealth/doors[i].doormaxhealth*100,2)+"percent");
}
for(uint i=0; i<psdoors.length(); i++)
{
m.add_item_tts("locked door at;"+psdoors[i].startx+" "+psdoors[i].starty+" "+"HP"+round(psdoors[i].psdoorhealth/psdoors[i].psdoormaxhealth*100,2)+"percent");
}
for(uint i=0; i<dest_plats.length(); i++)
{
m.add_item_tts("destroyable "+dest_plats[i].plat+" platform "+"at;"+dest_plats[i].minx+" "+dest_plats[i].miny+" "+"HP"+round(dest_plats[i].dest_plathealth/dest_plats[i].dest_platmaxhealth*100,2)+"percent");
}
for(uint i=0; i<dest_staircases.length(); i++)
{
m.add_item_tts("destroyable "+dest_staircases[i].stairstile+" staircase "+"at;"+dest_staircases[i].minx+" "+dest_staircases[i].miny+" "+"HP"+round(dest_staircases[i].dest_stairshealth/dest_staircases[i].dest_stairsmaxhealth*100,2)+"percent");
}
for(uint i=0; i<dest_walls.length(); i++)
{
m.add_item_tts("destroyable "+dest_walls[i].dest_wall+" "+"at;"+dest_walls[i].minx+" "+dest_walls[i].miny+" "+"HP"+round(dest_walls[i].dest_wallhealth/dest_walls[i].dest_wallmaxhealth*100,2)+"percent");
}
for(uint i=0; i<humans.length(); i++)
{
m.add_item_tts(humans[i].humantype+" "+"at;"+humans[i].humx+" "+humans[i].humy+" "+"HP"+round(humans[i].humanhealth/humans[i].humanmaxhealth*100,2)+"percent"+" "+"level"+humans[i].humlevel);
}
for(uint i=0; i<helpers.length(); i++)
{
m.add_item_tts(helpers[i].helpertype+" "+"at;"+helpers[i].helpx+" "+helpers[i].helpy+" "+"HP"+round(helpers[i].helperhealth/helpers[i].helpermaxhealth*100,2)+"percent"+" "+"level"+helpers[i].helplevel);
}
for(uint i=0; i<projectiles.length(); i++)
{
m.add_item_tts(projectiles[i].projtype+" "+"at;"+projectiles[i].prox+" "+projectiles[i].proy+" "+"HP"+round(projectiles[i].projhealth/projectiles[i].projmaxhealth*100,2)+"percent"+" "+"level"+projectiles[i].projlevel);
}
for(uint i=0; i<robots.length(); i++)
{
m.add_item_tts(robots[i].robottype+" "+"at;"+robots[i].robx+" "+robots[i].roby+" "+"HP"+round(robots[i].robothealth/robots[i].robotmaxhealth*100,2)+"percent"+" "+"level"+robots[i].roblevel);
}
for(uint i=0; i<spikes.length(); i++)
{
m.add_item_tts(spikes[i].spiketype+" "+"at;"+spikes[i].minx+" "+spikes[i].miny+" "+"HP"+round(spikes[i].spikehealth/spikes[i].spikemaxhealth*100,2)+"percent");
}
for(uint i=0; i<turrets.length(); i++)
{
m.add_item_tts(turrets[i].turtype+" "+"at;"+turrets[i].turx+" "+turrets[i].tury+" "+"HP"+round(turrets[i].turhealth/turrets[i].turmaxhealth*100,2)+"percent"+" "+"level"+turrets[i].turlevel);
}
for(uint i=0; i<vehicles.length(); i++)
{
m.add_item_tts(vehicles[i].vehtype+" "+"at;"+vehicles[i].vehx+" "+vehicles[i].vehy+" "+"HP"+round(vehicles[i].vehhealth/vehicles[i].vehmaxhealth*100,2)+"percent");
}
for(uint i=0; i<zombies.length(); i++)
{
m.add_item_tts(zombies[i].zombietype+" "+"at;"+zombies[i].zombx+" "+zombies[i].zomby+" "+"HP"+round(zombies[i].zombiehealth/zombies[i].zombiemaxhealth*100,2)+"percent"+" "+"level"+zombies[i].zomblevel);
}
int mres=m.run("Object info", true);
if(mres>=0)
{
resume_pools();
return;
}
}
void komlogmenu()
{
setupmenu();
m.add_item_tts("total entries "+kombatlog.length());
for (uint i = 0; i < kombatlog.length(); i++)
{
m.add_item_tts(kombatlog[i]);
}
int mres = m.run("Combat log", true);
if (mres >= 0)
{
resume_pools();
return;
}
}
void pointsmenu()
{
setupmenu();
m.add_item_tts("You're currently on level"+level+"with"+xp+"experience. Your next level requires"+(xprequiered-xp)+"experience");
m.add_item_tts("You have"+points+"points available to spend");
m.add_item_tts("upgrade maximum character attack,"+"currently set to;"+attack, "umat");
m.add_item_tts("upgrade maximum character defence,"+"currently set to;"+defence, "umd");
if(melee==false) m.add_item_tts("upgrade maximum weapon ammo,"+"currently set to;"+maxammo, "uma");
m.add_item_tts("upgrade maximum character health,"+"currently set to;"+maxhealth, "umh");
m.add_item_tts("upgrade maximum character stamina,"+"currently set to;"+maxstamina, "umt");
m.add_item_tts("upgrade maximum character lives,"+"currently set to;"+lifecard, "umlf");
if(drawnshield==true) m.add_item_tts("upgrade maximum shield strength,"+"currently set to;"+maxshieldstrength, "umst");
if(drawnshield==true) m.add_item_tts("upgrade maximum shield defence,"+"currently set to;"+shielddefence, "umsd");
m.add_item_tts("upgrade maximum horizontal weapon range,"+"currently set to;"+weprange, "umra1");
m.add_item_tts("upgrade maximum vertical weapon range,"+"currently set to;"+weprange2, "umra2");
m.add_item_tts("back", "back");
int mres=m.run("Points menu. ",true);
string ptmem=m.get_item_name(mres);
if(mres==0 or mres<=2)
{
resume_pools();
return;
}
if(ptmem=="umat")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string att=vd.input_box("","How much attack would you like to buy?");
if(attack=="")
return;
double tempstat=string_to_number(att);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
attack+=tempstat;
points-=tempstat;
update_char_attack(attack);
}
}
if(ptmem=="umd")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string def=vd.input_box("","How much defence would you like to buy?");
if(defence=="")
return;
double tempstat=string_to_number(def);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
defence+=tempstat;
points-=tempstat;
update_char_defence(defence);
}
}
if(ptmem=="uma")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string amm=vd.input_box("","How much ammo would you like to buy?");
if(ammo=="")
return;
double tempstat=string_to_number(amm);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
ammo+=tempstat;
points-=tempstat;
update_wep_ammo(ammo);
}
}
if(ptmem=="umh")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string hp=vd.input_box("","How much health would you like to buy?");
if(health=="")
return;
double tempstat=string_to_number(hp);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
maxhealth+=tempstat;
points-=tempstat;
update_char_maxhealth(maxhealth);
}
}
if(ptmem=="umt")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string stm=vd.input_box("","How much stamina would you like to buy?");
if(stamina=="")
return;
double tempstat=string_to_number(stm);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
maxstamina+=tempstat;
points-=tempstat;
update_char_maxstamina(maxstamina);
}
}
if(ptmem=="umlf")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string lc=vd.input_box("","How many lives would you like to buy?");
if(lifecard=="")
return;
double tempstat=string_to_number(lc);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
lifecard+=tempstat;
points-=tempstat;
update_char_lives(lifecard);
}
}
if(ptmem=="umst")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sg=vd.input_box("","How much shield strength would you like to buy?");
if(maxshieldstrength=="")
return;
double tempstat=string_to_number(sg);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
maxshieldstrength+=tempstat;
points-=tempstat;
update_shield_max_strength(maxshieldstrength);
}
}
if(ptmem=="umsd")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sd=vd.input_box("","How much shield defence would you like to buy?");
if(shielddefence=="")
return;
double tempstat=string_to_number(sd);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
shielddefence+=tempstat;
points-=tempstat;
update_shield_defence(shielddefence);
}
}
if(ptmem=="umra1")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=1)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string rg1=vd.input_box("","How much horizontal weapon range would you like to buy?");
if(weprange=="")
return;
double tempstat=string_to_number(rg1);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
weprange+=tempstat;
points-=tempstat;
update_wep_hl_range(weprange);
}
}
if(ptmem=="umra2")
{
if(points<=0)
{
dlg_snd("Error, you don't have enough points to complete this action. Press enter to continue.");
resume_pools();
return;
}
else if(points>=2)
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string rg2=vd.input_box("","How much vertical weapon range would you like to buy?");
if(weprange2=="")
return;
double tempstat=string_to_number(rg2);
if(charbuysound==1) p.play_stationary(get_pack_sound("characters/"+chartype+"/*buy*"),false);
resume_pools();
speak("Perchis completed.");
weprange2+=tempstat;
points-=tempstat;
update_wep_vl_range(weprange2);
}
}
if(ptmem=="back")
{
resume_pools();
return;
}
}
void weaponsmenu()
{
setupmenu();
m.add_item_tts("archery", "arro");
m.add_item_tts("artillery", "shoot");
m.add_item_tts("explosive", "bomb");
m.add_item_tts("melee", "swing");
int mres=m.run("Weapons menu",true);
string wpsm=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(wpsm=="arro")
{
string[] archers=get_pack_sound_folders("equipments/weapons/archery/*");
if(archers.length()==0)
{
dlg_snd("Error. There are no archery weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
weaponparse();
string res=archersmenu();
if(res!="")
{
drawable=true;
melee=false;
p.destroy_sound(refslot);
wepdef=0;
weapontype="archery";
t.destroy_sound(prevslot);
weapontype2=res;
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
}
if(wpsm=="shoot")
{
string[] fighters=get_pack_sound_folders("equipments/weapons/artillery/*");
if(fighters.length()==0)
{
dlg_snd("Error. There are no artillery weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
weaponparse();
string res=gunsmenu();
if(res!="")
{
drawable=true;
melee=false;
p.destroy_sound(refslot);
wepdef=0;
weapontype="artillery";
t.destroy_sound(prevslot);
weapontype2=res;
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
}
if(wpsm=="bomb")
{
string[] killers=get_pack_sound_folders("equipments/weapons/explosive/*");
if(killers.length()==0)
{
dlg_snd("Error. There are no explosive weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
weaponparse();
string res=explosesmenu();
if(res!="")
{
drawable=true;
melee=false;
p.destroy_sound(refslot);
wepdef=0;
weapontype="explosive";
t.destroy_sound(prevslot);
weapontype2=res;
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
}
if(wpsm=="swing")
{
string[] brawlers=get_pack_sound_folders("equipments/weapons/melee/*");
if(brawlers.length()==0)
{
dlg_snd("Error. There are no melee weapons available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
destroy_all_weapons();
weaponparse();
string res=meleesmenu();
if(res!="")
{
drawable=true;
melee=true;
p.destroy_sound(refslot);
wepdef=0;
weapontype="melee";
t.destroy_sound(prevslot);
weapontype2=res;
draw_weapon(weapontype, weapontype2, weprange, weprange2, wepdamage, wepspeed, maxammo, melee);
}
}
}
}
void pausemenu()
{
setupmenu();
m.add_item_tts("resume game", "rmg");
m.add_item_tts("view statistics", "vs");
int mres=m.run("Pause menu. ",true);
string psmem=m.get_item_name(mres);
if(mres==0)
{
p.play_stationary(get_pack_sound("misc/resume.ogg"),false);
resume_game();
return;
}
if(psmem=="rmg")
{
p.play_stationary(get_pack_sound("misc/resume.ogg"),false);
resume_game();
return;
}
if(psmem=="vs")
{
statsmenu();
}
}
