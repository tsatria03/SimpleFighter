int invpos;
dictionary inv;

void give(string item, int amount)
{
int a;
if (!inv.exists(item))
{
inv.set(item,amount);
}
else
{
inv.get(item,a);
if (a+amount<=0)
inv.delete(item);
else
inv.set(item,a+amount);
}
}
void drop_item(string direction, string objtype, string objtype2)
{
if(direction=="left")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/health/"+objtype2+"/*drop*"), me.x-1, me.y, me.x-1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x-1, me.y, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/other/"+objtype2+"/*drop*"), me.x-1, me.y, me.x-1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x-1, me.y, 500, "other", objtype2, true);
}
}
else if(direction=="right")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/health/"+objtype2+"/*drop*"), me.x+1, me.y, me.x+1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x+1, me.y, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/other/"+objtype2+"/*drop*"), me.x+1, me.y, me.x+1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x+1, me.y, 500, "other", objtype2, true);
}
}
else if(direction=="up")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/health/"+objtype2+"/*drop*"), me.x, me.y+1, me.x, me.y+1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y+1, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/other/"+objtype2+"/*drop*"), me.x, me.y+1, me.x, me.y+1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y+1, 500, "other", objtype2, true);
}
}
else if(direction=="down")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/health/"+objtype2+"/*drop*"), me.x, me.y-1, me.x, me.y-1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y-1, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_map_sound("objects/items/other/"+objtype2+"/*drop*"), me.x, me.y-1, me.x, me.y-1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y-1, 500, "other", objtype2, true);
}
}
}
void focus_item(const string&in item)
{
    string[] keys = inv.get_keys();
    keys.sort_ascending();
    for (uint i = 0; i < keys.length(); i++)
    {
        if (keys[i] == item)
        {
            invpos = i;
            return;
        }
    }
}
void clear_inv()
{
inv.delete_all();
}
void cycle_inv(int dir)
{
    if (inv.get_size() == 0)
    {
        p.destroy_sound(invslot);
        speak("empty");
        return;
    }
    string[] keys = inv.get_keys();
    keys.sort_ascending();
    if (dir == 1)
        invpos += 1;
    else
        invpos -= 1;
    if (invpos >= keys.length())
        invpos = 0;
    else if (invpos < 0)
        invpos = keys.length() - 1;
    double invpan = convert_to_pan(keys.length(), invpos, -25, 25);
    if (charinvsound == 1) invslot = p.play_stationary_extended(get_pack_sound("characters/" + chartype + "/*inv*"), false, 0, invpan, 0, 100, false);
    int a;
    inv.get(keys[invpos], a);
    if (a == 1)
        speak(keys[invpos] + ". Item " + (invpos + 1) + " of " + keys.length());
    else
        speak(keys[invpos] + "s, " + a + ". Item " + (invpos + 1) + " of " + keys.length());
}
void useitem(string current)
{
string[] healtype=get_map_sound_folders("objects/items/health/*");
string[] healtype2=get_map_sound_folders("objects/items/stamina/*");
string[] misktype=get_map_sound_folders("objects/items/other/*");
for(uint i1=0; i1<healtype.length(); i1++)
{
for(uint i2=0; i2<healtype2.length(); i2++)
{
for (uint i3=0; i3<misktype.length(); i3++)
{
if (inv.get_size()<=0)
{
speak("No items");
}
else
{
string[] keys = inv.get_keys();
keys.sort_ascending();

if (invpos < 0 || invpos >= keys.length())
    return;

current = keys[invpos];
if(current==healtype[i1])
{
if(health>=maxhealth)
{
speak("You don't need to use this!");
return;
}
if(firesound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/health/"+healtype[i1]+"/*fire*"),false,0,0,itemvolume,itempitch,false);
if(hitsound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/health/"+healtype[i1]+"/*hit*"),false,0,0,itemvolume,itempitch,false);
give(healtype[i1],-1);
double heal_percent = random(5, 10);
double heal_amount = maxhealth * (heal_percent / 100.0);
health = min(health + heal_amount, maxhealth);
hearttime = min(health + heal_amount, maxhealth);
speak("healed to"+round(health/maxhealth*100,2)+"percent health");
return;
}
if(current==healtype2[i2])
{
if(stamina>=maxstamina)
{
speak("You don't need to use this!");
return;
}
if(firesound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/stamina/"+healtype2[i2]+"/*fire*"),false,0,0,itemvolume,itempitch,false);
if(hitsound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/stamina/"+healtype2[i2]+"/*hit*"),false,0,0,itemvolume,itempitch,false);
give(healtype2[i2],-1);
double heal_percent = random(5, 10);
double heal_amount = maxstamina * (heal_percent / 100.0);
stamina = min(stamina + heal_amount, maxstamina);
speak("healed to"+round(stamina/maxstamina*100,2)+"percent stamina");
return;
}
if(current==misktype[i3])
{
if (current == "healing_cast")
{
if (broken_bones.get_size() == 0)
{
speak("You don't need to use this!");
return;
}
itemslot = p.play_stationary_extended(get_map_sound("objects/items/other/healing_cast/*healstart*"), false, 0, 0, itemvolume, itempitch, false);
speak("You apply the healing cast.");
heal_bones(random(5, 10));
return;
}
if(current == "health_scanner")
{
itemslot = p.play_stationary_extended(get_map_sound("objects/items/other/health_scanner/*scanstart*"), false, 0, 0, itemvolume, itempitch, false);
itemslot = p.play_stationary_extended(get_map_sound("objects/items/other/health_scanner/*scanning*"), false, 0, 0, itemvolume, itempitch, false);
speak("scanning");
wait(random(500, 1000));
itemslot = p.play_stationary_extended(get_map_sound("objects/items/other/health_scanner/*scanstop*"), false, 0, 0, itemvolume, itempitch, false);
array<string> keys = broken_bones.get_keys();
if (keys.length() == 0)
{
speak("The scan results show that you have no broken bones.");
}
else
{
string message = "The scan results show that you ";
if (keys.length() == 1)
{
string part = keys[0];
string status;
broken_bones.get(part, status);
string spoken_part = part.replace("_", " ");
message += status + " your " + spoken_part + ".";
}
else
{
for (uint i = 0; i < keys.length(); i++)
{
string part = keys[i];
string status;
broken_bones.get(part, status);
string spoken_part = part.replace("_", " ");
message += status + " your " + spoken_part;
if (i == keys.length() - 2)
message += ", and ";
else if (i < keys.length() - 2)
message += ", ";
else
message += ".";
}
}
speak(message);
}
return;
}
if(firesound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/other/"+misktype[i3]+"/*fire*"),false,0,0,itemvolume,itempitch,false);
if(hitsound==1) itemslot=p.play_stationary_extended(get_map_sound("objects/items/other/"+misktype[i3]+"/*hit*"),false,0,0,itemvolume,itempitch,false);
give(misktype[i3],-1);
speak(misktype[i3]+";"+"recycled");
return;
}
}
}
}
}
}
int count_total_items()
{
return inv.get_keys().length();
}
string getitem()
{
if (inv.get_size()<=0)
{
return "";
}
else
{
string current=inv.get_keys()[invpos];
return current;
}
}
int item_exists(string item)
{
string[] current=inv.get_keys();
int index=current.find(item);
if (index>-1)
{
int ab;
inv.get(current[index],ab);
return ab;
}
else
return -1;
}
