bool hookable=true;
bool onhook;
int hookslot;

class hook
{
int base_hook_delay = 100;
int current_hook_delay = 0;
int hook_extencions=50;
    int hook_max_range = 20;
    int hook_direction = 0;
double hook_start_x;
double hook_start_y;
    double hook_target_x;
    double hook_target_y;
    int hook_type = 0; 
    int hook_target_index = -1;
    bool hook_pending = false;
    bool hook_catch = false;
    double pending_x;
    double pending_y;
    int pending_type;
    int pending_index;
    timer hooktimer;
    void set_direction(int dir)
    {
        hook_direction = dir;
    }
    bool tile_valid(double tx, double ty)
    {
        string t = gmt(tx, ty);
        if(t != "" && t != "air")
        {
            pending_type = 1;
            pending_index = -1;
            return true;
        }
        for(uint i=0;i<walls.length();i++)
        {
            if(tx>=walls[i].minx && tx<=walls[i].maxx && ty>=walls[i].miny && ty<=walls[i].maxy)
            {
                pending_type = 2;
                pending_index = i;
                return true;
            }
        }
        for(uint i=0;i<staircases.length();i++)
        {
            if(tx>=staircases[i].minx && tx<=staircases[i].maxx && ty>=staircases[i].miny && ty<=staircases[i].maxy)
            {
                pending_type = 3;
                pending_index = i;
                return true;
            }
        }
        for(uint i=0;i<vanishing_platforms.length();i++)
        {
            if(!vanishing_platforms[i].vanished && tx>=vanishing_platforms[i].minx && tx<=vanishing_platforms[i].maxx && ty>=vanishing_platforms[i].miny && ty<=vanishing_platforms[i].maxy)
            {
                pending_type = 4;
                pending_index = i;
                return true;
            }
        }
        for(uint i=0;i<moving_platforms.length();i++)
        {
            if(tx>=moving_platforms[i].currentx && tx<=moving_platforms[i].currentx+moving_platforms[i].sizex && ty==moving_platforms[i].currenty)
            {
                pending_type = 5;
                pending_index = i;
                return true;
            }
        }
        return false;
    }
    void throw_hook()
    {
        if(onhook || hook_pending) return;
        hookslot = hookpool.play_stationary(get_pack_sound("map/"+maptype+"/hook/*throw*"), false);
        int dx = 0;
        int dy = 0;
        if(hook_direction==0) dx=1;
        if(hook_direction==1) dx=-1;
        if(hook_direction==2) dy=1;
        if(hook_direction==3) dy=-1;
        double cx = me.x;
        double cy = me.y;
        hook_catch = false;
        for(int i=1; i<=hook_max_range*hook_extencions; i++)
        {
            double tx = cx + dx*i;
            double ty = cy + dy*i;
            if(tile_valid(tx,ty))
            {
                hook_catch = true;
                pending_x = tx;
                pending_y = ty;
                break;
            }
        }
        if(base_hook_delay <= 0)
        {
            apply_hook(dx, dy);
        }
        else
        {
            hook_pending = true;
            hooktimer.restart();
current_hook_delay = base_hook_delay+hook_max_range*hook_extencions;
        }
    }
    void update_hook()
    {
        if(!hook_pending) return;
        if(hooktimer.elapsed >= current_hook_delay)
        {
            hook_pending = false;
            int dx = 0;
            int dy = 0;
            if(hook_direction==0) dx=1;
            if(hook_direction==1) dx=-1;
            if(hook_direction==2) dy=1;
            if(hook_direction==3) dy=-1;
            apply_hook(dx, dy);
        }
    }
    void apply_hook(int dx, int dy)
    {
        if(hook_catch)
        {
            hook_target_x = pending_x;
            hook_target_y = pending_y;
            hook_type = pending_type;
            hook_target_index = pending_index;
hook_start_x = me.x;
hook_start_y = me.y;
            me.x += dx;
            me.y += dy;
            onhook = true;
            hookslot = hookpool.play_stationary(get_pack_sound("map/"+maptype+"/hook/*catch*"), false);
        }
        else
        {
            hookslot = hookpool.play_stationary(get_pack_sound("map/"+maptype+"/hook/*drop*"), false);
        }
    }
    void release_hook()
    {
        if(!onhook) return;
        onhook = false;
        hook_type = 0;
        hook_target_index = -1;
        hookslot = hookpool.play_stationary(get_pack_sound("map/"+maptype+"/hook/*release*"), false);
    }
void move_hook(int dx, int dy)
{
    if(!onhook) return;
    double nx = me.x + dx;
    double ny = me.y + dy;
    if(nx < minx || nx > maxx) return;
    if(ny < miny || ny > maxy) return;
    if(hook_direction == 2 || hook_direction == 3)
    {
        nx = hook_target_x;
        double lowY  = (hook_start_y < hook_target_y) ? hook_start_y : hook_target_y;
        double highY = (hook_start_y > hook_target_y) ? hook_start_y : hook_target_y;
        if(dy > 0 && ny >= highY)
        {
            me.x = nx;
            me.y = highY;
            playstep();
            release_hook();
            return;
        }
        if(dy < 0 && ny <= lowY)
        {
            me.x = nx;
            me.y = lowY;
            playstep();
            release_hook();
            return;
        }
    }
    if(hook_direction == 0 || hook_direction == 1)
    {
        ny = hook_target_y;
        double lowX  = (hook_start_x < hook_target_x) ? hook_start_x : hook_target_x;
        double highX = (hook_start_x > hook_target_x) ? hook_start_x : hook_target_x;
        if(dx > 0 && nx >= highX)
        {
            me.x = highX;
            me.y = ny;
            playstep();
            release_hook();
            return;
        }
        if(dx < 0 && nx <= lowX)
        {
            me.x = lowX;
            me.y = ny;
            playstep();
            release_hook();
            return;
        }
    }
    me.x = nx;
    me.y = ny;
    if(jumping==0) hookslot = hookpool.play_stationary(get_pack_sound("map/"+maptype+"/hook/*step*"), false);
}
void validate_hook()
{
    if(!onhook) return;
    if(hook_type == 1)
    {
        string t = gmt(hook_target_x, hook_target_y);
        if(t == "" || t == "air")
        {
            release_hook();
        }
        return;
    }
    if(hook_type == 2)
    {
        if(hook_target_index < 0 || hook_target_index >= walls.length())
        {
            release_hook();
            return;
        }
        if(walls[hook_target_index].wallhealth <= 0)
        {
            release_hook();
            return;
        }
        return;
    }
    if(hook_type == 3)
    {
        if(hook_target_index < 0 || hook_target_index >= staircases.length())
        {
            release_hook();
            return;
        }
        if(staircases[hook_target_index].stairshealth <= 0)
        {
            release_hook();
            return;
        }
        return;
    }
    if(hook_type == 4)
    {
        if(hook_target_index < 0 || hook_target_index >= vanishing_platforms.length())
        {
            release_hook();
            return;
        }
        if(vanishing_platforms[hook_target_index].vanished)
        {
            release_hook();
            return;
        }
        return;
    }
    if(hook_type == 5)
    {
        if(hook_target_index < 0 || hook_target_index >= moving_platforms.length())
        {
            release_hook();
            return;
        }
        return;
    }
}
    void follow_moving_platform()
    {
        if(!onhook) return;
        if(hook_type != 5) return;
        if(hook_target_index < 0 || hook_target_index >= moving_platforms.length()) return;
        me.x += (moving_platforms[hook_target_index].currentx - hook_target_x);
        me.y += (moving_platforms[hook_target_index].currenty - hook_target_y);
        hook_target_x = moving_platforms[hook_target_index].currentx;
        hook_target_y = moving_platforms[hook_target_index].currenty;
    }
}
