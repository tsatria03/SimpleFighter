spike@[]spikes(0);
class spike
{
int defsound, hitsound, hurtsound, spikesound;
bool destroyable;
double minx, maxx, miny, maxy;
double spikehealth;
double spikemaxhealth;
int damage;
int spiketime;
string spiketype;
timer spiketimer;
spike(double mx,double mx2,double my,double my2,double hp,double maxhp,int dmg,int sp,string st,bool dtb)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
spikehealth=hp;
spikemaxhealth=maxhp;
damage=dmg;
spiketime=sp;
spiketype=st;
destroyable=dtb;
spikesound=spikepool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/spikes/"+spiketype+"/*loop*"),me.x,me.y,minx,miny,0,0,0,0,false,0,0,painvolume,painpitch,false);
spikepool.update_sound_2d(spikesound,minx,miny);
spikepool.update_sound_range_2d(spikesound, 0, maxx-minx, 0, maxy-miny);
}
}
void spikeloop()
{
for(uint i=0; i<spikes.length(); i++)
{
if(spikes[i].spiketimer.elapsed>=spikes[i].spiketime)
{
spikes[i].spikesound=spikepool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/spikes/"+spikes[i].spiketype+"/*loop*"),me.x,me.y,spikes[i].minx,spikes[i].miny,0,0,0,0,false,0,0,painvolume,painpitch,false);
spikepool.update_sound_2d(spikes[i].spikesound,spikes[i].minx,spikes[i].miny);
spikepool.update_sound_range_2d(spikes[i].spikesound, 0, spikes[i].maxx-spikes[i].minx, 0, spikes[i].maxy-spikes[i].miny);
spikes[i].spiketimer.restart();
if(spikes[i].minx<=me.x and spikes[i].maxx>=me.x and spikes[i].miny<=me.y and spikes[i].maxy>=me.y and shieldon==1 and paused==0)
{
if(shieldhitsound==1) shieldslot=p.play_stationary_extended(find_sound("sounds/"+soundpack+"/equipments/shields/"+shieldtype+"/*hit*"),false,0,0,shieldvolume,shieldpitch,false);
int sdm = max(1, (spikes[i].damage) - (shielddefence * 3));
shieldstrength -= sdm;
kombatlog.insert_last(spikes[i].spiketype + "'s attack took " + shieldtype + " " + sdm + " damage.");
}
else if(spikes[i].minx<=me.x and spikes[i].maxx>=me.x and spikes[i].miny<=me.y and spikes[i].maxy>=me.y and shieldon==0 and paused==0)
{
spikes[i].hitsound=spikepool.play_stationary_extended(find_sound("sounds/"+soundpack+"/objects/spikes/"+spikes[i].spiketype+"/*hit*"),false,0,0,painvolume,painpitch,false);
int dmg = max(1, (spikes[i].damage) - (defence * 3));
health -= dmg;
hearttime -= dmg;
kombatlog.insert_last(spikes[i].spiketype + "'s attack took you " + dmg + " damage.");
if (charhurtsound == 1)
{
string painfile;
int damage_percent = round((float(dmg) / float(maxhealth)) * 100, 0);
if (damage_percent <= 1)
{
painfile = find_sound("sounds/" + soundpack + "/characters/" + chartype + "/*hurt*");
}
else if (damage_percent >= 10)
{
painfile = find_sound("sounds/" + soundpack + "/characters/" + chartype + "/*crit*");
}
else
{
painfile = find_sound("sounds/" + soundpack + "/characters/" + chartype + "/*hurt*");
}
painslot = p.play_stationary_extended(painfile, false, 0, 0, painvolume, painpitch, false);
}
}
if(spikes[i].spikehealth<=0)
{
spikepool.destroy_sound(spikes[i].hurtsound);
spikepool.destroy_sound(spikes[i].spikesound);
spikes[i].defsound=spikepool.play_extended_2d(find_sound("sounds/"+soundpack+"/objects/spikes/"+spikes[i].spiketype+"/*death*"),me.x,me.y,spikes[i].minx,spikes[i].miny,0,0,0,0,false,0,0,painvolume,painpitch,false);
spikepool.update_sound_2d(spikes[i].defsound,spikes[i].minx,spikes[i].miny);
spikepool.update_sound_range_2d(spikes[i].defsound,0,spikes[i].maxx-spikes[i].minx,0,spikes[i].maxy-spikes[i].miny);
spikes.remove_at(i);
return;
}
}
}
}
void spawn_spike(double x1,double x2,double y1,double y2,double hp,double maxhp,int dmg,int sp,string spiketype,bool destroyable)
{
spike sp1(x1,x2,y1,y2,hp,maxhp,dmg,sp,spiketype,destroyable);
spikes.insert_last(sp1);
}
void destroy_all_spikes()
{
for(uint i=0; i<spikes.length(); i++)
{
spikepool.destroy_sound(spikes[i].spikesound);
}
spikes.resize(0);
}
