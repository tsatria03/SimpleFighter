animalzone@[]animalzones(0);
class animalzone
{
double minx, maxx;
int amy;
int spawntime;
string animaltype;
timer spawntimer;
animalzone(double mx,double mx2,int ay,int sp,string at)
{
minx=mx;
maxx=mx2;
amy=ay;
spawntime=sp;
animaltype=at;
}
}
void animalzoneloop()
{
for(uint i=0; i<animalzones.length(); i++)
{
if(animalzones[i].minx<=me.x and animalzones[i].maxx>=me.x and animalzones[i].amy==me.y and animalzones[i].spawntimer.elapsed>=animalzones[i].spawntime)
{
string[] animaltype=get_map_sound_folders("npc/animals/*");
string amtype = animalzones[i].animaltype;
if(amtype=="random" && animaltype.length()>0)
{
amtype=random_string(animaltype);
}
spawn_animal(random(animalzones[i].minx, animalzones[i].maxx), animalzones[i].amy, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, amtype, true, true, random_bool(), random_bool());
animalzones[i].spawntimer.restart();
}
}
}
void spawn_animalzone(double x1,double x2,int y,int sp,string type)
{
animalzone az1(x1,x2,y,sp,type);
animalzones.insert_last(az1);
}
void destroy_all_animalzones()
{
animalzones.resize(0);
}

humanzone@[]humanzones(0);
class humanzone
{
double minx, maxx;
int humy;
int spawntime;
string humantype;
timer spawntimer;
humanzone(double mx,double mx2,int huy,int sp,string et)
{
minx=mx;
maxx=mx2;
humy=huy;
spawntime=sp;
humantype=et;
}
}
void humanzoneloop()
{
for(uint i=0; i<humanzones.length(); i++)
{
if(humanzones[i].minx<=me.x and humanzones[i].maxx>=me.x and humanzones[i].humy==me.y and humanzones[i].spawntimer.elapsed>=humanzones[i].spawntime)
{
string[] humantype=get_map_sound_folders("npc/humans/*");
string humtype = humanzones[i].humantype;
if(humtype=="random" && humantype.length()>0)
{
humtype=random_string(humantype);
}
spawn_human(random(humanzones[i].minx, humanzones[i].maxx), humanzones[i].humy, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, 0, random(100, 1000), random(100, 1000), 1, 1*level, humtype, true, true, random_bool(), random_bool());
humanzones[i].spawntimer.restart();
}
}
}
void spawn_humanzone(double x1,double x2,int y,int sp,string type)
{
humanzone huz1(x1,x2,y,sp,type);
humanzones.insert_last(huz1);
}
void destroy_all_humanzones()
{
humanzones.resize(0);
}

projzone@[]projzones(0);
class projzone
{
double minx, maxx;
int proy;
int spawntime;
string projtype;
timer spawntimer;
projzone(double mx,double mx2,int py,int sp,string pt)
{
minx=mx;
maxx=mx2;
proy=py;
spawntime=sp;
projtype=pt;
}
}
void projzoneloop()
{
for(uint i=0; i<projzones.length(); i++)
{
if(projzones[i].minx<=me.x and projzones[i].maxx>=me.x and projzones[i].proy==me.y and projzones[i].spawntimer.elapsed>=projzones[i].spawntime)
{
string[] projtype=get_map_sound_folders("npc/projectiles/*");
string potype=projzones[i].projtype;
if(potype=="random" && projtype.length()>0)
{
potype=random_string(projtype);
}
spawn_projectile(random(projzones[i].minx, projzones[i].maxx), projzones[i].proy, random(0, 1), 1*xp+1, 1*xp+1, 1, 1*xp+1, random(50, 500), 1, 1*level, potype, true, true);
projzones[i].spawntimer.restart();
}
}
}
void spawn_projzone(double x1,double x2,int y,int sp,string type)
{
projzone pz1(x1,x2,y,sp,type);
projzones.insert_last(pz1);
}
void destroy_all_projzones()
{
projzones.resize(0);
}

robotzone@[]robotzones(0);
class robotzone
{
double minx, maxx;
int roby;
int spawntime;
string robtype;
timer spawntimer;
robotzone(double mx,double mx2,int ry,int sp,string rt)
{
minx=mx;
maxx=mx2;
roby=ry;
spawntime=sp;
robtype=rt;
}
}
void robotzoneloop()
{
for(uint i=0; i<robotzones.length(); i++)
{
if(robotzones[i].minx<=me.x and robotzones[i].maxx>=me.x and robotzones[i].roby==me.y and robotzones[i].spawntimer.elapsed>=robotzones[i].spawntime)
{
string[] robtype=get_map_sound_folders("npc/robots/*");
string rotype = robotzones[i].robtype;
if(rotype=="random" && robtype.length()>0)
{
rotype=random_string(robtype);
}
spawn_robot(random(robotzones[i].minx, robotzones[i].maxx), robotzones[i].roby, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, rotype, true, true, random_bool(), random_bool());
robotzones[i].spawntimer.restart();
}
}
}
void spawn_robotzone(double x1,double x2,int y,int sp,string type)
{
robotzone rz1(x1,x2,y,sp,type);
robotzones.insert_last(rz1);
}
void destroy_all_robotzones()
{
robotzones.resize(0);
}

zombiezone@[]zombiezones(0);
class zombiezone
{
double minx, maxx;
int zomby;
int spawntime;
string zombtype;
timer spawntimer;
zombiezone(double mx,double mx2,int zy,int sp,string zt)
{
minx=mx;
maxx=mx2;
zomby=zy;
spawntime=sp;
zombtype=zt;
}
}
void zombiezoneloop()
{
for(uint i=0; i<zombiezones.length(); i++)
{
if(zombiezones[i].minx<=me.x and zombiezones[i].maxx>=me.x and zombiezones[i].zomby==me.y and zombiezones[i].spawntimer.elapsed>=zombiezones[i].spawntime)
{
string[] zombtype=get_map_sound_folders("npc/zombies/*");
string zotype = zombiezones[i].zombtype;
if(zotype=="random" && zombtype.length()>0)
{
zotype=random_string(zombtype);
}
spawn_zombie(random(zombiezones[i].minx, zombiezones[i].maxx), zombiezones[i].zomby, 0, 0, maxx, maxy, 1*xp+1, 1*xp+1, 1, 1*xp+1, random(100, 1000), random(100, 1000), 1, 1*level, zotype, true, true, random_bool(), random_bool());
zombiezones[i].spawntimer.restart();
}
}
}
void spawn_zombiezone(double x1,double x2,int y,int sp,string type)
{
zombiezone zz1(x1,x2,y,sp,type);
zombiezones.insert_last(zz1);
}
void destroy_all_zombiezones()
{
zombiezones.resize(0);
}

healzone@[]healzones(0);
class healzone
{
bool in_zone;
int hitsound, healsound, takesound;
double minx, maxx, miny, maxy;
int healmode;
int healhp;
int healtime;
string healtype;
timer healtimer;
healzone(double mx,double mx2,double my,double my2,int hm,int hp,int ht,string hlt)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
healmode=hm;
healhp=hp;
healtime=ht;
healtype=hlt;
}
}
void healzoneloop()
{
for(uint i=0; i<healzones.length(); i++)
{
if(healzones[i].minx<=me.x and healzones[i].maxx>=me.x and healzones[i].miny<=me.y and healzones[i].maxy>=me.y and healzones[i].healtimer.elapsed>=healzones[i].healtime)
{
healzones[i].healtimer.restart();
if(healzones[i].healmode==0 and invehicle==false)
{
if(shieldon==1)
{
shieldstrength-=healzones[i].healhp;
}
else if(shieldon==0)
{
healzones[i].hitsound=healpool.play_stationary_extended(get_pack_sound("characters/"+chartype+"/*bleed*"),false,0,0,painvolume,painpitch,false);
health-=healzones[i].healhp;
hearttime-=healzones[i].healhp;
}
}
if(healzones[i].healmode==1 and invehicle==false)
{
if(shieldon==1)
{
shieldstrength+=healzones[i].healhp;
}
else if(shieldon==0)
{
health+=healzones[i].healhp;
hearttime+=healzones[i].healhp;
}
}
}
}
}
void spawn_healzone(double x1,double x2,double y1,double y2,int hm,int hp,int ht,string hlt)
{
healzone hz1(x1,x2,y1,y2,hm,hp,ht,hlt);
healzones.insert_last(hz1);
}
void destroy_all_healzones()
{
healzones.resize(0);
}

menuzone@[]menuzones(0);
class menuzone
{
double minx, maxx, miny, maxy;
menuzone(double mx,double mx2,double my,double my2)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
}
void menzmenu()
{
setupmenu();
m.add_item_tts("add a line", "addline");
m.add_item_tts("edit a line", "editline");
m.add_item_tts("remove a line", "remline");
m.add_item_tts("copy raw map data to clipboard", "clboard");
m.add_item_tts("paste raw map data from clipboard", "clboard2");
m.add_item_tts("Go to a zone on the map","gmz");
m.add_item_tts("delete map", "dcm");
m.add_item_tts("load decompiled map", "lm");
m.add_item_tts("new map", "nm");
m.add_item_tts("reload map", "rcm");
int mres=m.run("Map menu",true);
string mapem=m.get_item_name(mres);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mapem=="addline")
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "ab");
mapdata=mapper.read();
vd.set_disallowed_chars("", false, "This character is not allowed.");
string newline=vd.input_box("","Enter the line you'd like to add.");
mapper.write("\r\n"+newline);
mapper.close();
load_map(mapmode, mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(mapem=="remline")
{
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to remove", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>=1 and mres<=7)
{
resume_pools();
speak("This line cannot be removed.");
return;
}
if(mres>7 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
lines.remove_at(original_index);
string final;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) final+="\r\n";
final+=lines[i];
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapdata=mapper.read();
mapper.write(final);
mapper.close();
load_map(mapmode, mapname, mapowner);(mapname);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
}
if(mapem=="editline")
{
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
mapper.close();
string[] lines=string_split(mapdata, "\r\n", true);
string[] filtered_lines;
uint[] original_lines;
filter_empty_lines(lines, filtered_lines, original_lines);
setupmenu();
for (uint i=0; i<filtered_lines.length(); i++)
{
m.add_item_tts(filtered_lines[i],filtered_lines[i], "", true);
}
int mres=m.run("Select a line to edit", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres>0 and mres<=filtered_lines.length())
{
uint original_index=original_lines[mres-1];
vd.set_disallowed_chars("", false, "This character is not allowed.");
string final=vd.input_box("","line editor", lines[original_index]);
lines[original_index]=final; 
string mapline;
for (uint i=0; i<lines.length(); i++)
{
if(i>0) mapline+="\r\n";
mapline += lines[i];
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapper.write(mapline);
mapper.close();
load_map(mapmode, mapname, mapowner);(mapname);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
}
if(mapem=="dcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to delete "+mapname+"? This action cannot be undone.",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
if(fademode==0) fade_multi_pool(0);
if(fademode==1) fade_multi_pool(1);
if(directory_exists("data/maps/decompiled/"+mapname)) directory_delete("data/maps/decompiled/"+mapname);
speak("map deleted");
dlgplay(get_pack_sound("misc/mapdelete.ogg"),false);
me.x=0;
me.y=0;
clearmap();
destroymap();
mapmenu();
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(mapem=="gmz")
{
if (zones.length() == 0)
{
resume_pools();
speak("There are no zones available on this map.");
return;
}
setupmenu();
for (uint i = 0; i < zones.length(); i++)
{
double width = zones[i].maxx - zones[i].minx + 1;
double height = zones[i].maxy - zones[i].miny + 1;
string zone_desc = zones[i].text + ", " +int(width) + " x " + int(height) + " zone, at " +int(zones[i].minx) + ", " + int(zones[i].miny);
m.add_item_tts(zone_desc, zones[i].text);
}
int mres=m.run("Choose the zone you'd like to go to. There are "+zones.length()+" zones available on this map.", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if (mres==0 and mres>=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
if (mres>0 and mres<=zones.length())
{
int selected_zone_index = mres - 1;
zone@ selected_zone = zones[selected_zone_index];
double target_x = selected_zone.minx;
double target_y = selected_zone.miny;
resume_pools();
gop("me", "", target_x, target_y);
}
}
if(mapem=="clboard")
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "rb");
mapdata=mapper.read();
clipboard_copy_text(mapdata);
speak("The data of "+mapname+" has been copied to your clipboard");
mapper.close();
}
if(mapem=="clboard2")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to overwrite all existing map data with what's on your clipboard?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
string clipboard_data = clipboard_read_text();
if (clipboard_data == "")
{
dlg_snd("Error. The clipboard is empty.");
resume_pools();
return;
}
string[] lines = string_split(clipboard_data, "\r\n", true);
bool is_valid = validate_map_data(lines);
if (!is_valid)
{
dlg_snd("Error. The clipboard data is invalid.");
resume_pools();
return;
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif", "wb");
mapper.write(clipboard_data);
mapper.close();
load_map(mapmode, mapname, mapowner, force_spawned:true);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"), false);
speak("Map updated.");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
if(mapem=="lm")
{
string[] maps=find_directories("data/maps/decompiled/*");
if(maps.length()==0)
{
dlg_snd("Error. There are no decompiled maps available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
setupmenu();
for(uint i=0; i<maps.length(); i++)
{
string temp_map_name = string_replace(maps[i], ".sif", "", true);
mapper.open("data/maps/decompiled/"+temp_map_name+"/"+"info.sif", "rb");
string temp_map_data = mapper.read();
mapper.close();            
string temp_owner;
string[] lines = delinear(temp_map_data);
for (uint j = 0; j < lines.length(); j++)
{
string[] sd = string_split(lines[j], " ", true);
if (sd[0] == "owner" && sd.length() == 2)
{
temp_owner = sd[1];
break;
}
}            
uint64 size = get_directory_size("data/maps/decompiled/" + maps[i]);
string readable_size = measure_file_size(size);
m.add_item_tts(temp_map_name + " (by " + temp_owner + ". Total size: " + readable_size+")", maps[i]);
}
int mres=m.run("Decompiled maps menu", true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if (mres==0 and mres>=maps.length())
{
resume_pools();
speak("canceled");
return;
}
if (mres>0 and mres<=maps.length())
{
resume_pools();
mapname=maps[mres-1];
mapname=string_replace(mapname, ".sif", "", true);
me.x=0;
me.y=0;
load_map(mapmode, mapname, mapowner, force_compiled:false, force_spawned:true);
}
}
}
if(mapem=="nm")
{
resume_pools();
vd.set_disallowed_chars("", false, "This character is not allowed.");
string name=vd.input_box("","Enter the name of this map.");
string name2=vd.input_box("","Enter the owner of this map. Press enter to use the default owner.", "noone");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("","Enter the minimum length of this map.");
string mx2=vd.input_box("","Enter the maximum length of this map.");
string my=vd.input_box("","Enter the minimum height of this map.");
string my2=vd.input_box("","Enter the maximum height of this map.");
if(mapname=="" and mapowner=="" and minx=="" and maxx=="" and miny=="" and maxy=="")
return;
string mapname=name;
string mapowner=name2;
double minx=string_to_number(mx);
double maxx=string_to_number(mx2);
double miny=string_to_number(my);
double maxy=string_to_number(my2);
if(directory_exists("data/maps/decompiled/"+mapname))
{
dlg_snd("Error. A map with this name already exists. Press enter to continue.");
return;
}
else
{
create_map(mapmode, mapname, mapowner, minx, maxx, miny, maxy);
load_map(mapmode, mapname, mapowner);
}
}
if(mapem=="rcm")
{
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Are you sure you want to reload "+mapname+"?",true);
if(mres==0)
{
resume_pools();
speak("canceled");
return;
}
if(mres==1)
{
resume_pools();
load_map(mapmode, mapname, mapowner, anounce_mapload:false);
speak("map reloaded");
}
if(mres==2)
{
resume_pools();
speak("canceled");
return;
}
}
}
}
void menuzoneloop()
{
for(uint i=0; i<menuzones.length(); i++)
{
if(menuzones[i].minx<=me.x and menuzones[i].maxx>=me.x and menuzones[i].miny<=me.y and menuzones[i].maxy>=me.y and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and key_repeating(KEY_RETURN))
{
pause_pools();
menuzones[i].menzmenu();
}
}
}
void spawn_menuzone(double x1,double x2,double y1,double y2)
{
menuzone menz1(x1,x2,y1,y2);
menuzones.insert_last(menz1);
}
void destroy_all_menuzones()
{
menuzones.resize(0);
}

safezone@[]safezones(0);
class safezone
{
bool cam_in_zone;
bool player_in_zone;
int safesound;
double minx, maxx, miny, maxy;
string safetype;
safezone(double mx,double mx2,double my,double my2,string sft)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
safetype=sft;
player_in_zone = (minx <= me.x && maxx >= me.x && miny <= me.y && maxy >= me.y);
cam_in_zone=true;
if (player_in_zone)
{
safesound=safepool.play_stationary(get_map_sound("objects/safe zones/"+safetype+"/*in*"),false);
}
}
}
bool is_in_safe(double x,double y)
{
for(uint i=0; i<safezones.length(); i++)
{
if(safezones[i].minx<=x && safezones[i].maxx>=x && safezones[i].miny<=y && safezones[i].maxy>=y)
{
return true;
}
}
return false;
}
void spawn_safezone(double x1,double x2,double y1,double y2,string safetype)
{
safezone sz1(x1,x2,y1,y2,safetype);
safezones.insert_last(sz1);
}
void destroy_all_safezones()
{
for(uint i=0; i<safezones.length(); i++)
{
if(safezones[i].player_in_zone==true) safezones[i].safesound=safepool.play_stationary(get_map_sound("objects/safe zones/"+safezones[i].safetype+"/*out*"),false);
}
safezones.resize(0);
}

zone@[]zones(0);
class zone
{
double minx, maxx, miny, maxy;
string text;
zone(double mx,double mx2,double my,double my2,string txt)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
text=txt;
}
}
string get_zone_at(double x,double y)
{
string zdata;
for(uint i=0; i<zones.length(); i++)
{
if(zones[i].minx<=x and zones[i].maxx>=x and zones[i].miny<=y and zones[i].maxy>=y)
{
zdata=zones[i].text;
}
}
if(zdata!="") return zdata;
else return "";
}
string gmz()
{
return get_zone_at(me.x,me.y);
}
void checkloc()
{
if (get_zone_at(me.x, me.y)!="")
{
string locate=get_zone_at(me.x, me.y);
if (locate!=newzone)
{
if (zonestatus==1)
speak(locate);
newzone=locate;
}
}
else
{
if (newzone!="")
{
if (zonestatus==1) speak("leving "+newzone);
newzone="";
}
}
}
void spawn_zone(double x1,double x2,double y1,double y2,string text)
{
zone zone1(x1,x2,y1,y2,text);
zones.insert_last(zone1);
}
void destroy_all_zones()
{
zones.resize(0);
}
