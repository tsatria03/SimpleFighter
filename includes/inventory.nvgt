obj@[]objs(0);
class obj
{
bool automatic;
;int getsound, hurtsound, objsound;
int itx;
int ity;
int objtime;
string objtype;
string objtype2;
timer objtimer;
obj(int ix,int iy,int sp,string ty,string ty2,bool itc)
{
itx=ix;
ity=iy;
objtime=sp;
objtype=ty;
objtype2=ty2;
automatic=itc;
}
}
void objloop()
{
for(uint i=0; i<objs.length(); i++)
{
if(objs[i].objtimer.elapsed>=objs[i].objtime)
{
objs[i].objsound=itempool.play_extended_2d(get_sound("equipments/items/unsorted/"+objs[i].objtype+"/"+objs[i].objtype2+"/*loop*"),me.x,me.y,objs[i].itx,objs[i].ity,0,0,0,0,false,0,0,itemvolume,itempitch,false);
objs[i].objtimer.restart();
}
if(me.x==objs[i].itx and me.y==objs[i].ity and objs[i].automatic==true)
{
objs[i].getsound=itempool.play_stationary_extended(get_sound("equipments/items/unsorted/"+objs[i].objtype+"/"+objs[i].objtype2+"/*get*"),false,0,0,itemvolume,itempitch,false);
give(objs[i].objtype2,1);
speak(objs[i].objtype2);
objs.remove_at(i);
return;
}
if(me.x==objs[i].itx and me.y==objs[i].ity and objs[i].automatic==false and key_up(KEY_LSHIFT) and key_up(KEY_RSHIFT) and key_repeating(KEY_RETURN))
{
objs[i].getsound=itempool.play_stationary_extended(get_sound("equipments/items/unsorted/"+objs[i].objtype+"/"+objs[i].objtype2+"/*get*"),false,0,0,itemvolume,itempitch,false);
give(objs[i].objtype2,1);
speak(objs[i].objtype2);
objs.remove_at(i);
return;
}
}
}
void spawn_obj(int x,int y,int objtime,string objtype,string objtype2,bool automatic)
{
obj o1(x,y,objtime,objtype,objtype2,automatic);
objs.insert_last(o1);
}
void destroy_all_objs()
{
for(uint i=0; i<objs.length(); i++)
{
itempool.destroy_sound(objs[i].objsound);
}
objs.resize(0);
}

objzone@[]objzones(0);
class objzone
{
double minx, maxx, miny, maxy;
int spawntime;
string objtype;
string objtype2;
timer spawntimer;
objzone(double mx,double mx2,double my,double my2,int sp,string it,string it2)
{
minx=mx;
maxx=mx2;
miny=my;
maxy=my2;
spawntime=sp;
objtype=it;
objtype2=it2;
}
}
void objzoneloop()
{
for(uint i=0; i<objzones.length(); i++)
{
if(objzones[i].minx<=me.x and objzones[i].maxx>=me.x and objzones[i].miny<=me.y and objzones[i].maxy>=me.y and objzones[i].spawntimer.elapsed>=objzones[i].spawntime)
{
spawn_obj(random(objzones[i].minx, objzones[i].maxx), random(objzones[i].miny, objzones[i].maxy), objzones[i].spawntime, objzones[i].objtype, objzones[i].objtype2, true);
objzones[i].spawntimer.restart();
}
}
}
void spawn_objzone(double x1,double x2,double y1,double y2,int sp,string objtype,string objtype2)
{
objzone oz1(x1,x2,y1,y2,sp,objtype,objtype2);
objzones.insert_last(oz1);
}
void destroy_all_objzones()
{
objzones.resize(0);
}

void auto_use_item()
{
if(itemhold==0 and itemtimer1.elapsed>=itemtime1 and itemtimer2.elapsed>=itemtime2 and itemtimer3.elapsed>=itemtime3)
{
if(itemcad==0)
{
speak("You must draw an item from a cadigory before using it.");
}
else if(itemcad==1 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/drinks/"+drinktype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
itemtimer1.restart();
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/drinks/"+drinktype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
if(itemcad==2 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/foods/"+foodtype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
itemtimer2.restart();
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/foods/"+foodtype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
if(itemcad==3 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/healers/"+healtype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
itemtimer3.restart();
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/healers/"+healtype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
}
}
void manule_use_item()
{
if(itemhold==1)
{
if(itemcad==0)
{
speak("You must draw an item from a cadigory before using it.");
}
else if(itemcad==1 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/drinks/"+drinktype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
wait(item1delay);
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/drinks/"+drinktype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
if(itemcad==2 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/foods/"+foodtype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
wait(item2delay);
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/foods/"+foodtype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
if(itemcad==3 and useitems==true)
{
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/healers/"+healtype+"/*fire*"),false,0,0,itemvolume,itempitch,false);
wait(item3delay);
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/sorted/healers/"+healtype+"/*hit*"),false,0,0,itemvolume,itempitch,false);
health+=maxhealth/4;
hearttime+=maxhealth/4;
}
}
}
void drop_item(string direction, string objtype, string objtype2)
{
if(direction=="left")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/health/"+objtype2+"/*drop*"), me.x-1, me.y, me.x-1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x-1, me.y, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/other/"+objtype2+"/*drop*"), me.x-1, me.y, me.x-1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x-1, me.y, 500, "other", objtype2, true);
}
}
else if(direction=="right")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/health/"+objtype2+"/*drop*"), me.x+1, me.y, me.x+1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x+1, me.y, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/other/"+objtype2+"/*drop*"), me.x+1, me.y, me.x+1, me.y, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x+1, me.y, 500, "other", objtype2, true);
}
}
else if(direction=="up")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/health/"+objtype2+"/*drop*"), me.x, me.y+1, me.x, me.y+1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y+1, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/other/"+objtype2+"/*drop*"), me.x, me.y+1, me.x, me.y+1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y+1, 500, "other", objtype2, true);
}
}
else if(direction=="down")
{
if(objtype=="health")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/health/"+objtype2+"/*drop*"), me.x, me.y-1, me.x, me.y-1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y-1, 500, "health", objtype2, true);
}
else if(objtype=="other")
{
itemslot = p.play_extended_2d(get_sound("equipments/items/unsorted/other/"+objtype2+"/*drop*"), me.x, me.y-1, me.x, me.y-1, 0,0,0,0, false,0,0, itemvolume, itempitch, false);
spawn_obj(me.x, me.y-1, 500, "other", objtype2, true);
}
}
}

void give(string item, int amount)
{
int a;
if (!inv.exists(item))
{
inv.set(item,amount);
}
else
{
inv.get(item,a);
if (a+amount<=0)
inv.delete(item);
else
inv.set(item,a+amount);
}
}
void clear_inv()
{
inv.delete_all();
}
void cycle_inv(int dir)
{
if (inv.get_size() == 0)
{
p.destroy_sound(invslot);
speak("empty");
return;
}
if(charinvsound==1) invslot=p.play_stationary(get_sound("characters/"+chartype+"/*inv*"),false);
if (dir == 1)
invpos += 1;
else
invpos -= 1;
if (invpos >= inv.get_size())
invpos = 0;
else if (invpos < 0)
invpos = inv.get_size() - 1;
int a;
inv.get(inv.get_keys()[invpos], a);
if (a == 1)
speak(inv.get_keys()[invpos] + ". Item " + (invpos + 1) + " of " + inv.get_keys().length());
else
speak(inv.get_keys()[invpos] + "s, " + a + ". Item " + (invpos + 1) + " of " + inv.get_keys().length());
}
void useitem(string current)
{
string[] healtype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/health/*");
string[] misktype=find_directories("sounds/"+soundpack+"/equipments/items/unsorted/other/*");
for(uint i1=0; i1<healtype.length(); i1++)
{
for (uint i2=0; i2<misktype.length(); i2++)
{
if (inv.get_size()<=0)
{
speak("No items");
}
else
{
current=inv.get_keys()[invpos];
if(current==healtype[i1])
{
if(health>=maxhealth)
{
speak("You don't need to use this!");
return;
}
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/unsorted/health/"+healtype[i1]+"/*fire*"),false,0,0,itemvolume,itempitch,false);
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/unsorted/health/"+healtype[i1]+"/*hit*"),false,0,0,itemvolume,itempitch,false);
give(healtype[i1],-1);
double heal_percent = random(5, 10);
double heal_amount = maxhealth * (heal_percent / 100.0);
health = min(health + heal_amount, maxhealth);
hearttime = min(health + heal_amount, maxhealth);
speak("healed to"+round(health/maxhealth*100,2)+"percent health");
return;
}
if(current==misktype[i2])
{
if (current == "healing_cast")
{
if (broken_bones.get_size() == 0)
{
speak("You don't need to use this!");
return;
}
itemslot = p.play_stationary_extended(find_sound("sounds/" + soundpack + "/equipments/items/unsorted/other/healing_cast/*healstart*"), false, 0, 0, itemvolume, itempitch, false);
speak("You apply the healing cast.");
heal_bones(random(5, 10));
return;
}
if(current == "health_scanner")
{
itemslot = p.play_stationary_extended(get_sound("equipments/items/unsorted/other/health_scanner/*scanstart*"), false, 0, 0, itemvolume, itempitch, false);
itemslot = p.play_stationary_extended(get_sound("equipments/items/unsorted/other/health_scanner/*scanning*"), false, 0, 0, itemvolume, itempitch, false);
speak("scanning");
wait(random(500, 1000));
itemslot = p.play_stationary_extended(get_sound("equipments/items/unsorted/other/health_scanner/*scanstop*"), false, 0, 0, itemvolume, itempitch, false);
array<string> keys = broken_bones.get_keys();
if (keys.length() == 0)
{
speak("The scan results show that you have no broken bones.");
}
else
{
string message = "The scan results show that you ";
if (keys.length() == 1)
{
string part = keys[0];
string status;
broken_bones.get(part, status);
string spoken_part = part.replace("_", " ");
message += status + " your " + spoken_part + ".";
}
else
{
for (uint i = 0; i < keys.length(); i++)
{
string part = keys[i];
string status;
broken_bones.get(part, status);
string spoken_part = part.replace("_", " ");
message += status + " your " + spoken_part;
if (i == keys.length() - 2)
message += ", and ";
else if (i < keys.length() - 2)
message += ", ";
else
message += ".";
}
}
speak(message);
}
return;
}
if(firesound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/unsorted/other/"+misktype[i2]+"/*fire*"),false,0,0,itemvolume,itempitch,false);
if(hitsound==1) itemslot=p.play_stationary_extended(get_sound("equipments/items/unsorted/other/"+misktype[i2]+"/*hit*"),false,0,0,itemvolume,itempitch,false);
give(misktype[i2],-1);
speak(misktype[i2]+";"+"recycled");
return;
}
}
}
}
}
int count_total_items()
{
int amount=0;
for (uint i=0; i<inv.get_keys().length(); i++)
{
int a;
inv.get(inv.get_keys()[i],a);
amount+=a;
}
return amount;
}
string getitem()
{
if (inv.get_size()<=0)
{
return "";
}
else
{
string current=inv.get_keys()[invpos];
return current;
}
}
int item_exists(string item)
{
string[] current=inv.get_keys();
int index=current.find(item);
if (index>-1)
{
int ab;
inv.get(current[index],ab);
return ab;
}
else
return -1;
}

