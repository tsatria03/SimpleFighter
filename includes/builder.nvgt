void buildobj(string buildtype)
{
if(buildtype == "aircraft")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this aircraft.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this aircraft.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this aircraft. Press enter to use the default health.", "1");
if(x=="" and y=="" and minhp=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
string[] aircraft=get_map_sound_folders("objects/aircrafts/*");
if(aircraft.length()==0)
{
dlg_snd("Error. There are no aircrafts available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=plainsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
plaintyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"aircraft "+x+" "+y+" "+minhp+" "+plaintyp);
mapper.close();
spawn_aircraft(x, y, minhp, minhp, plaintyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "aircraft_beacon")
{
form.reset();
form.create_window("aircraft beacon", false);
int mx=form.create_input_box("Enter the x of this aircraft beacon.", sel_left_set ? sel_left : "");
int wt=form.create_input_box("Enter the width of this aircraft beacon.");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(wt, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
width=string_to_number(form.get_text(wt));
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("X is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(wt)=="")
{
speak("Width is required.");
form.focus(wt);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"airbeacon "+x+" "+width);
mapper.close();
spawn_airbeacon(x, 0, width);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "sound_ambience")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this sound ambience.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this sound ambience.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this sound ambience.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this sound ambience.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] soundamb=get_map_sound_folders("sources/*");
if(soundamb.length()==0)
{
dlg_snd("Error. There are no sound ambiences available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
sorcetyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_ambsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "music_ambience")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this music ambience.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this music ambience.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this music ambience.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this music ambience.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] musicamb=get_map_sound_folders("musics/*");
if(musicamb.length()==0)
{
dlg_snd("Error. There are no music ambiences available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_ambience "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicamb(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "animal")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this animal.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this animal.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal atack range of this animal.");
string rng2=vd.input_box("", "Enter the vertical atack range of this animal.");
string rng3=vd.input_box("", "Enter the horizontal seeing range of this animal.");
string rng4=vd.input_box("", "Enter the vertical seeing range of this animal.");
string hp=vd.input_box("", "Enter the health of this animal.");
string hc=vd.input_box("", "Enter the maximum lives of this animal. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this animal.");
string ft=vd.input_box("", "Enter the fire time of this animal.");
string sp=vd.input_box("", "Enter the speed of this animal.");
string lev=vd.input_box("", "Enter the level of this animal.");
string exper=vd.input_box("", "Enter the xp of this animal.");
if(x=="" and y=="" and amrange=="" and amrange2=="" and amrange3=="" and amrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
amrange=string_to_number(rng);
amrange2=string_to_number(rng2);
amrange3=string_to_number(rng3);
amrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] animal=get_map_sound_folders("npc/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
amtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the animal attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the animal move on the x axes?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the animal move on the y axes?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the animal drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal "+x+" "+y+" "+amrange+" "+amrange2+" "+amrange3+" "+amrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+amtype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_animal(x, y, amrange, amrange2, amrange3, amrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, amtype, fb, mb, mb2, itms);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "animal_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this animal zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this animal zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this animal zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this animal zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] animal=get_map_sound_folders("npc/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu(true);
if(res!="")
{
t.destroy_sound(prevslot);
amtype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"animal_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+amtype);
mapper.close();
spawn_animalzone(x, paxx, y, speedtime, amtype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "blockage")
{
form.reset();
form.create_window("blockage", false);
int mx=form.create_input_box("Enter the minimum x of this blockage", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this blockage", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this blockage", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this blockage", sel_top_set ? sel_top : "");
int bltext=form.create_input_box("Enter the text of this blockage");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
txt=form.get_text(bltext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(bltext)=="")
{
speak("Blockage text is required.");
form.focus(bltext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"blockage "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_blockage(x, paxx, y, paxy, txt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "bike")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this bike.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this bike.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this bike. Press enter to use the default health.", "1");
string sp=vd.input_box("", "Enter the base speed of this bike. Press enter to use the default base speed.", "1500");
if(x=="" and y=="" and minhp=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
string[] bike=get_map_sound_folders("objects/bikes/*");
if(bike.length()==0)
{
dlg_snd("Error. There are no bikes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bikesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
biktyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bike "+x+" "+y+" "+minhp+" "+speedtime+" "+biktyp);
mapper.close();
spawn_bike(x, y, minhp, minhp, speedtime, biktyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "bomb")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this bomb.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this bomb.", sel_bottom_set ? sel_bottom : "");
string dm=vd.input_box("", "Enter the maximum attack of this bomb.");
string sp=vd.input_box("", "Enter the speed of this bomb.");
if(x=="" and y=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] bomb=get_map_sound_folders("objects/bombs/*");
if(bomb.length()==0)
{
dlg_snd("Error. There are no bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
botype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb "+x+" "+y+" "+damage+" "+speedtime+" "+botype);
mapper.close();
spawn_bomb(x, y, damage, speedtime, botype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "bomb_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this bomb zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this bomb zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this bomb zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this bomb zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] bomb=get_map_sound_folders("objects/bombs/*");
if(bomb.length()==0)
{
dlg_snd("Error. There are no bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bombsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
botype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"bomb_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+botype);
mapper.close();
spawn_bombzone(x, paxx, y, speedtime, botype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "boss")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this boss.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this boss.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal atack range of this boss.");
string rng2=vd.input_box("", "Enter the vertical atack range of this boss.");
string rng3=vd.input_box("", "Enter the horizontal seeing range of this boss.");
string rng4=vd.input_box("", "Enter the vertical seeing range of this boss.");
string hp=vd.input_box("", "Enter the health of this boss.");
string hc=vd.input_box("", "Enter the maximum lives of this boss. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this boss.");
string ft=vd.input_box("", "Enter the fire time of this boss.");
string lt=vd.input_box("", "Enter the launch time of this boss.");
string sp=vd.input_box("", "Enter the speed of this boss.");
string tt=vd.input_box("", "Enter the teleport time of this boss.");
string ht=vd.input_box("", "Enter the healing time of this boss.");
string lev=vd.input_box("", "Enter the level of this boss.");
string exper=vd.input_box("", "Enter the xp of this boss.");
if(x=="" and y=="" and bossrange=="" and bossrange2=="" and bossrange3=="" and bossrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and launchtime=="" and speedtime=="" and teltime=="" and healtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
bossrange=string_to_number(rng);
bossrange2=string_to_number(rng2);
bossrange3=string_to_number(rng3);
bossrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
launchtime=string_to_number(lt);
speedtime=string_to_number(sp);
teltime=string_to_number(tt);
healtime=string_to_number(ht);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] boss=get_map_sound_folders("npc/bosses/*");
if(boss.length()==0)
{
dlg_snd("Error. There are no bosses available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=bossesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
bosstyp=res;
}
}
setupmenu();
m.add_item_tts("animal","an2");
m.add_item_tts("human", "hum2");
m.add_item_tts("projectile","pj2");
m.add_item_tts("robot","rt2");
m.add_item_tts("zombie","zb2");
int mres=m.run("What would you like this boss to spawn?",true);
string bossem=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(bossem=="an2")
{
string[] animal=get_map_sound_folders("npc/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
bosstyp2="animal";
t.destroy_sound(prevslot);
bosstyp3=res;
}
}
}
if(bossem=="hum2")
{
string[] human=get_map_sound_folders("npc/humans/*");
if(human.length()==0)
{
dlg_snd("Error. There are no humans available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=humansmenu();
if(res!="")
{
bosstyp2="human";
t.destroy_sound(prevslot);
bosstyp3=res;
}
}
}
if(bossem=="pj2")
{
string[] projectile=get_map_sound_folders("npc/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
bosstyp2="projectile";
t.destroy_sound(prevslot);
bosstyp3=res;
}
}
}
if(bossem=="rt2")
{
string[] robot=get_map_sound_folders("npc/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
bosstyp2="robot";
t.destroy_sound(prevslot);
bosstyp3=res;
}
}
}
if(bossem=="zb2")
{
string[] zombie=get_map_sound_folders("npc/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
bosstyp2="zombie";
t.destroy_sound(prevslot);
bosstyp3=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should the boss attack you?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
fb=true;
}
if(mres18==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres19=m.run("Should the boss move on the x axes?",true);
if(mres19==0)
{
speak("canceled");
return;
}
if(mres19==1)
{
mb=true;
}
if(mres19==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres20=m.run("Should the boss move on the y axes?",true);
if(mres20==0)
{
speak("canceled");
return;
}
if(mres20==1)
{
mb2=true;
}
if(mres20==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres21=m.run("Should the boss teleport randomly on the x axes?",true);
if(mres21==0)
{
speak("canceled");
return;
}
if(mres21==1)
{
tb=true;
}
if(mres21==2)
{
tb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres22=m.run("Should the boss teleport randomly on the y axes?",true);
if(mres22==0)
{
speak("canceled");
return;
}
if(mres22==1)
{
tb2=true;
}
if(mres22==2)
{
tb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Should the boss heal it's health randomly?",true);
if(mres23==0)
{
speak("canceled");
return;
}
if(mres23==1)
{
hb=true;
}
if(mres23==2)
{
hb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres24=m.run("Should the boss drop an item after killing it?",true);
if(mres24==0)
{
speak("canceled");
return;
}
if(mres24==1)
{
itms=true;
}
if(mres24==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"boss "+x+" "+y+" "+bossrange+" "+bossrange2+" "+bossrange3+" "+bossrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+launchtime+" "+speedtime+" "+teltime+" "+healtime+" "+lv+" "+xn+" "+bosstyp+" "+bosstyp2+" "+bosstyp3+" "+fb+" "+mb+" "+mb2+" "+tb+" "+tb2+" "+hb+" "+itms);
mapper.close();
spawn_boss(x, y, bossrange, bossrange2, bossrange3, bossrange4, minhp, minhp, card, damage, firetime, launchtime, speedtime, teltime, healtime, lv, xn, bosstyp, bosstyp2, bosstyp3, fb, mb, mb2, tb, tb2, hb, itms);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "calendar")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this calendar.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this calendar.", sel_bottom_set ? sel_bottom : "");
vd.set_disallowed_chars("", false, "This character is not allowed.");
string text=vd.input_box("", "Enter the text of this calendar. Press enter to use the default text.", "The date is ");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] calander=get_map_sound_folders("objects/calendars/*");
if(calander.length()==0)
{
dlg_snd("Error. There are no calendars available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=calandersmenu();
if(res!="")
{
t.destroy_sound(prevslot);
calandertyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this calendar to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"calendar "+x+" "+y+" "+txt+" "+calandertyp+" "+dmd);
mapper.close();
spawn_calendar(x, y, txt, calandertyp, dmd);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "clock")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this clock.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this clock.", sel_bottom_set ? sel_bottom : "");
vd.set_disallowed_chars("", false, "This character is not allowed.");
string text=vd.input_box("", "Enter the text of this clock. Press enter to use the default text.", "The time is ");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] clock=get_map_sound_folders("objects/clocks/*");
if(clock.length()==0)
{
dlg_snd("Error. There are no clocks available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=clocksmenu();
if(res!="")
{
t.destroy_sound(prevslot);
clocktyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this clock to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"clock "+x+" "+y+" "+txt+" "+clocktyp+" "+dmd);
mapper.close();
spawn_clock(x, y, txt, clocktyp, dmd);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "conveyor_belt")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this conveyor belt.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this conveyor belt.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this conveyor belt.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this conveyor belt.", sel_top_set ? sel_top : "");
string dr=vd.input_box("", "Enter the direction of this conveyor belt. 1 for left, 2 for right, 3 for down, and 4 for up.");
string sp=vd.input_box("", "Enter the speed of this conveyor belt.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
string[] belt=get_map_sound_folders("objects/belts/*");
if(belt.length()==0)
{
dlg_snd("Error. There are no belts available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=beltsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
belttyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"belt "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+belttyp);
mapper.close();
spawn_belt(x, paxx, y, paxy, direction, speedtime, tiletype, belttyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "dialog")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this dialog.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this dialog.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this dialog.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this dialog.", sel_top_set ? sel_top : "");
vd.set_disallowed_chars("", false, "This character is not allowed.");
string text=vd.input_box("", "Enter the text of this dialog. You can seperate them by dashes for reading multiple lines.");
if(x=="" and paxx=="" and y=="" and paxy=="" and txt=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
txt=text;
string[] dialog=get_map_sound_folders("dialogs/*");
if(dialog.length()==0)
{
dlg_snd("Error. There are no dialogs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dlgsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
dlgtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres25=m.run("Do you want this dialog to auto activate when stepped on?",true);
if(mres25==0)
{
speak("canceled");
return;
}
if(mres25==1)
{
dlt=true;
}
if(mres25==2)
{
dlt=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dialog "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+dlgtyp+" "+dlt);
mapper.close();
spawn_dialog(x, paxx, y, paxy, txt, dlgtyp, dlt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "door")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sx=vd.input_box("", "Enter the starting x of this door.", sel_left_set ? sel_left : "");
string sy=vd.input_box("", "Enter the starting y of this door.", sel_bottom_set ? sel_bottom : "");
string nx=vd.input_box("", "Enter the finishing x of this door.", sel_right_set ? sel_right : "");
string ny=vd.input_box("", "Enter the finishing y of this door.", sel_top_set ? sel_top : "");
string hp=vd.input_box("", "Enter the health of this door. Press enter to use the default health.", "1");
string sp=vd.input_box("", "Enter the speed of this door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
string[] dloop=get_map_sound_folders("objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
looptyp=res;
}
}
string[] dmove=get_map_sound_folders("objects/doors/move/*");
if(dmove.length()==0)
{
dlg_snd("Error. There are no door moves available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
t.destroy_sound(prevslot);
movtyp=res2;
}
}
string[] dopen=get_map_sound_folders("objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
t.destroy_sound(prevslot);
opentyp=res3;
}
}
string[] dclose=get_map_sound_folders("objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
t.destroy_sound(prevslot);
clostyp=res4;
}
}
string[] desttype=get_map_sound_folders("objects/doors/dest/*");
if(desttype.length()==0)
{
dlg_snd("Error. There are no door destructions available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
t.destroy_sound(prevslot);
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x, y, x2, y2, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"door "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_door(x2, y2, x, y, minhp, minhp, speedtime, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
}
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "elevator")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this elevator.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this elevator.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the speed of this elevator.");
string text=vd.input_box("", "Enter the menu text of this elevator. Press enter to use the default menu text.", "Choose the floor you'd like to go to.");
if(x=="" and y=="" and speedtime=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
txt=text;
string[] eldloop=get_map_sound_folders("objects/elevators/loop/*");
if(eldloop.length()==0)
{
dlg_snd("Error. There are no elevator loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=eldloopsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
ellooptyp=res;
}
}
string[] eldmove=get_map_sound_folders("objects/elevators/move/*");
if(eldmove.length()==0)
{
dlg_snd("Error. There are no elevator moves available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=eldmovesmenu();
if(res2!="")
{
t.destroy_sound(prevslot);
elmovtyp=res2;
}
}
string[] eldopen=get_map_sound_folders("objects/elevators/open/*");
if(eldopen.length()==0)
{
dlg_snd("Error. There are no elevator opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=eldopensmenu();
if(res3!="")
{
t.destroy_sound(prevslot);
elopentyp=res3;
}
}
string[] eldclose=get_map_sound_folders("objects/elevators/close/*");
if(eldclose.length()==0)
{
dlg_snd("Error. There are no elevator closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res4=eldclosesmenu();
if(res4!="")
{
t.destroy_sound(prevslot);
elclostyp=res4;
}
}
string[] elbeeptype=get_map_sound_folders("objects/elevators/beep/*");
if(elbeeptype.length()==0)
{
dlg_snd("Error. There are no elevator beeps available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res5=elbeepsmenu();
if(res5!="")
{
t.destroy_sound(prevslot);
elbeeptyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want the elevator floors to be spoken?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
fls=true;
}
if(mres27==2)
{
fls=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"elevator "+x+" "+y+" "+speedtime+" "+txt+" "+ellooptyp+" "+elmovtyp+" "+elopentyp+" "+elclostyp+" "+elbeeptyp+" "+fls);
mapper.close();
spawn_elevator(x, y, speedtime, txt, ellooptyp, elmovtyp, elopentyp, elclostyp, elbeeptyp, fls);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "elevator_floor")
{
form.reset();
form.create_window("elevator floor", false);
int mx=form.create_input_box("Enter the minimum x of this elevator floor", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this elevator floor", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the y of this elevator floor", sel_bottom_set ? sel_bottom : "");
int elvftext=form.create_input_box("Enter the text of this elevator floor");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
txt=form.get_text(elvftext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(elvftext)=="")
{
speak("Floor text is required.");
form.focus(elvftext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"el_floor "+x+" "+paxx+" "+y+" "+txt);
mapper.close();
spawn_el_floor(x, paxx, y, txt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "lockable_door")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sx=vd.input_box("", "Enter the starting x of this lockable door.", sel_left_set ? sel_left : "");
string sy=vd.input_box("", "Enter the starting y of this lockable door.", sel_bottom_set ? sel_bottom : "");
string nx=vd.input_box("", "Enter the finishing x of this lockable door.", sel_right_set ? sel_right : "");
string ny=vd.input_box("", "Enter the finishing y of this lockable door.", sel_top_set ? sel_top : "");
string hp=vd.input_box("", "Enter the health of this lockable door. Press enter to use the default health.", "1");
string sp=vd.input_box("", "Enter the speed of this lockable door.");
vd.set_disallowed_chars("", false, "This character is not allowed.");
string ps=vd.input_box("", "Enter the password of this lockable door.");
if(x=="" and y=="" and x2=="" and y2=="" and minhp=="" and speedtime=="" and drpassword=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
minhp=string_to_number(hp);
speedtime=string_to_number(sp);
drpassword=ps;
string[] dloop=get_map_sound_folders("objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
looptyp=res;
}
}
string[] dmove=get_map_sound_folders("objects/doors/move/*");
if(dmove.length()==0)
{
dlg_snd("Error. There are no door moves available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dmovesmenu();
if(res2!="")
{
t.destroy_sound(prevslot);
movtyp=res2;
}
}
string[] dopen=get_map_sound_folders("objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dopensmenu();
if(res3!="")
{
t.destroy_sound(prevslot);
opentyp=res3;
}
}
string[] dclose=get_map_sound_folders("objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res4=dclosesmenu();
if(res4!="")
{
t.destroy_sound(prevslot);
clostyp=res4;
}
}
string[] desttype=get_map_sound_folders("objects/doors/dest/*");
if(desttype.length()==0)
{
dlg_snd("Error. There are no door destructions available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res5=destsmenu();
if(res5!="")
{
t.destroy_sound(prevslot);
desttyp=res5;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres27=m.run("Do you want this lockable door to autoactivate when stepped on?",true);
if(mres27==0)
{
speak("canceled");
return;
}
if(mres27==1)
{
dmt=true;
}
if(mres27==2)
{
dmt=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this lockable door to be destroyable?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
dmd=true;
}
if(mres28==2)
{
dmd=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres23=m.run("Would you like to automatically build the opposite side of this lockable door?",true);
if(mres23==0)
{
speak("canceled");
return;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x+" "+y+" "+x2+" "+y2+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x, y, x2, y2, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
if(mres23==1)
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"psdoor "+x2+" "+y2+" "+x+" "+y+" "+minhp+" "+speedtime+" "+drpassword+" "+looptyp+" "+movtyp+" "+opentyp+" "+clostyp+" "+desttyp+" "+dmt+" "+dmd);
mapper.close();
spawn_psdoor(x2, y2, x, y, minhp, minhp, speedtime, drpassword, looptyp, movtyp, opentyp, clostyp, desttyp, dmt, dmd);
}
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "passage")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sx=vd.input_box("", "Enter the starting x of this passage.", sel_left_set ? sel_left : "");
string sy=vd.input_box("", "Enter the starting y of this passage.", sel_bottom_set ? sel_bottom : "");
string dr=vd.input_box("", "Enter the direction of this passage. 1 for left to right, and 2 for bottom to top.");
string lk=vd.input_box("", "Enter the maximum length of this passage.");
if(x=="" and y=="" and direction=="" and ln=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
string[] dloop=get_map_sound_folders("objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
looptyp=res;
}
}
string[] dopen=get_map_sound_folders("objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
t.destroy_sound(prevslot);
opentyp=res2;
}
}
string[] dclose=get_map_sound_folders("objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
t.destroy_sound(prevslot);
clostyp=res3;
}
}
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the opening time of this passage.");
string sp2=vd.input_box("", "Enter the closing time of this passage.");
if(speedtime=="" and speedtime2=="")
return;
speedtime=string_to_number(sp);
speedtime2=string_to_number(sp);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"passage "+x+" "+y+" "+direction+" "+ln+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+speedtime+" "+speedtime2);
mapper.close();
spawn_passage(x, y, direction, ln, tiletype, looptyp, opentyp, clostyp, speedtime, speedtime2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "lockable_passage")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sx=vd.input_box("", "Enter the starting x of this lockable passage.", sel_left_set ? sel_left : "");
string sy=vd.input_box("", "Enter the starting y of this lockable passage.", sel_bottom_set ? sel_bottom : "");
string dr=vd.input_box("", "Enter the direction of this lockable passage. 1 for left to right, and 2 for bottom to top.");
string lk=vd.input_box("", "Enter the maximum length of this lockable passage.");
if(x=="" and y=="" and direction=="" and ln=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
direction=string_to_number(dr);
ln=string_to_number(lk);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
string[] dloop=get_map_sound_folders("objects/doors/loop/*");
if(dloop.length()==0)
{
dlg_snd("Error. There are no door loops available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=dloopsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
looptyp=res;
}
}
string[] dopen=get_map_sound_folders("objects/doors/open/*");
if(dopen.length()==0)
{
dlg_snd("Error. There are no door opens available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res2=dopensmenu();
if(res2!="")
{
t.destroy_sound(prevslot);
opentyp=res2;
}
}
string[] dclose=get_map_sound_folders("objects/doors/close/*");
if(dclose.length()==0)
{
dlg_snd("Error. There are no door closes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res3=dclosesmenu();
if(res3!="")
{
t.destroy_sound(prevslot);
clostyp=res3;
}
}
vd.set_disallowed_chars("", false, "This character is not allowed.");
string ps=vd.input_box("", "Enter the password of this lockable passage.");
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the opening time of this lockable passage.");
string sp2=vd.input_box("", "Enter the closing time of this lockable passage.");
if(pspassword=="" and speedtime=="" and speedtime2=="")
return;
pspassword=ps;
speedtime=string_to_number(sp);
speedtime2=string_to_number(sp2);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"pspassage "+x+" "+y+" "+direction+" "+ln+" "+tiletype+" "+looptyp+" "+opentyp+" "+clostyp+" "+pspassword+" "+speedtime+" "+speedtime2);
mapper.close();
spawn_pspassage(x, y, direction, ln, tiletype, looptyp, opentyp, clostyp, pspassword, speedtime, speedtime2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "human")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this human.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this human.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal atack range of this human.");
string rng2=vd.input_box("", "Enter the vertical atack range of this human.");
string rng3=vd.input_box("", "Enter the horizontal seeing range of this human.");
string rng4=vd.input_box("", "Enter the vertical seeing range of this human.");
string hp=vd.input_box("", "Enter the health of this human.");
string hc=vd.input_box("", "Enter the maximum lives of this human. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this human.");
string dc=vd.input_box("", "Enter the maximum defence of this human. Press enter to use the default defence.", "0");
string ft=vd.input_box("", "Enter the fire time of this human.");
string sp=vd.input_box("", "Enter the speed of this human.");
string lev=vd.input_box("", "Enter the level of this human.");
string exper=vd.input_box("", "Enter the xp of this human.");
if(x=="" and y=="" and emrange=="" and emrange2=="" and emrange3=="" and emrange4=="" and minhp=="" and card=="" and damage=="" and dfc=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
emrange=string_to_number(rng);
emrange2=string_to_number(rng2);
emrange3=string_to_number(rng3);
emrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
dfc=string_to_number(dc);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] human=get_map_sound_folders("npc/humans/*");
if(human.length()==0)
{
dlg_snd("Error. There are no humans available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=humansmenu();
if(res!="")
{
t.destroy_sound(prevslot);
humtype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the human attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the human move on the x axes?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the human move on the y axes?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the human drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"human "+x+" "+y+" "+emrange+" "+emrange2+" "+emrange3+" "+emrange4+" "+minhp+" "+card+" "+damage+" "+dfc+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+humtype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_human(x, y, emrange, emrange2, emrange3, emrange4, minhp, minhp, card, damage, dfc, firetime, speedtime, lv, xn, humtype, fb, mb, mb2, itms);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "human_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this human zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this human zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this human zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this human zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] human=get_map_sound_folders("npc/humans/*");
if(human.length()==0)
{
dlg_snd("Error. There are no humans available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=humansmenu(true);
if(res!="")
{
t.destroy_sound(prevslot);
humtype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"human_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+humtype);
mapper.close();
spawn_humanzone(x, paxx, y, speedtime, humtype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "floor_breaker")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this floor breaker.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this floor breaker.", sel_bottom_set ? sel_bottom : "");
if(x=="" and y=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
string[] floorbtype=get_map_sound_folders("objects/floor breakers/*");
if(floorbtype.length()==0)
{
dlg_snd("Error. There are no floor breakers available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=floorsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
floortyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"floor_breaker "+x+" "+y+" "+floortyp);
mapper.close();
spawn_floorbreaker(x, y, floortyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "force_field")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this force field.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this force field.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this force field.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this force field.", sel_top_set ? sel_top : "");
string dm=vd.input_box("", "Enter the maximum attack of this force field.");
string sp=vd.input_box("", "Enter the speed of this force field.");
if(x=="" and paxx=="" and y=="" and paxy=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] forcefield=get_map_sound_folders("objects/force fields/*");
if(forcefield.length()==0)
{
dlg_snd("Error. There are no force fields available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=forcesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
forcetyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"forcefield "+x+" "+paxx+" "+y+" "+paxy+" "+damage+" "+speedtime+" "+forcetyp);
mapper.close();
spawn_forcefield(x, paxx, y, paxy, damage, speedtime, forcetyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "hazard")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this hazard.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this hazard.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this hazard.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this hazard.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] hazardtype=get_map_sound_folders("objects/hazards/*");
if(hazardtype.length()==0)
{
dlg_snd("Error. There are no hazards available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
hazztype=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like to automaticly spawn ledges on both sides of this hazard?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lp=true;
}
if(mres==2)
{
lp=false;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"hazard "+x+" "+paxx+" "+y+" "+paxy+" "+hazztype+" "+lp);
mapper.close();
spawn_hazard(x, paxx, y, paxy, hazztype, lp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "helper")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this helper.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this helper.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this helper.");
string hc=vd.input_box("", "Enter the maximum lives of this helper. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this helper.");
string ft=vd.input_box("", "Enter the fire time of this helper.");
string sp=vd.input_box("", "Enter the speed of this helper.");
string lev=vd.input_box("", "Enter the level of this helper.");
if(x=="" and y=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
string[] helper=get_map_sound_folders("npc/helpers/*");
if(helper.length()==0)
{
dlg_snd("Error. There are no helpers available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=helpersmenu();
if(res!="")
{
t.destroy_sound(prevslot);
helptyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"helper "+x+" "+y+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+helptyp);
mapper.close();
spawn_helper(x, y, minhp, minhp, card, damage, firetime, speedtime, lv, helptyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "heal_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this heal zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this heal zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this heal zone.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this heal zone.", sel_top_set ? sel_top : "");
string hm=vd.input_box("", "Enter the healing mode of this heal zone. 0 for decreasing health, and 1 for increasing health.");
string hp=vd.input_box("", "Enter the health of this heal zone.");
string ht=vd.input_box("", "Enter the healing time of this heal zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and healthmode=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
healthmode=string_to_number(hm);
damage=string_to_number(hp);
speedtime=string_to_number(ht);
string[] heals=get_map_sound_folders("objects/heal zones/*");
if(heals.length()==0)
{
dlg_snd("Error. There are no heal zones available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
healtyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"heal_zone "+x+" "+paxx+" "+y+" "+paxy+" "+healthmode+" "+damage+" "+speedtime+" "+healtyp);
mapper.close();
spawn_healzone(x, paxx, y, paxy, healthmode, damage, speedtime, healtype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "mine")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this mine.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this mine.", sel_bottom_set ? sel_bottom : "");
string dm=vd.input_box("", "Enter the maximum attack of this mine.");
if(x=="" and y=="" and damage=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
string[] mine=get_map_sound_folders("objects/mines/*");
if(mine.length()==0)
{
dlg_snd("Error. There are no mines available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=minesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
minetyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Should this mine be auto activated?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
trg=true;
}
if(mres==2)
{
trg=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mine "+x+" "+y+" "+damage+" "+minetyp+" "+trg);
mapper.close();
spawn_mine(x, y, damage, minetyp, trg);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "moving_hazard")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the left x of this moving hazard.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the right x of this moving hazard.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the bottom y of this moving hazard.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the top y of this moving hazard.", sel_top_set ? sel_top : "");
string sx=vd.input_box("", "Enter the maximum x length of this moving hazard.", sel_right_set ? sel_right : "");
string sy=vd.input_box("", "Enter the maximum y length of this moving hazard.", sel_top_set ? sel_top : "");
string dr=vd.input_box("", "Enter the direction of this moving hazard. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=vd.input_box("", "Enter the snap mode of this moving hazard. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=vd.input_box("", "Enter the sspeed of this moving hazard. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and y2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
y2=string_to_number(sy);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] hazardtype=get_map_sound_folders("objects/hazards/*");
if(hazardtype.length()==0)
{
dlg_snd("Error. There are no hazards available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
hazztype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mhazard "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+y2+" "+direction+" "+direction2+" "+speedtime+" "+hazztype);
mapper.close();
spawn_moving_hazard(x, paxx, y, paxy, x2, y2, direction, direction2, speedtime, hazztype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "moving_platform")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the left x of this moving platform.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the right x of this moving platform.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the bottom y of this moving platform.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the top y of this moving platform.", sel_top_set ? sel_top : "");
string sx=vd.input_box("", "Enter the maximum x length of this moving platform.", sel_right_set ? sel_right : "");
string dr=vd.input_box("", "Enter the direction of this moving platform. 0 for Right and left, 1 for up and down, 2 for Diagonal up/right and down/left, 3 for diagonal up/left and down/right, 4 for Left and right, 5 for Down and up, 6 for Diagonal down/left and up/right, and 7 for diagonal down/right and up/left.");
string sn=vd.input_box("", "Enter the snap mode of this moving platform. 0 for no snapping, 1 for forward to snap, 2 for backward to snap, and 3 for snap at ends.");
string sp=vd.input_box("", "Enter the sspeed of this moving platform. 100 is equaled to 1000 milliseconds, 50 is equaled to 500 milliseconds, 10 is equaled to 100 milliseconds, 5 is equaled to 50 milliseconds, and 1 is equaled to 10 milliseconds.");
if(x=="" and paxx=="" and y=="" and paxy=="" and x2=="" and direction=="" and direction2=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
x2=string_to_number(sx);
direction=string_to_number(dr);
direction2=string_to_number(sn);
speedtime=string_to_number(sp);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] mplatform=get_map_sound_folders("objects/moving platforms/*");
if(mplatform.length()==0)
{
dlg_snd("Error. There are no moving platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=mplatsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
mplattyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string vof=vd.input_box("", "Enter the volume offset of this moving platform.");
if(volset=="")
return;
volset=string_to_number(vof);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"mplatform "+x+" "+paxx+" "+y+" "+paxy+" "+x2+" "+direction+" "+direction2+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+mplattyp+" "+volume2+" "+pitch2+" "+volset);
mapper.close();
spawn_moving_platform(x, paxx, y, paxy, x2, direction, direction2, speedtime, tiletype, volume, pitch, mplattyp, volume2, pitch2, volset);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "menu_zone")
{
form.reset();
form.create_window("menu zone", false);
int mx=form.create_input_box("Enter the minimum x of this menu zone", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this menu zone", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this menu zone", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this menu zone", sel_top_set ? sel_top : "");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"menu_zone "+x+" "+paxx+" "+y+" "+paxy);
mapper.close();
spawn_menuzone(x, paxx, y, paxy);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "checkpoint")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this checkpoint.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this checkpoint.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the speed of this checkpoint. Press enter to use the default speed.", "350");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] checktype=get_map_sound_folders("objects/checkpoints/*");
if(checktype.length()==0)
{
dlg_snd("Error. There are no checkpoints available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=checksmenu();
if(res!="")
{
t.destroy_sound(prevslot);
checktyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"checkpoint "+x+" "+y+" "+speedtime+" "+checktyp);
mapper.close();
spawn_checkpoint(x, y, speedtime, checktyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "item")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this item.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this item.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the speed of this item. Press enter to use the default speed.", "500");
if(x=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
m.add_item_tts("stamina", "st");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=get_map_sound_folders("objects/items/health/*");
if(ithealth.length()==0)
{
dlg_snd("Error. There are no health items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=get_map_sound_folders("objects/items/other/*");
if(itother.length()==0)
{
dlg_snd("Error. There are no other items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
if(itsm=="st")
{
string[] itstamina=get_map_sound_folders("objects/items/stamina/*");
if(itstamina.length()==0)
{
dlg_snd("Error. There are no stamina items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres28=m.run("Do you want this item to be autograbbed when stepped on?",true);
if(mres28==0)
{
speak("canceled");
return;
}
if(mres28==1)
{
itm=true;
}
if(mres28==2)
{
itm=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item "+x+" "+y+" "+speedtime+" "+itemtype+" "+itemtype2+" "+itm);
mapper.close();
spawn_obj(x, y, speedtime, itemtype, itemtype2, itm);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "item_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this item zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this item zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this item zone.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this item zone.", sel_top_set ? sel_top : "");
string sp=vd.input_box("", "Enter the spawn time of this item zone.");
if(x=="" and paxx=="" and y=="" and paxy=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
speedtime=string_to_number(sp);
setupmenu();
m.add_item_tts("health", "hp");
m.add_item_tts("other", "ot");
m.add_item_tts("stamina", "st");
int mres=m.run("Items menu",true);
string itsm=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(itsm=="hp")
{
string[] ithealth=get_map_sound_folders("objects/items/health/*");
if(ithealth.length()==0)
{
dlg_snd("Error. There are no health items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=healthsmenu();
if(res!="")
{
itemtype="health";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
if(itsm=="ot")
{
string[] itother=get_map_sound_folders("objects/items/other/*");
if(itother.length()==0)
{
dlg_snd("Error. There are no other items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=othersmenu();
if(res!="")
{
itemtype="other";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
if(itsm=="st")
{
string[] itstamina=get_map_sound_folders("objects/items/stamina/*");
if(itstamina.length()==0)
{
dlg_snd("Error. There are no stamina items available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=staminasmenu();
if(res!="")
{
itemtype="stamina";
t.destroy_sound(prevslot);
itemtype2=res;
}
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"item_zone "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+itemtype+" "+itemtype2);
mapper.close();
spawn_objzone(x, paxx, y, paxy, speedtime, itemtype, itemtype2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "lift")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this lift.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this lift.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this lift.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this lift.", sel_top_set ? sel_top : "");
string dr=vd.input_box("", "Enter the direction of this lift. 0 for down and up, and 1 for up and down.");
string sp=vd.input_box("", "Enter the speed of this lift.");
if(x=="" and paxx=="" and y=="" and paxy=="" and direction=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] liftform=get_map_sound_folders("objects/lifts/*");
if(liftform.length()==0)
{
dlg_snd("Error. There are no lifts available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=liftsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
lifttyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"lift "+x+" "+paxx+" "+y+" "+paxy+" "+direction+" "+speedtime+" "+tiletype+" "+volume+" "+pitch+" "+lifttyp+" "+volume2+" "+pitch2);
mapper.close();
spawn_lift(x, paxx, y, paxy, direction, speedtime, tiletype, volume, pitch, lifttyp, volume2, pitch2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "music_source")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this music source.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this music source.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this music source.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this music source.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=get_map_sound_folders("musics/*");
if(music.length()==0)
{
dlg_snd("Error. There are no music sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"music_source "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch);
mapper.close();
spawn_musicsource(x, paxx, y, paxy, mustyp, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "platform")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this platform.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this platform.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this platform.", sel_bottom_set ? sel_bottom : "");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch);
mapper.close();
spawn_platform(x, paxx, y, y, tiletype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "projectile")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this projectile.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this projectile.", sel_bottom_set ? sel_bottom : "");
string dr=vd.input_box("", "Enter the direction of this projectile. 0 for left, and 1 for right");
string hp=vd.input_box("", "Enter the health of this projectile.");
string hc=vd.input_box("", "Enter the maximum lives of this projectile. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this projectile.");
string sp=vd.input_box("", "Enter the speed of this projectile.");
string lev=vd.input_box("", "Enter the level of this projectile.");
string exper=vd.input_box("", "Enter the xp of this projectile.");
if(x=="" and y=="" and direction=="" and minhp=="" and card=="" and damage=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
direction=string_to_number(dr);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] projectile=get_map_sound_folders("npc/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
potype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the projectile attack you?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres9=m.run("Should the projectile move on the x axes?",true);
if(mres9==0)
{
speak("canceled");
return;
}
if(mres9==1)
{
mb=true;
}
if(mres9==2)
{
mb=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile "+x+" "+y+" "+direction+" "+minhp+" "+card+" "+damage+" "+speedtime+" "+lv+" "+xn+" "+potype+" "+fb+" "+mb);
mapper.close();
spawn_projectile(x, y, direction, minhp, minhp, card, damage, speedtime, lv, xn, potype, fb, mb);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "projectile_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this projectile zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this projectile zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this projectile zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this projectile zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] projectile=get_map_sound_folders("npc/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu(true);
if(res!="")
{
t.destroy_sound(prevslot);
potype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"projectile_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+potype);
mapper.close();
spawn_projzone(x, paxx, y, speedtime, potype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "reverb_space")
{
form.reset();
form.create_window("reverb space", false);
int mx=form.create_input_box("Enter the minimum x of this reverb space", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this reverb space", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this reverb space", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this reverb space", sel_top_set ? sel_top : "");
int rd=form.create_input_box("Enter the id of this reverb space", generate_custom_token(random(5, 10), "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"));
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
int dr=form.create_slider("&dry_mix: ", 50, 0, 100, "percent");
int wm=form.create_slider("&wet_mix: ", 50, 0, 100, "percent");
int rm=form.create_slider("&room_size: ", 50, 0, 100, "percent");
int dp=form.create_slider("dam&ping: ", 50, 0, 100, "percent");
int wt=form.create_slider("w&idth: ", 50, 0, 100, "percent");
int platile = form.create_list("te&st surface");
string[] plats = get_map_sound_folders("objects/platforms/*");
string current_tile = gmt(me.x, me.y);
int selected_index = 0;
for (uint i = 0; i < plats.length(); i++)
{
form.add_list_item(platile, plats[i], plats[i]);
if (plats[i] == current_tile)
selected_index = i;
}
form.set_list_position(platile, selected_index);
if(plats.length()!=0) tiletype = plats[selected_index];
int revok = form.create_button("&okay",true);
int revcn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
reverid=form.get_text(rd);
revdry = form.get_slider(dr) / 100.0;
revwet = form.get_slider(wm) / 100.0;
revsize = form.get_slider(rm) / 100.0;
revdamp = form.get_slider(dp) / 100.0;
revwidth = form.get_slider(wt) / 100.0;
int list_position = form.get_list_position(platile);
if (list_position != -1)
{
tiletype = form.get_list_item(platile, list_position);
}
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(revcn))
{
resume_pools();
speak("canceled");
game();
}
if (form.get_current_focus() == platile)
{
@temp.mixer = mixer();
if (key_down(KEY_SPACE) && keyrowhold == 1 && movetimer.elapsed >= movetime)
{
revdry = form.get_slider(dr) / 100.0;
revwet = form.get_slider(wm) / 100.0;
revsize = form.get_slider(rm) / 100.0;
revdamp = form.get_slider(dp) / 100.0;
revwidth = form.get_slider(wt) / 100.0;
string fxtype = "$test_reverb:freeverb:" + revdry + ":" + revwet + ":" + revsize + ":" + revdamp + ":" + revwidth;
temp.mixer.set_fx(fxtype);
temp.destroy_sound(tileslot);
tileslot = temp.play_stationary_extended(get_map_sound("objects/platforms/" + tiletype + "/*step*"), false, 0, 0, tilevolume, tilepitch);
movetimer.restart();
}
if (key_pressed(KEY_SPACE) && keyrowhold == 0)
{
revdry = form.get_slider(dr) / 100.0;
revwet = form.get_slider(wm) / 100.0;
revsize = form.get_slider(rm) / 100.0;
revdamp = form.get_slider(dp) / 100.0;
revwidth = form.get_slider(wt) / 100.0;
string fxtype = "$test_reverb:freeverb:" + revdry + ":" + revwet + ":" + revsize + ":" + revdamp + ":" + revwidth;
temp.mixer.set_fx(fxtype);
temp.destroy_sound(tileslot);
tileslot = temp.play_stationary_extended(get_map_sound("objects/platforms/" + tiletype + "/*step*"), false, 0, 0, tilevolume, tilepitch);
}
if (control_is_down() && key_repeating(KEY_L))
{
revdry = form.get_slider(dr) / 100.0;
revwet = form.get_slider(wm) / 100.0;
revsize = form.get_slider(rm) / 100.0;
revdamp = form.get_slider(dp) / 100.0;
revwidth = form.get_slider(wt) / 100.0;
string fxtype = "$test_reverb:freeverb:" + revdry + ":" + revwet + ":" + revsize + ":" + revdamp + ":" + revwidth;
temp.mixer.set_fx(fxtype);
temp.destroy_sound(tileslot);
tileslot = temp.play_stationary_extended(get_map_sound("objects/platforms/" + tiletype + "/*land*"), false, 0, 0, tilevolume, tilepitch);
}
if (control_is_down() && key_repeating(KEY_H))
{
revdry = form.get_slider(dr) / 100.0;
revwet = form.get_slider(wm) / 100.0;
revsize = form.get_slider(rm) / 100.0;
revdamp = form.get_slider(dp) / 100.0;
revwidth = form.get_slider(wt) / 100.0;
string fxtype = "$test_reverb:freeverb:" + revdry + ":" + revwet + ":" + revsize + ":" + revdamp + ":" + revwidth;
temp.mixer.set_fx(fxtype);
temp.destroy_sound(tileslot);
tileslot = temp.play_stationary_extended(get_map_sound("objects/platforms/" + tiletype + "/*fall*"), false, 0, 0, tilevolume, tilepitch);
}
}
if(form.is_pressed(revok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(rd)=="")
{
speak("Id is required.");
form.focus(rd);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"reverb "+x+" "+paxx+" "+y+" "+paxy+" "+reverid+" "+round(revdry, 2)+" "+round(revwet, 2)+" "+round(revsize, 2)+" "+round(revdamp, 2)+" "+round(revwidth, 2));
mapper.close();
spawn_reverb_space(x, paxx, y, paxy, reverid, revdry, revwet, revsize, revdamp, revwidth);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "robot")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this robot.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this robot.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal atack range of this robot.");
string rng2=vd.input_box("", "Enter the vertical atack range of this robot.");
string rng3=vd.input_box("", "Enter the horizontal seeing range of this robot.");
string rng4=vd.input_box("", "Enter the vertical seeing range of this robot.");
string hp=vd.input_box("", "Enter the health of this robot.");
string hc=vd.input_box("", "Enter the maximum lives of this robot. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this robot.");
string ft=vd.input_box("", "Enter the fire time of this robot.");
string sp=vd.input_box("", "Enter the speed of this robot.");
string lev=vd.input_box("", "Enter the level of this robot.");
string exper=vd.input_box("", "Enter the xp of this robot.");
if(x=="" and y=="" and robrange=="" and robrange2=="" and robrange3=="" and robrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
robrange=string_to_number(rng);
robrange2=string_to_number(rng2);
robrange3=string_to_number(rng3);
robrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] robot=get_map_sound_folders("npc/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
rotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the robot attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the robot move on the x axes?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the robot move on the y axes?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the robot drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot "+x+" "+y+" "+robrange+" "+robrange2+" "+robrange3+" "+robrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+rotype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_robot(x, y, robrange, robrange2, robrange3, robrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, rotype, fb, mb, mb2, itms);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "robot_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this robot zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this robot zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this robot zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this robot zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] robot=get_map_sound_folders("npc/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu(true);
if(res!="")
{
t.destroy_sound(prevslot);
rotype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"robot_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+rotype);
mapper.close();
spawn_robotzone(x, paxx, y, speedtime, rotype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "safe_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this safe zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this safe zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this safe zone.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this safe zone.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] safes=get_map_sound_folders("objects/safe zones/*");
if(safes.length()==0)
{
dlg_snd("Error. There are no safe zones available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=safsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
saftyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"safe_zone "+x+" "+paxx+" "+y+" "+paxy+" "+saftyp);
mapper.close();
spawn_safezone(x, paxx, y, paxy, saftyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "security_camera")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this security camera.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this security camera.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal seeing range of this security camera.");
string rng2=vd.input_box("", "Enter the vertical seeing range of this security camera.");
string dr=vd.input_box("", "Enter the direction of this security camera. 1 for left, and 2 for right.");
string sp=vd.input_box("", "Enter the speed of this security camera.");
string hp=vd.input_box("", "Enter the health of this security camera.");
string lev=vd.input_box("", "Enter the level of this security camera.");
string exper=vd.input_box("", "Enter the xp of this security camera.");
if(x=="" and y=="" and camrange=="" and camrange2=="" and direction=="" and speedtime=="" and minhp=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
camrange=string_to_number(rng);
camrange2=string_to_number(rng2);
direction=string_to_number(dr);
speedtime=string_to_number(sp);
minhp=string_to_number(hp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] camera=get_map_sound_folders("objects/cameras/*");
if(camera.length()==0)
{
dlg_snd("Error. There are no cameras available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=camsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
camtyp=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"camera "+x+" "+y+" "+camrange+" "+camrange2+" "+direction+" "+speedtime+" "+minhp+" "+lv+" "+xn+" "+camtyp);
mapper.close();
spawn_camera(x, y, camrange, camrange2, direction, speedtime, minhp, minhp, lv, xn, camtyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "sign")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this sign.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this sign.", sel_bottom_set ? sel_bottom : "");
vd.set_disallowed_chars("", false, "This character is not allowed.");
string text=vd.input_box("", "Enter the text of this sign.");
if(x=="" and y=="" and txt=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
txt=text;
string[] signs=get_map_sound_folders("objects/signs/*");
if(signs.length()==0)
{
dlg_snd("Error. There are no signs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=signsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
signtyp=res;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this sign to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Would you like the sign sound to be looped?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
lpg=true;
}
if(mres==2)
{
lpg=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sign "+x+" "+y+" "+txt+" "+signtyp+" "+dmd+" "+lpg);
mapper.close();
spawn_sign(x, y, txt, signtyp, dmd, lpg);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "sound_source")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this sound source.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this sound source.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this sound source.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this sound source.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=get_map_sound_folders("sources/*");
if(source.length()==0)
{
dlg_snd("Error. There are no sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
sorcetyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"sound_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch);
mapper.close();
spawn_soundsource(x, paxx, y, paxy, sorcetyp, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "spike")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this spike.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this spike.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this spike.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this spike.", sel_top_set ? sel_top : "");
string hp=vd.input_box("", "Enter the health of this spike. Press enter to use the default health.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this spike.");
string sp=vd.input_box("", "Enter the speed of this spike.");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] spike=get_map_sound_folders("objects/spikes/*");
if(spike.length()==0)
{
dlg_snd("Error. There are no spikes available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=spikesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
spiktype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Do you want this spike to be destroyable?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
dmd=true;
}
if(mres==2)
{
dmd=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spike "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+damage+" "+speedtime+" "+spiktype+" "+dmd);
mapper.close();
spawn_spike(x, paxx, y, paxy, minhp, minhp, damage, speedtime, spiktype, dmd);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "spawnpoint")
{
form.reset();
form.create_window("spawnpoint", false);
int mx=form.create_input_box("Enter the x of this spawnpoint", sel_left_set ? sel_left : "");
int my=form.create_input_box("Enter the y of this spawnpoint", sel_bottom_set ? sel_bottom : "");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
y=string_to_number(form.get_text(my));
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("X is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"spawnpoint "+x+" "+y);
mapper.close();
create_spawnpoint(x, y);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "staircase")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this staircase.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this staircase.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this staircase.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this staircase.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"staircase "+x+" "+paxx+" "+y+" "+paxy+" "+tiletype+" "+volume+" "+pitch);
mapper.close();
spawn_staircase(x, paxx, y, paxy, tiletype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "switch")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string scx=vd.input_box("", "Enter the x of this switch.", sel_left_set ? sel_left : "");
string scy=vd.input_box("", "Enter the y of this switch.", sel_bottom_set ? sel_bottom : "");
if(x=="" and y=="")
return;
x=string_to_number(scx);
y=string_to_number(scy);
string[] switcher=get_map_sound_folders("objects/switches/*");
if(switcher.length()==0)
{
dlg_snd("Error. There are no switches available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=switchesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
switchtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres=m.run("Should this switch be auto activated?",true);
if(mres==0)
{
speak("canceled");
return;
}
if(mres==1)
{
trg=true;
}
if(mres==2)
{
trg=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should this switch be single-use only?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
sse=true;
}
if(mres2==2)
{
sse=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"switch "+x+" "+y+" "+switchtyp+" "+trg+" "+sse);
mapper.close();
spawn_switcher(x, y, switchtyp, trg, sse);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "teleporter")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sx=vd.input_box("", "Enter the starting x of this teleporter.", sel_left_set ? sel_left : "");
string sy=vd.input_box("", "Enter the starting y of this teleporter.", sel_bottom_set ? sel_bottom : "");
string nx=vd.input_box("", "Enter the finishing x of this teleporter.", sel_right_set ? sel_right : "");
string ny=vd.input_box("", "Enter the finishing y of this teleporter.", sel_top_set ? sel_top : "");
string rng=vd.input_box("", "Enter the horizontal seeing range of this teleporter.");
string rng2=vd.input_box("", "Enter the vertical seeing range of this teleporter.");
string sp=vd.input_box("", "Enter the speed of this teleporter.");
if(x=="" and y=="" and x2=="" and y2=="" and telrange=="" and telrange2=="" and speedtime=="")
return;
x=string_to_number(sx);
y=string_to_number(sy);
x2=string_to_number(nx);
y2=string_to_number(ny);
telrange=string_to_number(rng);
telrange2=string_to_number(rng2);
speedtime=string_to_number(sp);
string[] teleporter=get_map_sound_folders("objects/teleporters/*");
if(teleporter.length()==0)
{
dlg_snd("Error. There are no teleporters available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=teleportersmenu();
if(res!="")
{
t.destroy_sound(prevslot);
teltype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres16=m.run("Should the teleporter move on the x axes?",true);
if(mres16==0)
{
speak("canceled");
return;
}
if(mres16==1)
{
mb=true;
}
if(mres16==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres17=m.run("Should the teleporter move on the y axes?",true);
if(mres17==0)
{
speak("canceled");
return;
}
if(mres17==1)
{
mb2=true;
}
if(mres17==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should this teleporter be single-use only?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
sse=true;
}
if(mres18==2)
{
sse=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"teleporter "+x+" "+y+" "+x2+" "+y2+" "+telrange+" "+telrange2+" "+speedtime+" "+teltype+" "+mb+" "+mb2+" "+sse);
mapper.close();
spawn_teleporter(x, y, x2, y2, telrange, telrange2, speedtime, teltype, mb, mb2, sse);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "text_square")
{
form.reset();
form.create_window("text square", false);
int mx=form.create_input_box("Enter the x of this text square", sel_left_set ? sel_left : "");
int my=form.create_input_box("Enter the y of this text square", sel_bottom_set ? sel_bottom : "");
int tqtext=form.create_input_box("Enter the text of this text square");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
y=string_to_number(form.get_text(my));
txt=form.get_text(tqtext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("X is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(tqtext)=="")
{
speak("Text is required.");
form.focus(tqtext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"text_square "+x+" "+y+" "+txt);
mapper.close();
spawn_text_square(x, y, txt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "time_bomb")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this time bomb.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this time bomb.", sel_bottom_set ? sel_bottom : "");
string dm=vd.input_box("", "Enter the maximum attack of this time bomb.");
string sp=vd.input_box("", "Enter the speed of this time bomb.");
if(x=="" and y=="" and damage=="" and speedtime=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
string[] timebomb=get_map_sound_folders("objects/time bombs/*");
if(timebomb.length()==0)
{
dlg_snd("Error. There are no time bombs available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=timbombsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
timbotype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timebomb "+x+" "+y+" "+damage+" "+speedtime+" "+timbotype);
mapper.close();
spawn_timebomb(x, y, damage, speedtime, timbotype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "timed_source")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this timed source.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this timed source.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this timed source.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this timed source.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] source=get_map_sound_folders("sources/*");
if(source.length()==0)
{
dlg_snd("Error. There are no sources available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=sorcesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
sorcetyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the speed of this timed source.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_source "+x+" "+paxx+" "+y+" "+paxy+" "+sorcetyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedsource(x, paxx, y, paxy, volume, pitch, speedtime, sorcetyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "timed_music")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this timed music.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this timed music.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this timed music.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this timed music.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] music=get_map_sound_folders("musics/*");
if(music.length()==0)
{
dlg_snd("Error. There are no musics available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=musicsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
mustyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the speed of this timed music.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_music "+x+" "+paxx+" "+y+" "+paxy+" "+mustyp+" "+volume+" "+pitch+" "+speedtime);
mapper.close();
spawn_timedmusic(x, paxx, y, paxy, volume, pitch, speedtime, mustyp);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "timed_text")
{
form.reset();
form.create_window("timed text", false);
int mx=form.create_input_box("Enter the minimum x of this timed text", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this timed text", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this timed text", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this timed text", sel_top_set ? sel_top : "");
int sp=form.create_input_box("Enter the speed of this timed text");
int tmtext=form.create_input_box("Enter the text of this timed text");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(sp, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
speedtime=string_to_number(form.get_text(sp));
txt=form.get_text(tmtext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(sp)=="")
{
speak("Speed is required.");
form.focus(sp);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(tmtext)=="")
{
speak("Text is required.");
form.focus(tmtext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"timed_text "+x+" "+paxx+" "+y+" "+paxy+" "+speedtime+" "+txt);
mapper.close();
spawn_timedtext(x, paxx, y, paxy, speedtime, txt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "travelpoint")
{
form.reset();
form.create_window("travelpoint", false);
int mx=form.create_input_box("Enter the minimum x of this travelpoint", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this travelpoint", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this travelpoint", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this travelpoint", sel_top_set ? sel_top : "");
int dmap=form.create_input_box("Enter the destenation map of this travelpoint");
int dx=form.create_input_box("Enter the destenation x of this travelpoint", sel_left_set ? sel_left : "");
int dy=form.create_input_box("Enter the destenation y of this travelpoint", sel_bottom_set ? sel_bottom : "");
int dtext=form.create_input_box("Enter the destenation text of this travelpoint");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(dx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(dy, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
txt=form.get_text(dmap);
x2=string_to_number(form.get_text(dx));
y2=string_to_number(form.get_text(dy));
txt2=form.get_text(dtext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(dmap)=="")
{
speak("Destenation map is required.");
form.focus(dmap);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(dx)=="")
{
speak("Destenation x is required.");
form.focus(dx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(dy)=="")
{
speak("Destenation y is required.");
form.focus(dy);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(dtext)=="")
{
speak("Destenation text is required.");
form.focus(dtext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"travelpoint "+x+" "+paxx+" "+y+" "+paxy+" "+txt+" "+x2+" "+y2+" "+txt2);
mapper.close();
spawn_travelpoint(x, paxx, y, paxy, txt, x2, y2, txt2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "tts_enemie")
{
form.reset();
form.create_window("tts_enemie", false);
int mx=form.create_input_box("Enter the x of this tts_enemie", sel_left_set ? sel_left : "");
int my=form.create_input_box("Enter the y of this tts_enemie", sel_bottom_set ? sel_bottom : "");
int hp=form.create_input_box("Enter the health of this tts_enemie");
int sp=form.create_input_box("Enter the speed of this tts_enemie");
int ttsenetext=form.create_input_box("Enter the text of this tts_enemie: seperated by quotes");
int rt  = form.create_slider("rate: ", 0, -10, 10);
int vl  = form.create_slider("volume: ", 100, 0, 100);
int pt  = form.create_slider("pitch: ", 0, -10, 10);
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(hp, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(sp, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
y=string_to_number(form.get_text(my));
minhp=string_to_number(form.get_text(hp));
speedtime=string_to_number(form.get_text(sp));
txt=form.get_text(ttsenetext);
rate = form.get_slider(rt);
volume = form.get_slider(vl);
pitch = form.get_slider(pt);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("X is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(hp)=="")
{
speak("Health is required.");
form.focus(hp);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(sp)=="")
{
speak("Speed is required.");
form.focus(sp);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(ttsenetext)=="")
{
speak("Text is required.");
form.focus(ttsenetext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"ttsenemie "+x+" "+y+" "+minhp+" "+speedtime+" "+txt+" "+rate+" "+volume+" "+pitch);
mapper.close();
spawn_ttsenemie(x, y, minhp, minhp, speedtime, txt, rate, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "turret")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this turret.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this turret.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this turret.");
string hc=vd.input_box("", "Enter the maximum lives of this turret. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this turret.");
string ft=vd.input_box("", "Enter the fire time of this turret.");
string lt=vd.input_box("", "Enter the launch time of this turret.");
string sp=vd.input_box("", "Enter the speed of this turret.");
string lev=vd.input_box("", "Enter the level of this turret.");
string exper=vd.input_box("", "Enter the xp of this turret.");
if(x=="" and y=="" and minhp=="" and card=="" and damage=="" and firetime=="" and launchtime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
launchtime=string_to_number(lt);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] turret=get_map_sound_folders("npc/turrets/*");
if(turret.length()==0)
{
dlg_snd("Error. There are no turrets available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=turretsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tutype=res;
}
}
setupmenu();
m.add_item_tts("animal","an2");
m.add_item_tts("human", "hum2");
m.add_item_tts("projectile","pj2");
m.add_item_tts("robot","rt2");
m.add_item_tts("zombie","zb2");
int mres=m.run("What would you like this turret to spawn?",true);
string turem=m.get_item_name(mres);
if(mres==0)
{
speak("canceled");
return;
}
if(turem=="an2")
{
string[] animal=get_map_sound_folders("npc/animals/*");
if(animal.length()==0)
{
dlg_snd("Error. There are no animals available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=animalsmenu();
if(res!="")
{
tutype2="animal";
t.destroy_sound(prevslot);
tutype3=res;
}
}
}
if(turem=="hum2")
{
string[] human=get_map_sound_folders("npc/humans/*");
if(human.length()==0)
{
dlg_snd("Error. There are no humans available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=humansmenu();
if(res!="")
{
tutype2="human";
t.destroy_sound(prevslot);
tutype3=res;
}
}
}
if(turem=="pj2")
{
string[] projectile=get_map_sound_folders("npc/projectiles/*");
if(projectile.length()==0)
{
dlg_snd("Error. There are no projectiles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=projesmenu();
if(res!="")
{
tutype2="projectile";
t.destroy_sound(prevslot);
tutype3=res;
}
}
}
if(turem=="rt2")
{
string[] robot=get_map_sound_folders("npc/robots/*");
if(robot.length()==0)
{
dlg_snd("Error. There are no robots available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=robotsmenu();
if(res!="")
{
tutype2="robot";
t.destroy_sound(prevslot);
tutype3=res;
}
}
}
if(turem=="zb2")
{
string[] zombie=get_map_sound_folders("npc/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
tutype2="zombie";
t.destroy_sound(prevslot);
tutype3=res;
}
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres18=m.run("Should the turret attack you?",true);
if(mres18==0)
{
speak("canceled");
return;
}
if(mres18==1)
{
fb=true;
}
if(mres18==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres19=m.run("Should the turret move on the x axes?",true);
if(mres19==0)
{
speak("canceled");
return;
}
if(mres19==1)
{
mb=true;
}
if(mres19==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres20=m.run("Should the turret move on the y axes?",true);
if(mres20==0)
{
speak("canceled");
return;
}
if(mres20==1)
{
mb2=true;
}
if(mres20==2)
{
mb2=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"turret "+x+" "+y+" "+minhp+" "+card+" "+damage+" "+firetime+" "+launchtime+" "+speedtime+" "+lv+" "+xn+" "+tutype+" "+tutype2+" "+tutype3+" "+fb+" "+mb+" "+mb2);
mapper.close();
spawn_turret(x, y, minhp, minhp, card, damage, firetime, launchtime, speedtime, lv, xn, tutype, tutype2, tutype3, fb, mb, mb2);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "vehicle")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this vehicle.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this vehicle.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this vehicle. Press enter to use the default health.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this vehicle.");
string sp=vd.input_box("", "Enter the base speed of this vehicle. Press enter to use the default base speed.", "500");
string sp2=vd.input_box("", "Enter the accel speed of this vehicle. Press enter to use the default accel speed.", "100");
string sp3=vd.input_box("", "Enter the brake speed of this vehicle. Press enter to use the default brake speed.", "50");
if(x=="" and y=="" and minhp=="" and damage=="" and speedtime=="" and speedtime2=="" and speedtime3=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
minhp=string_to_number(hp);
damage=string_to_number(dm);
speedtime=string_to_number(sp);
speedtime2=string_to_number(sp2);
speedtime3=string_to_number(sp3);
string[] vehicle=get_map_sound_folders("objects/vehicles/*");
if(vehicle.length()==0)
{
dlg_snd("Error. There are no vehicles available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=vehsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
vehtyp=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres8=m.run("Should the vehicle hit other entities while moving?",true);
if(mres8==0)
{
speak("canceled");
return;
}
if(mres8==1)
{
fb=true;
}
if(mres8==2)
{
fb=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vehicle "+x+" "+y+" "+minhp+" "+damage+" "+speedtime+" "+speedtime2+" "+speedtime3+" "+vehtyp+" "+fb);
mapper.close();
spawn_vehicle(x, y, minhp, minhp, damage, speedtime, speedtime2, speedtime3, vehtyp, fb);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "vanishing_hazard")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this vanishing hazard.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this vanishing hazard.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this vanishing hazard.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this vanishing hazard.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] hazardtype=get_map_sound_folders("objects/hazards/*");
if(hazardtype.length()==0)
{
dlg_snd("Error. There are no hazards available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=hazardsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
hazztype=res;
}
}
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the speed of this vanishing hazard.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vanishing_hazard "+x+" "+paxx+" "+y+" "+paxy+" "+hazztype+" "+speedtime);
mapper.close();
spawn_vanishing_hazard(x, paxx, y, paxy, hazztype, speedtime);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "vanishing_platform")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this vanishing platform.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this vanishing platform.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this vanishing platform.", sel_bottom_set ? sel_bottom : "");
if(x=="" and paxx=="" and y=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
string[] platform=get_map_sound_folders("objects/platforms/*");
if(platform.length()==0)
{
dlg_snd("Error. There are no platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=platsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
tiletype=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
string[] vplatform=get_map_sound_folders("objects/vanishing platforms/*");
if(vplatform.length()==0)
{
dlg_snd("Error. There are no vanishing platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=vplatsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
vplattyp=res;
}
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres2= s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres2==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume2=s.get_item_value(0);
pitch2=s.get_item_value(1);
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string sp=vd.input_box("", "Enter the speed of this vanishing platform.");
if(speedtime=="")
return;
speedtime=string_to_number(sp);
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"vanishing_platform "+x+" "+paxx+" "+y+" "+tiletype+" "+volume+" "+pitch+" "+vplattyp+" "+volume2+" "+pitch2+" "+speedtime);
mapper.close();
spawn_vanishing_platform(x, paxx, y, y, tiletype, volume, pitch, vplattyp, volume2, pitch2, speedtime);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "command_blocker")
{
form.reset();
form.create_window("command blocker", false);
int mx=form.create_input_box("Enter the minimum x of this command blocker", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this command blocker", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this command blocker", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this command blocker", sel_top_set ? sel_top : "");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
int comlist = form.create_list("Select the slash commands to block or allow", 0, true);
string[] allcommands = {"build", "bl", "changemap", "cm", "delmap", "dm", "draw", "dr", "getall", "gl", "give", "gv", "go", "gozone", "gz", "help", "hp", "invclear", "ic", "kill", "kn", "killall", "kl", "maps", "mp", "menu", "mu", "newmap", "nm", "play", "pl", "preffs", "pf", "rawmap", "rp", "rawdata", "rd", "relchar", "rc", "relmap", "rm", "relshields", "rs", "relscripts", "rt", "relweps", "rw", "scriptmode", "sm", "speek", "sp", "stats", "st", "suicide", "sd"};
for (uint i = 0; i < allcommands.length(); i++)
{
form.add_list_item(comlist, allcommands[i], "", -1, false);
}
int cw = form.create_checkbox("Enable whitelist", false);
int comok = form.create_button("&okay",true);
int comcn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
ctl = form.is_checked(cw);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(comcn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(comok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
comslist.resize(0);
        int[] selected = form.get_checked_list_items(comlist);
        for (uint i = 0; i < selected.length(); i++)
{
            string cmd = form.get_list_item(comlist, selected[i]);
            comslist.insert_last(cmd);
        }
        if (comslist.length() == 0)
{
            speak("You must select at least one command.");
form.focus(comlist);
continue;
        }
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"cblocker "+x+" "+paxx+" "+y+" "+paxy+" "+string_join(comslist, ", ")+" "+ctl);
mapper.close();
spawn_cblocker(x, paxx, y, paxy, comslist, ctl);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
if(buildtype == "destroyable_platform")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this destroyable platform.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this destroyable platform.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this destroyable platform.", sel_bottom_set ? sel_bottom : "");
string hp=vd.input_box("", "Enter the health of this destroyable platform. Press enter to use the default health.", "1");
if(x=="" and paxx=="" and y=="" and minhp=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
minhp=string_to_number(hp);
string[] destplat=get_map_sound_folders("objects/platforms/*");
if(destplat.length()==0)
{
dlg_snd("Error. There are no destroyable platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=destplatsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
destplattype=res;
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dest_plat "+x+" "+paxx+" "+y+" "+minhp+" "+destplattype+" "+volume+" "+pitch);
mapper.close();
spawn_dest_plat(x, paxx, y, y, minhp, minhp, destplattype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "destroyable_staircase")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this destroyable staircase.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this destroyable staircase.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this destroyable staircase.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this destroyable staircase.", sel_top_set ? sel_top : "");
string hp=vd.input_box("", "Enter the health of this destroyable staircase. Press enter to use the default health.", "1");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
string[] destplat=get_map_sound_folders("objects/platforms/*");
if(destplat.length()==0)
{
dlg_snd("Error. There are no destroyable platforms available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=destplatsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
destplattype=res;
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dest_staircase "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+destplattype+" "+volume+" "+pitch);
mapper.close();
spawn_dest_staircase(x, paxx, y, paxy, minhp, minhp, destplattype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "destroyable_wall")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this destroyable wall.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this destroyable wall.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this destroyable wall.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this destroyable wall.", sel_top_set ? sel_top : "");
string hp=vd.input_box("", "Enter the health of this destroyable wall. Press enter to use the default health.", "1");
if(x=="" and paxx=="" and y=="" and paxy=="" and minhp=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
minhp=string_to_number(hp);
string[] border=get_map_sound_folders("objects/walls/*");
if(border.length()==0)
{
dlg_snd("Error. There are no destroyable walls available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=destwallsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
destwalltype=res;
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"dest_wall "+x+" "+paxx+" "+y+" "+paxy+" "+minhp+" "+destwalltype+" "+volume+" "+pitch);
mapper.close();
spawn_dest_wall(x, paxx, y, paxy, minhp, minhp, destwalltype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "wall")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this wall.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this wall.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the minimum y of this wall.", sel_bottom_set ? sel_bottom : "");
string my2=vd.input_box("", "Enter the maximum y of this wall.", sel_top_set ? sel_top : "");
if(x=="" and paxx=="" and y=="" and paxy=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
paxy=string_to_number(my2);
string[] border=get_map_sound_folders("objects/walls/*");
if(border.length()==0)
{
dlg_snd("Error. There are no walls available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=wallsmenu();
if(res!="")
{
t.destroy_sound(prevslot);
walltype=res;
}
create_slider();
s.add_slider_item("volume", -100.0, 0.0, 0.0, 1.0);
s.add_slider_item("pitch", 0.0, 500.0, 100.0, 1.0);
int sres = s.run_slider("Effects designer. Press tab or shift tab to cycle through the effect parameters. Press the arrow keys to increase or decrease the value you're currently focused on. Press the home or end key to directly jump to the minimum or maximum value of the parameter. Press the enter key when you're done shaping the effect to your liking.");
if (sres==0)
{
resume_pools();
speak("Canceled");
return;
}
resume_pools();
volume=s.get_item_value(0);
pitch=s.get_item_value(1);
}
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"wall "+x+" "+paxx+" "+y+" "+paxy+" "+walltype+" "+volume+" "+pitch);
mapper.close();
spawn_wall(x, paxx, y, paxy, walltype, volume, pitch);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "zombie")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the x of this zombie.", sel_left_set ? sel_left : "");
string my=vd.input_box("", "Enter the y of this zombie.", sel_bottom_set ? sel_bottom : "");
string rng=vd.input_box("", "Enter the horizontal atack range of this zombie.");
string rng2=vd.input_box("", "Enter the vertical atack range of this zombie.");
string rng3=vd.input_box("", "Enter the horizontal seeing range of this zombie.");
string rng4=vd.input_box("", "Enter the vertical seeing range of this zombie.");
string hp=vd.input_box("", "Enter the health of this zombie.");
string hc=vd.input_box("", "Enter the maximum lives of this zombie. Press enter to use the default lives.", "1");
string dm=vd.input_box("", "Enter the maximum attack of this zombie.");
string ft=vd.input_box("", "Enter the fire time of this zombie.");
string sp=vd.input_box("", "Enter the speed of this zombie.");
string lev=vd.input_box("", "Enter the level of this zombie.");
string exper=vd.input_box("", "Enter the xp of this zombie.");
if(x=="" and y=="" and zombrange=="" and zombrange2=="" and zombrange3=="" and zombrange4=="" and minhp=="" and card=="" and damage=="" and firetime=="" and speedtime=="" and lv=="" and xn=="")
return;
x=string_to_number(mx);
y=string_to_number(my);
zombrange=string_to_number(rng);
zombrange2=string_to_number(rng2);
zombrange3=string_to_number(rng3);
zombrange4=string_to_number(rng4);
minhp=string_to_number(hp);
card=string_to_number(hc);
damage=string_to_number(dm);
firetime=string_to_number(ft);
speedtime=string_to_number(sp);
lv=string_to_number(lev);
xn=string_to_number(exper);
string[] zombie=get_map_sound_folders("npc/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu();
if(res!="")
{
t.destroy_sound(prevslot);
zotype=res;
}
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres2=m.run("Should the zombie attack you?",true);
if(mres2==0)
{
speak("canceled");
return;
}
if(mres2==1)
{
fb=true;
}
if(mres2==2)
{
fb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres3=m.run("Should the zombie move on the x axes?",true);
if(mres3==0)
{
speak("canceled");
return;
}
if(mres3==1)
{
mb=true;
}
if(mres3==2)
{
mb=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres4=m.run("Should the zombie move on the y axes?",true);
if(mres4==0)
{
speak("canceled");
return;
}
if(mres4==1)
{
mb2=true;
}
if(mres4==2)
{
mb2=false;
}
setupmenu();
m.wrap_sound="none.ogg";
m.click_sound=get_pack_sound("misc/menu1.ogg");
m.enter_sound=get_pack_sound("misc/menu2.ogg");
m.open_sound=get_pack_sound("misc/menu3.ogg");
m.add_item_tts("yes");
m.add_item_tts("no");
int mres5=m.run("Should the zombie drop an item after killing it?",true);
if(mres5==0)
{
speak("canceled");
return;
}
if(mres5==1)
{
itms=true;
}
if(mres5==2)
{
itms=false;
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie "+x+" "+y+" "+zombrange+" "+zombrange2+" "+zombrange3+" "+zombrange4+" "+minhp+" "+card+" "+damage+" "+firetime+" "+speedtime+" "+lv+" "+xn+" "+zotype+" "+fb+" "+mb+" "+mb2+" "+itms);
mapper.close();
spawn_zombie(x, y, zombrange, zombrange2, zombrange3, zombrange4, minhp, minhp, card, damage, firetime, speedtime, lv, xn, zotype, fb, mb, mb2, itms);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "zombie_zone")
{
vd.set_disallowed_chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !@#$%^&*()[]{};:'\"\\|,.<>?/+=`~", false, "This character is not allowed.");
string mx=vd.input_box("", "Enter the minimum x of this zombie zone.", sel_left_set ? sel_left : "");
string mx2=vd.input_box("", "Enter the maximum x of this zombie zone.", sel_right_set ? sel_right : "");
string my=vd.input_box("", "Enter the y of this zombie zone.", sel_bottom_set ? sel_bottom : "");
string sp=vd.input_box("", "Enter the spawn time of this zombie zone.");
if(x=="" and paxx=="" and y=="" and speedtime=="")
return;
x=string_to_number(mx);
paxx=string_to_number(mx2);
y=string_to_number(my);
speedtime=string_to_number(sp);
string[] zombie=get_map_sound_folders("npc/zombies/*");
if(zombie.length()==0)
{
dlg_snd("Error. There are no zombies available to view. Press enter to continue.");
resume_pools();
return;
}
else
{
string res=zombiesmenu(true);
if(res!="")
{
t.destroy_sound(prevslot);
zotype=res;
}
}
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zombie_zone "+x+" "+paxx+" "+y+" "+speedtime+" "+zotype);
mapper.close();
spawn_zombiezone(x, paxx, y, speedtime, zotype);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
}
if(buildtype == "zone")
{
form.reset();
form.create_window("zone", false);
int mx=form.create_input_box("Enter the minimum x of this zone", sel_left_set ? sel_left : "");
int mx2=form.create_input_box("Enter the maximum x of this zone", sel_right_set ? sel_right : "");
int my=form.create_input_box("Enter the minimum y of this zone", sel_bottom_set ? sel_bottom : "");
int my2=form.create_input_box("Enter the maximum y of this zone", sel_top_set ? sel_top : "");
int zntext=form.create_input_box("Enter the text of this zone");
string disallowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ `!@#$%^&*()[]{};:'\"\\|,<>?_/+=~";
form.set_disallowed_chars(mx, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(mx2, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my, disallowed_chars, false, "This character is not allowed.");
form.set_disallowed_chars(my2, disallowed_chars, false, "This character is not allowed.");
int ok = form.create_button("&okay",true);
int cn = form.create_button("&cancel");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
while (true)
{
key_echocheck(form);
form.monitor();
wait(5);
x=string_to_number(form.get_text(mx));
paxx=string_to_number(form.get_text(mx2));
y=string_to_number(form.get_text(my));
paxy=string_to_number(form.get_text(my2));
txt=form.get_text(zntext);
if(key_pressed(KEY_ESCAPE))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(cn))
{
resume_pools();
speak("canceled");
game();
}
if(form.is_pressed(ok))
{
if(form.get_text(mx)=="")
{
speak("Minimum x is required.");
form.focus(mx);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(mx2)=="")
{
speak("Maximum x is required.");
form.focus(mx2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my)=="")
{
speak("Minimum y is required.");
form.focus(my);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(my2)=="")
{
speak("Maximum y is required.");
form.focus(my2);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else if(form.get_text(zntext)=="")
{
speak("Zone text is required.");
form.focus(zntext);
spool.play_stationary(get_pack_sound("menus/"+menutype+"/*open*"),false);
}
else
{
resume_pools();
mapper.open("data/maps/decompiled/"+mapname+"/"+"info.sif","ab");
mapdata=mapper.read();
mapper.write("\r\n"+"zone "+x+" "+paxx+" "+y+" "+paxy+" "+txt);
mapper.close();
spawn_zone(x, paxx, y, paxy, txt);
load_map(mapname, mapowner);
mpool.play_stationary(get_pack_sound("misc/mapupdate.ogg"),false);
speak("Map updated.");
game();
}
}
}
}
}
